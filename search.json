[{"title":"【K8s】组件","date":"2026-01-25T02:00:00.000Z","url":"/blog/2026/01/25/K8s/K8s%E7%BB%84%E4%BB%B6/","tags":[["K8s","/blog/tags/K8s/"]],"categories":[["K8s","/blog/categories/K8s/"]],"content":"Namespace 组件Namespace 组件介绍 资源隔离：如测试环境下的资源，开发环境下的资源。 权限隔离：测试环境的 Namespace 只给测试用，开发环境 Namespace 只给开发用。 资源配额：可以为不同的 Namespace 分配硬件资源，如 CPU、内存等。 Namespace 的 yaml 配置文件 使用 describe 查看详细信息 Pod 组件Pod 组件介绍程序运行在容器中，容器运行在 Pod 中，k8s 通过管理 Pod 进而管理程序。 一个 Pod 里面可以运行一个或多个容器。 Pod 的 yaml 配置文件 使用 -o wide 查看 Pod 信息 列名称 描述 NAME pod 的名称。 READY 描述 pod 里面有多少个容器，有多少个容器正在运行中。 STATUS 描述 pod 的状态，Running 指运行中，Terminating 指正在删除 pod。 RESTARTS pod 重启次数。 AGE pod 运行了多少时间。 IP k8s 给 pod 分配的 ip。 NODE pod 运行在集群哪个节点上。 使用 describe 查看详细信息 Deployment 组件Deployment 组件介绍Deployment 是 Pod 控制器，用来管理 Pod 的生命周期。Deployment 能够在 Pod 出现故障时，自动重启 Pod 或创建 Pod。 Deployment 的 yaml 配置文件 使用 -o wide 查看 Deployment 信息 列名称 描述 NAME deployment 的名称。 READY 描述 deployment 里面有多少个 pod，有多少个 pod 正在运行中。 UP-TO-DATE 有多少 pod 使用的是当前 deployment 最新配置。 AVAILABLE 可以对外提供服务的 pod 数。 AGE deployment 运行了多少时间。 CONTAINERS pod 中容器的名字。 IMAGES 容器使用的镜像。 SELECTOR 标签选择器，通过标签选择器来确定控制哪些 pod。 使用 describe 查看详细信息 Label 组件Label 组件介绍给资源对象添加标签，通过管理标签来管理一组资源对象，如管理一组 node 节点，管理一组 pod 对象，管理一组 service 对象等。 操作 Label 标签给 pod 添加标签： 根据标签查询 pod： "},{"title":"【K8s】常用命令","date":"2026-01-24T14:00:00.000Z","url":"/blog/2026/01/24/K8s/K8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["K8s","/blog/tags/K8s/"]],"categories":[["K8s","/blog/categories/K8s/"]],"content":"yaml 配置文件命令 Namespace 命令Namespace 的资源名称缩写为 “ns” Pod 命令 Deployment 命令Deployment 的资源名称缩写为 “deploy” Label 标签命令"},{"title":"【Idea】插件","date":"2026-01-11T09:00:00.000Z","url":"/blog/2026/01/11/Idea/IDEA%E6%8F%92%E4%BB%B6/","tags":[["Idea","/blog/tags/Idea/"]],"categories":[["Idea","/blog/categories/Idea/"]],"content":"中文语言包插件名称：Chinese (Simplified) Language Pack &#x2F; 中文语言包 Idea 官方中文插件 "},{"title":"Centos7问题处理","date":"2026-01-04T07:54:00.000Z","url":"/blog/2026/01/04/Linux/Centos7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/","tags":[["Linux","/blog/tags/Linux/"]],"categories":[["Linux","/blog/categories/Linux/"]],"content":"yum 命令异常虚拟机可联网的前提了，使用 yum 命令出现异常： 问题原因当前的镜像地址无法找到所需的文件。因为 CentOS 7 的官方仓库在 2024 年 6 月 30 日之后已经停止维护，部分仓库已被移至归档库，导致了 yum 命令无法找到所需的元数据文件。 解决方法 修改 CentOS-Base.repo 文件，修改成以下内容： "},{"title":"【Trae】安装插件实现Java代码编写","date":"2025-12-09T01:00:00.000Z","url":"/blog/2025/12/09/Trae/Trae%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Java%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/","tags":[["Trae","/blog/tags/Trae/"]],"categories":[["undefined",""]],"content":"Java 插件Extension Pack for JavaExtension Pack for Java 包括以下插件： Red Hat 的 Java™ 语言支持 Java 调试器 Java 测试运行器 适用于 Java 的 Maven Java 项目管理器 Visual Studio IntelliCode Spring Boot Extension Pack IntelliJ IDEA Keybindings将 Idea 快捷键同步到 Vs Code 中。 Maven 配置前提：安装完 Maven 插件。 第一步设置setting.xml路径：文件 -&gt; 首选项 -&gt; 设置，搜索 maven，完成 setting.xml 路径配置 第二步配置mvn路径：扩展中搜索 Maven For Java 插件 -&gt; 配置 mvn 路径 第三步：检查maven是否可用 项目告警颜色显示配置代码有告警，相应的文件、目录以及项目都会显示黄色，关闭告警颜色显示配置如下： "},{"title":"【Java】常见的日志框架","date":"2024-04-07T01:00:00.000Z","url":"/blog/2024/04/07/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"JAVA 日志框架Java 日志框架主要关注以下问题： 日志级别。 日志输出格式。 日志输出位置。 JUL 日志框架介绍JUL 全称 Java util Logging，是 Java 原生的日志框架。 日志组件 Loggers：应用程序通过 Logger 对象来输出日志信息。 Handlers：每个 Logger 对象都会关联一个 Handler 对象，Logger 对象会将日志信息交给 Handlers 对象处理，由 Handlers 对象决定日志的输出位置。 Formatter：每个 Handler 对象都会关联一个 Formatter 对象，由 Formatter 对象对日志信息格式化。 Filters：过滤器，例如对日志级别进行过滤。 使用示例 JUL 中的日志级别 修改日志配置 Logger 之间的父子关系 JUL 中的 Logger 对象之间是存在父子关系的。例如 name 为 blog.lin.JulTest 的 Logger 对象是 name 为 blog.lin 的 Logger 对象的 父 Logger。 所有 Logger 对象的顶级父 Logger 是 RootLogger 对象。 如果 Logger 对象的 useParentHandlers 属性为 true，表示该 Logger 对象会使用父 Logger 的配置，如果父 Logger 的 useParentHandlers 属性也为 true，则会一层一层往上找，直到找到 RootLogger 对象的配置。 通过代码修改 通过配置文件修改在 resources 目录下编写 logging.properties 配置文件： 读取自己编写的 logging.properties 配置： Log4j 日志框架日志组件 Loggers：应用程序通过 Logger 对象来输出日志信息。 Appenders：每个 Logger 对象可以关联多个 Appenders 对象，Logger 对象会将日志信息交给 Appenders 对象处理，由 Appenders 对象决定日志的输出位置。 Layout：每个 Appenders 对象都会关联一个 Layout 对象，由 Layout 对象对日志信息格式化。 Appenders 组件可选类型 ConsoleAppender：将日志输出到控制台。 FileAppender：将日志输出到文件中。 DailyRollingFileAppender：将日志输出到一个日志文件，文件名跟日期相关。 RollingFileAppender：将日志信息输出到一个日志文件，并且指定文件的尺寸，当文件大 小达到指定尺寸时，会自动把文件改名，同时产生一个新的文件。如果文件数量达到最大值，就覆盖最旧的日志。 JDBCAppender：把日志信息保存到数据库中。 Layouts 组件可选类型 HTMLLayout：以 HTML 表示形式输出日志。 SimpleLayout：简单的日志格式，格式为（info - message）。 PatternLayout：自定义日志格式。 自定义日志格式的占位符含义： %m：日志信息。 %p：日志级别。 %n：换行符。 %r：输出自应用启动到输出该 log 信息耗费的毫秒数 %c：全限定类名。 %t：线程名称。 %d：服务器时间，也可以指定格式，如：%d{yyyy-MM-dd HH:mm:ss} %F：文件名称。 %L：代码中的行号。 %l：输出日志时间发生的位置，包括类名、线程、及在代码中的行数。如：Test.main(Test.java:10) %%：输出一个 “%” 字符 文本的对其方式： %5c：字符最少数量。如果字符数量小于 5，文本右对齐，左边用空格填充。 %-5c：字符最少数量。如果字符数量小于 5，文本左对齐，右边用空格填充。 %.5c：字符最大数量。如果字符数量大于5，会将左边多余的字符截断。 配置文件在 resources 目录下创建 log4j.properties 配置文件。 注： 如果自定义的 logger 和 父 logger 都配置了日志级别，以自定义的 logger 配置的日志级别为准。 如果自定义的 logger 和 父 logger 都配置了 appender 组件，那么所有配置的组件都会使用。如果配置了相同的组件，那么该组件就会使用两次。 使用示例导入 Log4j 依赖包。 前提在 resources 目录下创建了 log4j.properties 配置文件。 Log4j 的日志级别 JCL 日志接口介绍JCL 全称 Jakarta Commons Logging，是 Apache 提供的一个通用日志 API。 实现 JCL 接口的三个日志框架：log4j、jul、simpleLog。 如果一个项目导入多个 JCL 多个日志实现类，优先级为：Log4JLogger &gt; Jdk14Logger &gt; Jdk13LumberjackLogger &gt; SimpleLog。 使用示例 JCL + JUL 使用示例 导入依赖包，不需要导入 JUL 依赖包，因为是 JDK 自带的日志框架： 测试 JCL 接口 API： JCL + Log4j 使用示例 导入依赖包： 编写 logging.properties 配置文件： 测试 JCL 接口 API： SLF4J 日志接口介绍SLF4J 作为通用的日志接口，整合了市面上常用的日志框架。例如：Log4j、JUC、JCL、Logback、Log4j2 等。 SLF4J 整合其它日志框架使用 SLF4J 流程： 如果日志框架已经实现了 SLF4J 的接口，直接添加对应日志依赖即可。 如果日志框架没有实现 SLF4J 的接口，需要先添加日志对 SLF4J 接口的适配器，然后再添加对应的日志依赖。 SLF4J 只能绑定一个日志实现框架。如果有多个日志实现框架，默认使用第一个依赖日志实现。 SLF4J + Log4j2 SLF4J + Logback SLF4J + NOP 注：SLF4J 整合 NOP 日志框架表示停止输出日志。 SLF4J + JCL SLF4J + Log4j SLF4J + JUL SLF4J + Slf4j-simple 桥接旧的日志框架桥接的步骤： 除去需要被替换的日志框架的依赖。 添加 SLF4J 提供的桥接框架。 为项目添加 SLF4J 日志实现框架。 SLF4J 提供的桥接框架： 以下情况会抛出 StackOverflow Error 异常 ： jcl-over-slf4j 依赖和 slf4j-jcl 依赖一起导入项目中。 log4j-over-slf4j 依赖和 slf4j-log4j12 依赖一起导入项目中。 jul-to-slf4j.jar 依赖和 slf4j-jdk14 依赖一起导入项目中。 注意： 所有的桥接都只对 Logger 对象有效，如果程序中调用了内部的配置类或者是 Appender、Filter 等对象，将无法产生效果。 Logback 日志框架日志组件 Loggers：应用程序通过 Logger 对象来输出日志信息。 Appenders： 每个 Logger 对象可以关联多个 Appenders 对象，Logger 对象会将日志信息交给 Appenders 对象处理，由 Appenders 对象决定日志的输出位置。 Layout：每个 Appenders 对象都会关联一个 Layout 对象，由 Layout 对象对日志信息格式化。 配置文件在 resources 目录中创建 logback.xml 配置文件。 日志输出格式： %d{pattern}：操作系统日期。 %thread：线程名称。 %-5level：日志级别。 %c：全限定类名。 %M：方法名称。 %L：行号。 %msg：日志信息。 %n：换行符。 使用示例导入依赖包： 在 resources 目录下编写 logback.xml 配置文件： 测试 Logback 代码： "},{"title":"【ES】搜索语法","date":"2024-04-06T01:00:00.000Z","url":"/blog/2024/04/06/SpringCloud/ElasticStack/Elasticsearch%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["Elasticsearch","/blog/tags/Elasticsearch/"],["ELK","/blog/tags/ELK/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"Query 查询 DSL 查询模板： 查询类型： match_all：查询所有文档。 match：全文检索，单字段查询。 multi_match：全文检索，多字段查询。 term：精确查询，不分词查询。 ids：精确查询，根据文档 id 查询。 range：精确查询，指定查询范围。 geo_distance：地理位置查询，需要指定圆的范围。 geo_bounding_box：地理位置查询，需要指定矩形的范围。 bool：复合查询，多种类型的查询的集合。 function_score：根据查询结果重新计算文档的分数。 match_all用来查询所有文档。 match_all 使用示例 match将搜索内容的分词结果跟指定字段的倒排索引匹配。 注意：指定的字段的 index 属性为 false，会抛出 query_shard_exception 异常。 mulit_match将搜索内容的分词结果跟多个字段的倒排索引匹配。 注意：指定的字段的 index 属性为 false，会抛出 query_shard_exception 异常。 注：搜索字段越多，对查询性能影响越大，因此建议采用 copy_to，然后单字段查询的方式。 term对搜索内容不分词查询。 terms对搜索内容不分词查询，可以指定多个搜索内容。 ids根据 id 查询文档。 range范围查询。 geo_distance地理位置查询，需要指定圆的范围。 geo_distance 使用示例 exists指定的字段要存在，且值不为 null。 fuzzy返回包含与搜索词类似的词的文档，包括以下几种情况： 写错字符（fox → box） 漏写字符（apple → aple） 多写字符（sic → sick） 相邻字符被调换（cat → act） fuzzy 使用示例 prefix前缀查询。 bool 查询布尔查询是由多个子查询组合而成，子查询之间的逻辑关系是与 and。 bool 的四种子查询类型： must：每个查询条件之间的逻辑关系是 and。 should：每个查询条件之间的逻辑关系是 or。 filter：跟 must 一样，区别是不参与 score 的计算。 must_not：文档不能匹配指定查询条件，不参与 score 的计算。 注意：使用 should 类型的子查询，必须设置 minimum_should_match 参数的值。minimum_should_match 参数表示匹配的文档必须满足几个 should 子查询。如果 should 子句中包含两个查询，如果不设置参数 minimum_should_match，默认值是0。 bool 查询示例 条件：brand&#x3D;”速8” and city&#x3D;”上海” and business&#x3D;”四川北路商业区” 条件：(brand&#x3D;”速8” and city&#x3D;”上海”) and (business&#x3D;”四川北路商业区” or business&#x3D;”长风公园地区”) 条件：business&#x3D;”四川北路商业区” or business&#x3D;”长风公园地区” or (city&#x3D;”北京” and starName&#x3D;”五钻”) function_score 得分根据业务要求重新计算 _score 算分。 function_score 的四部分内容： query 查询：基于 query 查询出来的文档，score 值由 es 计算得出。 filter 查询：基于 filter 查询出来的文档，根据算分函数重新计算文档的 score 值。 算分函数：对 filter 查询的文档重新计算 score 值，有四种算分函数。 weight：指定一个常量。 field_value_factor：以文档中的某个字段值作为 score 值。 random_score：随机一个数作为 score 值。 script_score：自定义算分函数。 加权模式：对 es 得出 score 和算分函数得出的 score 运算得出 score 的最终值： multiply：相乘。 sum：相加。 avg：取平均值。 max：取最大值。 min：取最小值。 replace：采用算分函数得出的 score。 function_score 使用示例 对品牌为君悦的酒店的权重全部 +3： 对查询结果排序普通字段排序 地理坐标排序 分页查询 from 默认从 0 开始。 当分页查询深度较大、汇总数据过多时，会对内存和 CPU 压力造成巨大的压力，因此 es 会禁止from+ size 超过 10000 的请求。如果要查询 10000 以后的数据，可以使用 search_after 方式。 搜索时可以通过 search_after 指定一个游标来作为搜索的起点。这个游标是由排序字段的值决定的。 search_after 的使用示例 假设查询结果根据 id 倒序排序，每次查询 10 条数据。上一次查询结果的最后一个文档 id 为100000，那么查询这次查询 url 为： 高亮显示高亮显示就是在分词前后添加 html 标签，给前端解析就能够高亮显示了。 高亮显示的字段必须在查询字段的范围内，否则没有意义。 高亮显示示例 查询结果： 数据聚合聚合概念数据聚合就是对数据进行分组，让后进行统计、分析、运算等。 桶聚合（Bucket）：用来对文档做分组。 term：根据文档字段值分组。 date：按照日期阶梯分组，例如一周为一组，或者一月为一组。 指标聚合（Metric）：对分组进行统计，例如求 avg、max、min、sum 等。 注：参加聚合的字段必须是keyword、日期、数值、布尔类型 在聚合逻辑那里可以填以下属性： field：根据指定的文档字段聚合。 size：显示数据的条数。 指标聚合类型value_count用来统计文档的数量，null 值不在统计范围内。 cardinality用统计文档的数量，会根据字段值去重。null 值不在统计范围内。 avg统计组内指定字段的平均值。 sum组内字段求和。 max组内指定字段的最大值。 min组内指定字段的最小值。 stats统计 value_count、avg、sum、max、min 值。 分组聚合类型terms根据文档字段的唯一值分组。 min_doc_count：如果组内 doc_count 小于 min_doc_count 设定的值，就不显示那个区间的信息。 histogram划分区间然后进行分组。 interval：设置区间的间隔，从 0 开始加减 interval 形成区间，区间是左闭右开类型。组内 key 指的是区间的左边界值。 min_doc_count：如果组内 doc_count 小于 min_doc_count 设定的值，就不显示那个区间的信息。 extended_bounds：设置 min 和 max，即分组内 key 的范围。如果 interval&#x3D;10，min&#x3D;-1，那么组内 key 从 -10 开始。 注意：如果字段值比设置的 max 要大，以实际的最大值为准，如果比 max 要小，以 max 为准，min 同理。 date_histogram将日期根据年月日时分秒分组。 calendar_interval：时间分隔单位。 format：指定时间的显示格式。 min_doc_count：如果组内 doc_count 小于 min_doc_count 设定的值，就不显示那个区间的信息。 range字段的区间由自己划分。 keyed：是否由内置 key 指向区间信息。 ranges.key：指定内置 key 的名称。不指定内置 key 的名称由 ranges.from 和 ranges.to 组成。 注：区间是左闭右开类型的。 range 使用示例 执行结果： 分组排序 排序参数有： _count：根据 doc_count 排序。仅对 terms 、 histogram 、 date_histogram 类型的分组有效。 _key：根据内置 key 排序，仅对 histogram、date_histogram 类型的分组有效。 子聚合的指标：根据统计结果进行排序。 _key 排序示例 使用 histogram 分组，然后根据划分的区间从大到小排序： 执行结果： 根据聚合指标排序示例 统计每个酒店品牌的价格的平均值，然后根据价格的平均值从大到小排序： 执行结果： "},{"title":"【ES】索引配置","date":"2024-04-03T01:00:00.000Z","url":"/blog/2024/04/03/SpringCloud/ElasticStack/Elasticsearch%E7%B4%A2%E5%BC%95%E9%85%8D%E7%BD%AE/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["Elasticsearch","/blog/tags/Elasticsearch/"],["ELK","/blog/tags/ELK/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"mappings 配置dynamic 配置dynamic 是用来配置，遇到未定义字段时的 mapping 策略。 有三种策略： strict：遇到未定义字段就报错。 false：遇到未定义字段，只会存储该字段的内容，不会为它配置字段类型和创建倒排索引。 true：遇到未定义字段，会为该字段自动配置字段类型和创建倒排索引。 es 默认配置。 properties 配置es 是在 properties 中声明文档的字段，而且字段一旦被声明就不可以再被修改。 type用来声明文档字段的类型，常见的类型有： 字符串：text、keyword。 数值：byte、short、integer、long、float、double、scaled_float。 布尔：boolean。 日期：date。 对象：object。 地址位置：geo_point。 geo_point 字段类型使用示例 创建索引： 写入 geo_point 数据： lon：longitude 经度 lat：latitude 维度 index是否为该字段的内容创建倒排索引，默认为 true。 fieldsfields 可以让一个字段拥有多个子字段类型，也就是让同一文本有多种不同的索引方式。 fields 使用示例 创建索引： 向索引存放两条数据： 查询文档，然后按 id 升序排序： 执行结果： 查询文档，把 id 当作整数进行降序排序： analyzer指定该字段使用哪种分词器分词。 search_analyzer指定查询时用哪种分词器分词。 format用来指定日期的存储格式。 format 使用示例 允许 birthday 字段存储 yyyy-MM-dd 和 yyyy-MM-dd HH:mm:ss 两种日期格式的数据： scaling_factor指定浮点数的缩放因子，该属性需要配合 scaled_float 类型字段使用。 scaled_float 实际上是一个 long 类型字段，它只是将给定的浮点数乘以缩放因子（scaling_factor），然后将四舍五入的结果存储。 scaling_factor 使用示例 创建 price 字段，类型为 scaled_float： 存储一个文档： 查询该文档： 注：如果查询该文档，prices 依旧显示为 13.325，但在 es 中实际存储的值为 13.33。如果查询条件为 13.325 也可以把这个文档查询出来。 properties声明字段的子字段。 数据的存储方式 Object 数据的存储方式 文档数据： es 的存储格式： 对象数组的存储方式 文档数据： es 的存储格式： settings 配置analysisanalysis 的作用analysis 是用来定制分词器，配置内容如下： 分词器的 3 个组件 char_filter：对文本先进行预处理，如去掉 html 标签。 tokenizer：对文本进行分词。 filter：对分词集合进行处理，如过滤不需要分词、normalization（标准化）等。 es 自带的 char_filter 预处理器： html_strip：去除 html 标签。 es 自带的 tokenizer 分词器： standard 分词器：过滤 html 符号，按词划分，小写处理。 simple 分词器：按词划分、会去掉数字，小写处理。 stop 分词器：相比于 simple 分词器，多了去除停用词（the、a、is 等）的操作。 path_hierarchy 分词器：根据路径分词。 keyword 分词器：将整个文本作为分词输出。 whitespace 分词器：根据空格分词。 es 自带的 filter 分词过滤器： lowercase：对分词小写处理。 自定义 char_filter type 取值： mapping：字符串替换。 pattern_replace：正则匹配替换。 自定义 mapping 预处理器示例 特殊符号转义： 测试： 测试结果： 自定义 filter type 取值： stop：过滤指定的分词。 自定义 filter 分词过滤器示例 过滤指定分词： 测试： 测试结果： 自定义 analyzer type 取值： custom：自定义分词器。 自定义 analyzer 分词器示例 配置分词器 3 大组件： 测试： 测试结果： 测试分词器组件 测试 es 自带的分词器组件： 测试在索引自定义的分词组件： number_of_shards指定索引主分片数量，确定后就不能够修改了。 number_of_replicas指定索引每个主分片可以有多少个副分片，指定了还可以修改。"},{"title":"【Kibana】常用功能","date":"2024-04-02T10:00:00.000Z","url":"/blog/2024/04/02/SpringCloud/ElasticStack/Kibana%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["ELK","/blog/tags/ELK/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"开发工具模块在开发工具界面编写 Restful API 操作 ES。 Discover 模块创建索引模式为了方便的检索索引中有哪些文档，可在管理中创建索引模式， 创建完成后就可以在 Discovery 模块查看所有内容了： 如果创建了多个索引模式，也可以选择指定的索引模式： "},{"title":"【IK 分词器】基本使用","date":"2024-04-02T06:00:00.000Z","url":"/blog/2024/04/02/SpringCloud/ElasticStack/IK%E5%88%86%E8%AF%8D%E5%99%A8/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["ELK","/blog/tags/ELK/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"安装 IK 分词器 IK 分词器官网下载地址，选择跟 es 版本兼容的 IK 版本。 在 es 的 plugins 目录中创建 ik 目录，把下载的 zip 包放到 ik 目录中。 在 linux 中使用 unzip 包名.zip 解压 ik 压缩包。 重启 es。 IK 分词模式IK 分词器有两种分词模式： ik_smart：粗粒度。 ik_max_word：细粒度。 粗粒度示例： 细粒度示例： IK 分词器的配置文件config 目录 main.dic：ik 内置的中文词库。 preposition.dic: 介词。 quantifier.dic：量词。 suffix.dic：中文后缀。 surname.dic：姓氏 stopword.dic：英文停用词 IKAnalyzer.cfg.xml：用来配置扩展词库和停用词。 "},{"title":"【ES】基本使用","date":"2024-04-02T01:00:00.000Z","url":"/blog/2024/04/02/SpringCloud/ElasticStack/Elasticsearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["Elasticsearch","/blog/tags/Elasticsearch/"],["ELK","/blog/tags/ELK/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"ES 介绍搜索相关概念正向索引：根据词条逐条扫描文档数据。 倒排索引：根据分词算法，从文档获取词条集合，然后建立词条到文档的映射关系。通过词条就能够快速查找相关文档。 全文检索：根据用户提供的词条，在一个文档集合中查找跟这些词条相关的文档的过程。 Lucene：一个通过倒排索引思想实现了全文检索功能的 Java 工具包。 ES 介绍Elasticsearch 是基于 Lucene 工具包开发的全文搜索引擎。 ES 的特点： 支持分布式集群，ES 节点的可拓展性强。 查询效率高，ES 只需秒级即可查询海量数据。 支持 Restful API 接口操作数据。 ES 相关概念 文档：es 是以文档为单位存储的，一个文档就是一条 json 格式的数据。文档可以有自己的属性。 索引：就是相同类型的文档的集合。在索引中定义 mapping 映射，就是定义文档的属性。 ES 相关配置说明 索引操作创建索引 执行结果： acknowledged：为 true 表示请求被处理。 shards_acknowledged：为 true 表示该索引的所有分片都创建成功。 index：创建索引的名称。 删除索引 查询索引查看所有配置 查看 mapping 配置 查看 sessiong 配置 新增字段 关闭索引 在索引关闭期间，不可以对索引进行增删改查相关的操作。 打开索引 文档操作在 ES 中，文档都是用 Json 数据格式来表示。索引类型在 es 9 中被彻底删除，因此在没有被删除的版本里固定使用 _doc 即可。 文档内容说明 _index：文档所在的索引名称。 _type：索引类型，固定为 _doc。 _id：文档的 id。 _version：文档的版本号，对文档进行增删改都会让版本号 +1，删除可能会让版本号重置。 _seq_no： 索引内维护了一个 _seq_no 操作序列号，只要对索引中的任意文档进行了增删改操作，都会让操作序列号 +1。 每一个文档内部也维护了一个 _seq_no 操作序列号，只要对该文档进行增删改操作，会让索引内的 _seq_no 序列号 +1，然后赋值到文档内的 _seq_no 。 如果对文档 a 进行了增删改操作，会影响索引内 _seq_no 和文档 a 自己的 _seq_no ，不会影响其它文档的 _seq_no 。 _primary_term：表示文档所在主分片的编号。 found：是否找到了指定的文档。 创建文档 文档 id：创建的时候需要给文档指定 id。如果不指定， es 会自动给文档生成 20 个字符的 id。 /_create：表示 url 是用来创建数据，如果重复执行会返回 error 信息。去掉 _create 就可以反复执行 url，新的文档会覆盖旧的文档，即便新旧文档的内容完全一致，version 也会被修改。 创建文档示例 创建文档 url： 执行结果： 查询文档返回全部字段 查询文档全部字段示例 查询 url： 执行结果： 定制返回字段 查询文档部分字段示例 查询 url： 执行结果： 修改文档 注：以上的 API 是用来修改文档的部分字段，如果想全量替换，可以使用创建文档的 API，这样旧的内容就会被新的内容全部替换。 修改文档示例 修改文档 url： 执行结果： 如果修改后的内容跟修改前的内容完全一样，那么会返回以下结果： 注：_seq_no 操作序列也不会被修改。 删除文档 注： 文档被删除后，es 不会立即删除该文档，会先做一个标记，等到要删除的文档达到阈值后再统一删除。 如果文档被 es 删除了，那么新增 id 一样的文档，version 是从 1 开始。 如果文档还没有被 es 删除，只是做了标记，那么新增 id 一样的文档，会继续使用原来的 version。 删除文档示例 删除文档 url： 执行结果： 批量操作语法： 格式要求：每个 json 不能换行。相邻 json 必须换行。 隔离：每个操作互不影响。操作失败的行会返回其失败信息。 实际用法：bulk 请求一次不要太大，否则一下积压到内存中，性能会下降。所以一次请求几千个操作、大小在几M正好。 批量操作示例 批量操作 url： 执行结果： 乐观锁的并发控制基于 version 实现如果数据的版本号在数据库中维护，可以基于 verson 实现乐观锁。 external：表示传入的 version 要大于 ES 文档中的 _version 属性。 external_gte：表示传入的 version 要大于或等于 ES 文档中的 _version 属性。 基于 version 实现乐观锁示例 基于 seq_no 实现使用 if_seq_no 和 if_primary_term 实现乐观锁的并发控制 示例 查询文档的 if_seq_no 和 if_primary_term： 查询结果： 基于乐观锁修改文档属性： 集群管理检查集群的健康状态 执行结果： ?v：表示需要显示表头。 green：每个索引的 primary shard 和 replica shard 都是可用状态。 yellow：每个索引的 primary shard 都是可用状态，但是部分 replica shard 处于不可用的状态。 red：不是所有索引的 primary shard 都是可用状态，部分索引有数据丢失了。 查看集群中有哪些索引 ?v：表示需要显示表头。 ES 内部机制索引的主分片和副分片 ES 中的每个 index 包含一个或多个主分片。 每个文档只能存储在一个主分片，以及主分片对应的副分片中。 副分片用来负责容错、分担主分片读请求负载。 主分片和副分片不能放在同一个 ES 节点上。如果只有一个 ES 节点，那这个节点只会存储主分片，不会存储副分片，并且集群的状态为 yellow。 配置 index 的主分片数量和副分片数量： 新增或减少 ES 节点新增或减少 ES 节点，ES 集群都会将主分片和副分片重新分配。 选举 master 节点master 节点的主要责任：创建或删除节点、创建或删除索引。 如果 master 节点宕机，可能有 index 的主分片不是可用状态，此时集群的状态可能是 red。 处理措施： es 集群会重新选举出 master 节点，并承担 master 节点的责任。 将丢失的主分片的副本提升为主分片，此时集群状态改为 yellow。 如果故障节点恢复： master 将缺失的副分片 copy 一份到节点上。 copy 是增量数据的过程，不是将主分片数据全部拷贝一份。 文档路由一个文档，由路由算法计算的结果确认存储在索引的哪个主分片上。 routingKey 默认是文档的 id，可以自己指定文档的 routingKey。 索引的主分片数一旦确定，就不可以改变。 ES 文档的增删改机制 客户端会选择一个 node 发送请求，这个 node 就会成为 coordinating node（协调节点）。 coordinating node 会根据文档的路由结果，将请求转发给对应的 node。 实际的 node 根据请求处理主分片上的数据，然后将数据同步到副分片。 coordinating node 发现主分片和副分片上的数据都处理完成，就给客户端响应结果。 ES 文档的查询机制 客户端会选择一个 node 发送请求，这个 node 就会成为 coordinating node（协调节点）。 coordinate node对根据文档的路由结果，在主分片和副分片上随机轮询，将请求转发给 node。 接收请求的 node 将文档返回给 coordinate node。 oordinate node 将文档返回给客户端。 如果文档还在创建过程中，可能出现主分片有该文档，副分片没有该文档的情况。如果 coordinate node 此时路由给了主分片，那么可以获取文档，如果路由给了副分片，那么没有获取到文档。 type 被弃用的原因在 es 中，一个索引可以有多个 type。同一个索引下的不同 type，字段会有所不同。但是不同 type 的数据会存储其它 type 的字段，其它 type 字段都会设置为空，因此会产生大量的空值，导致资源浪费。 一个索引多个 type 的数据存储示例 goods 索引 electronic_goods、fresh_goods 两个 type： goods 索引的结构： 存储数据： 实际上在 es 存储的数据： "},{"title":"【RabbitMQ】高级用法","date":"2024-04-01T01:00:00.000Z","url":"/blog/2024/04/01/SpringCloud/RabbitMQ/RabbitMQ%E9%AB%98%E7%BA%A7/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["RabbitMQ","/blog/tags/RabbitMQ/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"消息丢失的场景 publisher 到 交换机： publisher 无法连接 rabbitmq。 publisher 投递消息给交换机时，交换机不存在。 rabbitmq 内部处理消息： 交换机投递消息给队列时，没有找到匹配 routingKey 的队列。 消息保存到队列后，还未投递给 consumer 就宕机了。 rabbitmq 内部处理消息时发送异常。 队列到 consumer： consumer 接收到消息后，处理过程抛出异常。 consumer 接收到消息后还没处理就宕机。 publisher 的可靠性重试机制当出现网络波动，导致 publisher 与 rabbitmq 的连接中断，publisher 无法向交换机投递消息，此时可以使用重试机制。 向 publisher 程序的配置文件添加以下内容： 注意：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。但是 Spring AMQP 提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，也可以考虑使用异步线程来执行发送消息的代码。 确认机制确认机制-Return只有交换机无法投递消息给队列时，才会触发 ReturnCallback 回调函数。 实现 Return 确认机制示例 开启 Return 确认机制： 编写 Return 回调函数： 确认机制-Confirm只要 publisher 将消息投递到交换机，不管发生了什么情况，都会触发 ConfirmCallback 回调函数。 RabbitMQ 通过返回 ack 或 nack 来告知 publisher 投递的消息是否成功。 实现 Confirm 确认机制示例 开启 Confirm 确认机制： 编写 Confirm 回调函数： 注： correlationData.getReturned() 能否获取值，需要同时满足以下条件 开启了 ReturnCallback 确认机制。 exchange 没有找到匹配 routingKey 的队列。 注意：如果队列堆积消息的数量达到最大值，且处理策略是丢弃新投递的消息，那么回调结果为 nack，且 correlationData.getReturned() 为null，因为这被视为成功路由。 RabbitMQ 返回 ack 的情况： 持久消息入队成功，也成功写入磁盘，返回 ack。 临时消息入队成功，返回 ack。 消息投递到了交换机，但是没有找到匹配 routingKey 的队列，返回 ack。这种情况是开发者导致的问题，跟 rabbitmq 没有关系。 其它情况都会返回 nack。 注意事项在 publisher 程序开启确认机制是比较消耗 mq 性能的，不建议开启。只有对可靠性要求非常高的业务才需要开启，而且只需要开启 Confirm 确认机制处理 nack 就行了。 不可靠场景 网络出现波动，publisher 无法连接 mq（重试机制）。 publisher 投递消息到达交换机后，没有找到匹配 routingKey 的队列（确认机制-Return）。 publisher 投递消息到达 mq 后没有找到交换机（确认机制-Confirm）。 队列堆积消息的数量达到了最大值，交换机继续向队列投递消息，消息被队列丢弃（确认机制-Confirm）。这种情况会返回 nack，但是 cause 变量和 Returned 变量都为 null， mq 内部处理消息时发生了异常（确认机制-Confirm）。 RabbitMQ 的可靠性数据持久化默认情况下创建的交换机、队列、消息都会被持久化。 如果创建的是临时的交换机、队列、消息，在 RabbitMQ 重启后都会消失。 交换机持久化 队列持久化 消息持久化 LazyQueue默认情况下，RabbitMQ 会将接收到的信息先保存在内存中，如果队列积压过多的消息，触发内容预警上限。此时 RabbitMQ 会将内存消息刷到磁盘上，这个过程会比较耗时，并且在这个过程中 RabbitMQ 不会再处理新的消息，生产者的所有请求都会被阻塞。 为了处理上述问题，RabbitMQ 建议将队列声明为惰性队列，惰性队列特性如下： 惰性队列接收到消息就直接存入磁盘中，内存只保存最近的消息，默认是 2048 条。 consumer 需要处理消息时才从磁盘中读取并加载到内容中。 一个惰性队列支持存储百万条消息，也就是队列的 x-max-length 属性可以达到百万条。 将队列声明为惰性队列： 注：在 3.12 版本之后，LazyQueue 已经成为所有队列的默认格式。3.12 版本之前的版本建议都设置为 LazyQueue。 consumer 的可靠性确认机制consumer 的确认机制：当 consumer 接收到消息或处理完消息，需要向 RabbitMQ 发送一个回执，告知 RabbitMQ 消息的处理结果。 consumer 发送回执的方式有三种： none：不发送回执。队列把消息投递给 consumer 后，就可以删除消息了。 manual：手动发送回执。需要在业务代码中手动调用 API 发送回执。 auto：自动发送回执。 consumer 正常处理完消息，自动发送 ack。 如果处理过程抛出业务异常，自动发送 nack。 如果队列投递消息失败或者消息校验异常，自动发送 reject。 回执有三种可选值： ack：成功处理消息，队列可以删除消息。 nack：消息处理失败，队列需要再次投递消息。 reject：消息处理失败，队列可以删除该消息。 自动发送 reject 回执的场景： 抛出 MessageConversionException 异常：消息转换异常。 抛出 MethodArgumentNotValidException 异常：方法参数校验失败异常。 抛出 MethodArgumentTypeMismatchException 异常：方法参数类型不匹配异常。 抛出 NoSuchMethodException 异常。 抛出 ClassCastException 异常。 consumer 自动发送回执示例 修改配置： 监听队列代码： 打上断点后的执行结果，unacked 是指还没有收到 consumer 回执的消息数量： consumer 手动发送回执示例 修改配置： 监听队列代码： 失败重试机制介绍失败重试机制是为了避免出现投递消息，处理失败，重新投递消息死循环的情况。 配置失败重试机制 注1：开启了 consumer 的失败重试机制，不管 consumer 的确认机制配置的是什么，只要 consumer 抛出了异常，都会触发失败重试机制。 注2：重试都是在本地进行，不是将消息重新投递到队列，然后让队列再次投递。 失败处理策略如果 consumer 重试次数达到允许的最大值，默认的失败处理策略是抛出 RejectAndDontRequeueRecoverer 异常，然后给 RabbitMQ 返回 reject 消息。 RabbitMQ 提供了 3 种失败处理策略： RejectAndDontRequeueRecoverer：给 RabbitMQ 返回 reject 消息。 ImmediateRequeueMessageRecoverer：给 RabbitMQ 返回 nack 消息。 RepublishMessageRecoverer：将失败消息投递到指定的交换机。 RepublishMessageRecoverer 策略使用示例 声明处理异常信息的交换机和队列： 配置 consumer 失败处理策略： 异常队列中的消息，可以获取异常信息和异常栈： 业务幂等性业务幂等性：一个业务，使用相同的数据成功执行了多次，期望最终得到的结果是跟成功执行一次得到的结果一样的。 例如取消订单恢复库存业务。因为某种原因，同一订单被执行了多次取消业务。恢复库存业务被成功执行了多次的结果希望是跟被成功执行一次一样的。 兜底方案不管如何使用 RabbitMQ 的可靠机制，都不能保证消息一定会被投递到 consumer 并被成功处理。可以在 consumer 编写定时任务主动去获取 publisher 相关的消息， 死信交换机死信的概念当队列中的消息满足以下其中一种情况，就是死信： consumer 处理消息失败，并丢弃的消息都会成为死信。 手动发送 basic.reject 或 basic.nack 回执，并将 requeue 参数设置为 false。 consumer 自动发送 reject 回执。 失败处理策略使用了 RejectAndDontRequeueRecoverer，达到最大重试次数就发送 reject 回执。 要投递的队列消息满了，处理策略是将消息投递到死信交换机。 TTL（有效期）到期的消息。 延迟消息使用队列 TTL 机制 + 死信交换机的机制。 延迟消息使用实例 声明死信交换机： 声明队列，并指定 TTL 和死信交换机： 基于插件实现延迟消息通过 DelayExchange 插件，可以直接声明一个延迟交换机，在发送消息的时候设置消息延迟多少时间送达队列即可。不需要进行繁琐的配置。 延迟插件官网下载地址，根据 rabbitmq 的版本选择插件的版本，插件文件后缀类型为 .ez。 用延迟插件实现延迟交换机示例 将下载好的插件放到 rabbitmq 插件目录中，用 docker 部署 rabbitmq 时，将插件目录挂载到以下目录了： 进入 rabbitmq 容器中，并启动延迟插件： 声明延迟交换机，将 delayed 属性设置为 true： 发送消息，并指定延迟时间： 队列的相关属性 x-message-ttl：设置消息的有效期，单位毫秒。 x-max-length：队列能够堆积消息的数量。 x-overflow：队列堆满消息的处理策略。 reject-publish：直接将信息丢弃，这种不算交换机路由失败。 reject-publish-dlx：将消息投递到死信交换机。 x-dead-letter-exchange：指定死信交换机。 x-dead-letter-routing-key：指定死刑交换机的 routingKey，不指定就沿用之前的 routingKey。 x-queue-mode：队列模式，官方推荐使用惰性队列，取值为 lazy。 MessagePostProcessor 的作用MessagePostProcessor 是 Message 对象的后置处理器，Message 对象存储了本次消息的各种属性，例如消息的 id、是否将消息持久化、消息的延迟时间等等。可以通过重写 MessagePostProcessor 的方法，在发送消息前修改 Message 对象的属性。 CorrelationData 的作用主要有两个作用： 设置 id：表示发送本次消息的唯一标识。 SettableListenableFuture：将来 RabbitMQ 的回执回存储到 Future 对象中，我们可以提前给 CorrelationData 中的 Future 对象添加回调函数来处理消息回执。 CorrelationData 使用示例 RabbitMQ 相关配置"},{"title":"【RabbitMQ】基本使用","date":"2024-03-31T01:00:00.000Z","url":"/blog/2024/03/31/SpringCloud/RabbitMQ/RabbitMQ%E5%9F%BA%E7%A1%80/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["RabbitMQ","/blog/tags/RabbitMQ/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"RabbitMQ 介绍MQ 简介通过 OpenFeign 调用服务实例提供的服务，这个过程是同步的。如果是消费实例通过 MQ 将请求投递给服务实例，服务实例接收到请求后执行服务，这个过程是异步的。 MQ 三个必要的元素： 消息发送者：投递消息的程序。 MQ：管理、暂存、转发消息的程序。 消息接收者：接收和处理消息的程序。 RabbitMQ 架构 publisher：投递消息的程序。 consumer：接收和处理消息的程序。 exchange：交换机，负责消息路由。publisher 投递的消息由交换机决定路由到哪些队列。 queue：队列，用来存储 publisher 投递的消息。 virtual host：虚拟主机，起到隔离数据的作用。每个虚拟主机相互独立，有各自的 exchange 和 queue。 Spring AMQPSpring AMQP 是基于 RabbitMQ 封装的一套模板，并且还基于 SpringBoot 对其实现了自动装配。 Spring AMQP 主要提供了三个功能： 封装了 RabbitTemplate 工具，用于发送消息。 基于注解，使用监听器模式异步接收消息。 自动声明队列、交换机及其绑定关系。 RabbitMQ 使用示例publisher 程序 导入 Spring AMQP 依赖包： 编写 RabbitMQ 配置： publisher 投递消息，直接投递到队列，不经过交换机： consumer 程序 导入 Spring AMQP 依赖包： 编写 RabbitMQ 配置： 编写 consumer 程序： RabbitMQ 交换机路由模式交换机介绍RabbitMQ 中的交换机只负责转发消息，不具备存储消息的能力。如果没有队列与交换机绑定，或者消息根据路由规则找不到队列，消息都会丢失。 交换机参见的模式： Fanout：广播模式，将消息投递给所有与交换机绑定的队列。 Direct：订阅模式，基于 RoutingKey 发送给订阅了消息的队列 Topic：通配符订阅模式，与 Direc t类似，只不过 RoutingKey 可以使用通配符。 Fanout 交换机Fanout 交换机会将消息投递给所有与交换机绑定的队列。 Fanout 交换机使用示例 Fanout 交换机跟队列的绑定关系图： 向 Fanout 交换机投递消息： 执行结果： Direct 交换机Direct 交换机跟队列绑定的时候需要指定 RoutingKey，向 Direct 交换机投递消息的时候需要传递一个 RoutingKey ，Direct 交换机根据指定的 RoutingKey 将消息投递到队列（可以有多个）。 交换机、队列、RoutingKey 的关系： 交换机可以用多个不同的 RoutingKey 绑定同一个队列。 交换机可以用相同的 RoutingKey 绑定不同的队列。 Direct 交换机使用示例 Direct 交换机跟队列的绑定关系图： 向 Direct 交换机投递消息： 执行结果： Topic 交换机Topic 交换机在编写 RoutingKey 的时候可以使用通配符。 通配符规则： #：匹配零个、一个或多个词，用来指定 RoutingKey 的前缀或后缀。 *：匹配零个或一个词。 通配符使用示例： Direct 交换机使用示例 Topic 交换机跟队列的绑定关系图： 向 Topic 交换机投递消息： 执行结果： WorkQueues 模式WorkQueues 模式： 让多个 consumer 绑定同一个队列，共同处理队列中的消息。 默认情况下，RabbitMQ 会采用轮询的方式将消息依次投递给 consumer，一个消息只能被一个 consumer 处理。 让多个消费者绑定同一个队列，可以提高消费队列信息的速度，防止出现消息堆积情况。 WorkQueues 模式示例： 注意：如果队列总共有 500 条消息，即便 consumer1 处理消息的速度远大于 consumer2，RabbitMQ 也是将 500 条消息轮询分配给每个 consumer。即使 consumer2 堆积的消息还没处理完成，但是轮询到 consumer2 了，也要把消息投递给 consumer2。 添加以下配置解决上述问题： 声明交换机和队列通过编程的方式声明交换机和队列，如果声明的交换机或队列不存在就创建，存在就不处理。 使用 @Bean 注解声明创建 Exchange 对象方式： 创建 Binding 对象方式： 声明 Fanout 交换机 Fanout 交换机跟队列的绑定关系图： 声明 Direct 交换机 Direct 交换机跟队列的绑定关系图： 声明 Topic 交换机 Topic 交换机跟队列的绑定关系图： 使用 @RabbitListener 注解声明声明 Fanout 交换机 Fanout 交换机跟队列的绑定关系图： 声明 Direct 交换机 Direct 交换机跟队列的绑定关系图： 声明 Topic 交换机 Topic 交换机跟队列的绑定关系图： 消息转换器在数据的传输过程中，Spring AMQP 需要将 java 对象进行序列化与反序列化。默认情况下 Spring AMQP 序列化的结果不是 json 格式的数据，但我们希望是以 json 格式进行序列化与反序列化。 publisher 和 consumer 都需要进行修改。 publisher 和 consumer 都需要导入 jackson 依赖包，如果项目引入了 spring-boot-starter-web 就不需要了： publisher 和 consumer 都需要配置消息转换器： publisher 投递消息测试： publisher 投递消息结果： consumer 接收消息测试： consumer 执行结果： 【consumer】 user&#x3D;User(id&#x3D;1001, name&#x3D;lin, age&#x3D;18) RabbitMQ 相关配置"},{"title":"【CORS】跨域资源共享","date":"2024-03-29T01:00:00.000Z","url":"/blog/2024/03/29/JavaWeb/CORS/","tags":[["CORS","/blog/tags/CORS/"]],"categories":[["undefined",""]],"content":"什么是跨域请求什么是跨域请求：通过 http:&#x2F;&#x2F;localhost:8080 获得前端页面，但是前端页面 ajax 发起了 http:&#x2F;&#x2F;localhost:9090 后端请求。因为 ajax 发起的请求符合 3 种情况跨域中的一种（端口不同），所以说 ajax 这次发出的请求是跨域请求。 出现跨域请求的 3 种情况： 协议不同，如 http 和 https。 域名不同。 端口不同。 注：从一个页面跳转到另一个页面，不算跨域。 CORS 介绍CORS 是一个协议，定义了”跨域资源共享”的协议。 它允许浏览器向跨域服务器，发出 XMLHttpRequest 跨域请求，让 AJAX 请求不仅限于同域服务器。CORS 协议需要浏览器和服务器同时支持才能发出跨域请求。 基本上浏览器都是支持 CORS 协议的。在前端，使用 AJAX 发起同源请求和跨域请求的代码是一样的。浏览器如果发现 AJAX 发起的请求是跨域请求，就会根据 CORS 协议对跨域请求进行处理。 因此，能否实现 CORS 跨域请求的关键在服务器。只有服务器根据 CORS 协议进行相关配置，才可以跨域通信。 跨域请求的分类CORS 标准将跨域请求分为两类：简单请求和复杂请求。对这两类跨域请求的处理方式也不一样。 只要满足以下两大条件就属于简单请求： （1）请求方法是以下三种之一： HEAD GET POST （2）HTTP 的头信息只能含有以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain 不能同时满足以上两个条件的请求，就属于复杂请求。 简单请求的处理方式对于简单请求，浏览器在 AJAX 请求的基础上，在头信息中添加一个 Origin 字段。Origin 字段会说明本次跨域请求来自哪个源。 服务器根据 Origin 字段判断是否允许跨域，如果允许，服务器返回的响应头信息会包含 Access-Control-Allow-Origin 字段，不允许就不会包含该字段。 如果浏览器发现发出去的跨域请求得到响应的响应头信息不包含 Access-Control-Allow-Origin 字段，就在控制台抛出一个错误： 如果服务器允许，服务器返回的响应头信息里会多出以下几个字段： Access-Control-Allow-Origin：该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个 *****，表示接受任意域名的请求。 Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，CORS 跨域请求不能携带 Cookie 信息。设为 true，表示服务器允许接收同源 Cookie。 Access-Control-Expose-Headers：CORS 跨域请求，如果服务器想获得其它请求头字段信息，需要在该字段指定。 复杂请求的处理方式CORS 规定，在发起复杂的跨域请求前，需要先发送一次 OPTIONS 请求询问跨域服务器是否可以接收跨域请求。浏览器只有得到跨域服务器的肯定答复才会发送跨域请求。 OPTIONS 请求头信息： Origin：说明本次跨域请求来自哪个源。 Access-Control-Request-Method：说明本次跨域请求的方法是什么。 Access-Control-Request-Headers：说明本次跨域请求会额外携带的头信息。 OPTIONS 响应头信息： Access-Control-Allow-Origin：表示接受哪些任意域名的跨域请求，星号表示接收所有的跨域请求。 Access-Control-Allow-Methods：表示服务器支持的跨域请求方法。 Access-Control-Allow-Headers：表示服务器支持的跨域请求头字段。 Access-Control-Allow-Credentials：表示服务器是否支持跨域请求携带 Cookie 信息。 Access-Control-Max-Age：用来说明本次 OPTIONS 请求的有效期，单位为秒。在有效期内，不需要再发送相同的 OPTIONS 请求。 一旦服务器通过了浏览器的 OPTIONS 请求，在有效期内，浏览器对后面复杂的跨域请求的处理方式跟简单请求一样，只在跨域请求头信息添加 Origin 字段就行，不需要再发送 OPTIONS 请求。 withCredentials 属性CORS 跨域请求默认不携带 Cookie 信息。如果要携带 Cookie 信息，一方面要服务器同意，使 Access-Control-Allow-Credentials 字段为 true，另一方面前端开发者需要在 AJAX 请求中把 withCredentials 属性设置为 true。否则即使服务器同意接收 Cookie，浏览器处理跨域请求时候也不会携带 Cookie 信息。 注意，如果服务器要接收 Cookie 信息，在配置 Access-Control-Allow-Origin 时候就不能设为星号，必须指定明确的、与请求网页一致的域名。"},{"title":"【Gateway】基本使用","date":"2024-03-28T06:00:00.000Z","url":"/blog/2024/03/28/SpringCloud/Gateway/Gateway%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["Gateway","/blog/tags/Gateway/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"Gateway 介绍Gateway 是一个网关微服务框架，是所有微服务程序的统一入口。 网关的核心功能有： 权限控制：Gateway 作为微服务入口，需要校验用户是否有请求资格，如果没有则进行拦截。 请求路由：用户的所有请求都必须先经过 Gateway，但 Gateway 不处理业务，而是根据某种规则，把请求转发到目标服务。如果路由的目标服务有多个，还需要做负载均衡。 限流：当请求流量过高时，Gateway 根据指定策略对请求进行放行，避免服务压力过大。 Gateway 的使用示例 导入 gateway 依赖： 编写 gateway 配置： gateway 流程图： 路由的配置内容包括： 路由 id：路由的唯一标识。 路由目标 uri：路由的目标地址，http 开头代表固定地址，lb 开头代表根据项目的 id负载均衡。 路由断言 predicates：判断路由的规则。 路由过滤器 filters：对请求或响应做处理。 路由断言 Path：请求路径必须符合指定规则才能路由到目标地址。如果有多个规则，满足其中一个就行。示例： Path=/user/**：只要是以 user 开头的路径都符合要求。 Path=/red/&#123;segment&#125;：{segment} 是一个路径占位符，后续可以通过路径占位符获取值。 After：某个时间点之后的请求才符合要求，时间点之前的不符合要求。例如： After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver] Before：某个时间点之前的请求才符合要求，时间点之后的不符合要求。例如： Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai] Between：两个时间点之间的请求才符合要求，不在这个区间的不符合要求。例如： Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver] Cookie：请求必须包含指定 cookie。例如： Cookie=token：cookie 中必须要有 token。 Cookie=token,123：cokie中必须要有 token，且值为 123。 Header：请求必须包含指定 header。例如： Header=token：请求头中必须要有 token。 Header=token,123：请求头中必须要有 token，且值为 123。 Method：请求必须时指定的方法。例如： Method&#x3D;GET,POST Query：请求参数必须包含指定的参数名。例如： Query=name：url 中必须要携带 name 的参数名。 Query=name,lin：url 中必须要携带 name 的参数名，且值为 lin。 RemoteAddr：在范围内的 ip 才能符合要求。例如： RemoteAddr&#x3D;192.168.1.1&#x2F;24 Host：请求必须是指定的访问域名。例如： Host=**.lin.blog:81：请求的 url 的二级域名为 lin，顶级域名为 blog，三级域名随便，可以没有，端口为 81。 Weight：权重处理。 以 Query 路由断言示例 断言规则：url 要以 user 开头，且 url 要携带 name 和 age 参数，且值必须为 lin 和 18。 模拟场景： http:&#x2F;&#x2F;127.0.0.1:10010&#x2F;user&#x2F;1?name&#x3D;lin&amp;age&#x3D;18（符合要求） http:&#x2F;&#x2F;127.0.0.1:10010&#x2F;user&#x2F;1?name&#x3D;lin&amp;age&#x3D;19（不符合要求，age 值不为 18） http:&#x2F;&#x2F;127.0.0.1:10010&#x2F;user&#x2F;1?name&#x3D;lin（不符合要求，缺少 age 参数） 过滤器Gateway 过滤器介绍Gateway 的过滤器可以对进入 Gateway 的请求和返回的响应做处理。 Gateway 提供的过滤器StripPrefix跳过指定路径。 StripPrefix 示例 发起 &#x2F;name&#x2F;blue&#x2F;red 请求会被路由到 https:&#x2F;&#x2F;nameservice&#x2F;red，如果StripPrefix&#x3D;1，那么会被路由到 https:&#x2F;&#x2F;nameservice&#x2F;blue&#x2F;red。 RewritePath修改请求路径。 RewritePath 示例 发起 &#x2F;red&#x2F;blue 请求会被路由到 https:&#x2F;&#x2F;example.org&#x2F;red_v2&#x2F;blue。由于 YAML 的语法问题，$ 符号后面应该加上 \\。 PrefixPath给请求路径添加前缀。 PrefixPath 示例 发起 &#x2F;hello 的请求会被路由到 https:&#x2F;&#x2F;example.org&#x2F;mypath&#x2F;hello。 AddRequestHeader给当前请求添加一个请求头 RemoveRequestHeader移除请求中的一个请求头 AddResponseHeader给响应结果中添加一个响应头 RemoveResponseHeader从响应结果中移除有一个响应头 配置过滤器 针对某个路由添加过滤器： 针对所有路由添加过滤器： 自定义过滤器通过实现 GlobalFilter 接口来自定义过滤器，自定义的过滤器作用于全部路由。 注：exchange 对象是指请求上下文。请求从进入网关到返回响应内容，整个过程都共享 exchange 对象。 自定义过滤器示例 需求：如果请求头携带 authorization 参数，并且值为 admin 就放行，否则拦截请求。 过滤器的执行顺序 已知有三种过滤器： 针对单个路由配置的过滤器。 针对全部路由配置的过滤器（DefaultFilter）。 自定义的过滤器（GlobalFilter）。 排序规则： 每个过滤器都有一个 order 值，order 值越小，优先级越高，执行顺序越靠前。 GlobalFilter 通过实现 Ordered 接口，或者添加 @Order 注解来指定 order 值。通过配置声明的过滤器，默认按声明顺序从 1 开始递增。 当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。 模拟场景： 跨域请求 Gateway 处理跨域请求： add-to-simple-url-handler-mapping：true：表示将 corsConfigurations 配置信息添加到 SimpleUrlHandlerMapping 处理器中。 &#39;[/**]&#39; 或 &#39;[/user/**]&#39;：为指定的资源路径定义跨域规则，资源路径可以用正则表达式编写。如果一个路径匹配多个跨域规则，选择第一个匹配的跨域规则。根据声明的顺序从上到下依次匹配。 遇到的问题 问题1：正确导入 Gateway 依赖包，Gateway 相关配置也是正确的，但是访问显示 503 在 Spring Cloud Gateway 的早期版本中，Ribbon 被用作默认的负载均衡器。然而，从 Spring Cloud 2020.0.0 版本开始，Ribbon 被废弃，Spring Cloud LoadBalancer 成为了推荐的负载均衡方案。 在这个版本变动中，为了提供更大的灵活性，spring-cloud-starter-loadbalancer 被标记为了可选依赖，不再默认包含在 Spring Cloud Gateway 中。如果没有显式包含这个依赖，就会导致无法处理 lb:&#x2F;&#x2F;URI，从而返回503错误。 "},{"title":"【Feign】基本使用","date":"2024-03-28T01:00:00.000Z","url":"/blog/2024/03/28/SpringCloud/Feign/Feign%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["Feign","/blog/tags/Feign/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"Feign 介绍Feign 的作用：Feign 实现了类似 Dubbo 的操作，在 Consumer 实例中通过接口方法直接调用接口实现类方法的操作。 Feign 的使用示例 导入 Feign 的依赖包： 使用注解 @EnableFeignClients 开启 Feign 的功能： 编写 Feign 客户端，配合 SpringMVC 的注解编写： 测试 Feign 客户端： Feign 的相关配置Feign 的配置 类型 作用 说明 feign.Logger.Level 修改日志级别 包含四种不同的级别：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 响应结果的解析器 http远程调用的结果做解析，例如解析json字符串为java对象 feign.codec.Encoder 请求参数编码 将请求参数编码，便于通过http请求发送 feign. Contract 支持的注解格式 默认是SpringMVC的注解 feign. Retryer 失败重试机制 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 Feign 的日志级别 NONE：不记录任何日志信息，默认值。 BASIC：仅记录请求的方法，URL 以及响应状态码和执行时间。 HEADERS：在 BASIC 的基础上，还记录了请求和响应的头信息。 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 注：只有 debug 级别的日志才能看到 feign 输出的请求日志。 修改配置文件方式配置文件方式 代码方式 声明一个类，然后再声明一个 Logger.Level 的对象： 针对全服服务的配置： 针对某个服务的配置： 提高 Feign 的性能Feign 底层是依赖其它框架发起 http 请求的，依赖的框架包括： URLConnection：默认实现，不支持连接池。 Apache HttpClient：支持连接池。 OKHttp：支持连接池。 提高 Feign 的性能主要手段就是使用支持连接池的框架代替默认的 URLConnection 框架。 使用 Apache HttpClient 提高 Feign 性能示例 导入 HttpClient 依赖： 修改 Feign 的配置： 在 FeignClientFactoryBean 类中的 loadBalance() 方法打断点，重新启动项目看 httpclient 有没有生效： Feign 的实践方式我们喜欢把 Feign 的客户端接口都放到一个模块中，服务提供者导入该模块，然后实现 Feign 的客户端接口，服务消费者导入该模块，通过该接口方法发起调用。 创建 Feign-Client 模块，把跟 Feign 相关的客户端接口都放入该模块中： 服务提供者实现 Feign 的客户端接口： 服务消费者使用 @EnableFeignClients 注解开启 Feign 功能，并指定需要加载的 Clent 接口： 遇到的问题 问题1：将 Feign 的日志级别改为 FULL，但是没有输出请求日志 需要把 springboot 的日志级别改了debug，feign 才会输出请求信息。 "},{"title":"【Nacos】基本使用","date":"2024-03-27T01:00:00.000Z","url":"/blog/2024/03/27/SpringCloud/Nacos/Nacos%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["Nacos","/blog/tags/Nacos/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"Nacos 介绍Nacos 是一个服务注册中心和配置中心组件。主要用来注册&#x2F;发现服务，配置和管理微服务。 使用 Docker 搭建 Nacos 服务端环境。 Nacos 官网下载地址。 因为 Nacos 是 alibaba 的微服务组件，所以需要在 &lt;dependencyManagement&gt; 中导入 SpringCloudAlibaba 依赖： 注意：SpringCloudAlibaba 跟 SpringCloud 版本的兼容关系。 注册&#x2F;发现服务搭建 Nacos 环境服务提供者 导入 nacos discover 依赖包： 编写 nacos 配置： 服务消费者 导入 nacos discover 依赖包： 编写 nacos 配置： 注册 RestTemplate Bean 对象： 测试代码： 环境隔离处于 dev 环境的消费实例只能调用处于 dev 环境的服务实例提供的服务，不能访问 test、pro 等其它环境的服务实例。 再 nacos 服务端创建环境： 在服务实例或消费实例中配置所属环境： 实例分组一个服务提供者如果有多个实例，nacos 可以将这些实例分组，每个组就是一个集群。 nacos 集群划分的维度：服务提供者的 id + 所属的环境 + 所属的组名。 添加以下配置来分组： 修改服务消费者的负载均衡模式，要求优先访问同组的服务提供者，并且是根据服务实例的权重随机访问。 模拟场景 同一个服务提供者有以下实例： service-provider1，在 c1 组。 service-provider2，在 c2 组。 service-provider3，在 c2 组。 服务消费者的实例在 c2 组，那么服务消费者的实例需要调用服务的时候，只会调用 service-provider2 和 service-provider3 的服务，并且是根据权重随机调用。如果 service-provider2 和 service-provider3 都挂了，那么就会访问 service-provider1 的服务。 负载均衡 第一种方式，注入 IRule 的实现类，全局修改： 第二种方式，通过配置文件方式，针对指定的服务进行修改： 注：因为 Netflix 官方停止了对 Ribbon 负载均衡组件的维护，所以 nacos 在某个版本之后就不再引入 Ribbon 组件了，也不能再通过以上方式修改，需要使用其它方式修改。 统一配置管理拉取配置文件 导入 nacos 配置管理的依赖包： 在 nacos 服务端创建配置文件： 在 bootstrap.yml 配置文件中编写配置： 注：配置文件名称是由nacos 环境、项目名称、项目使用的环境、文件类型确定的。 配置热更新配置热更新：nacos 管理的配置文件做了修改，运行中程序立马能获得修改后的配置信息，无需重启项目。 springboot 读取配置主要有两种方式，一个是通过 @Value 注解读取，另一种是通过 @ConfigurationProperties 注解读取。 nacos 针对 springboot 读取配置的两种方式都有热更新处理措施。 针对 @Value 注解的热更新，需要配合 @RefreshScope 注解使用： 针对 @ConfigurationProperties 注解的热更新，不需要做什么，在 nacos 中自带热更新功能 读取多个配置文件nacos 除了会读取由项目名称、项目使用的环境、文件类型组成的配置文件名称，还会读取由项目名称、文件类型组成的配置文件名称。这个配置文件不包含环境，因此可以被多个环境共享。 例如项目名称为 configDemo 的项目，使用了 dev 环境，以下两个文件都能够读取： 多个配置文件的优先级相同配置，优先级高的生效，优先级从高到低排序： nacos 带环境的配置文件 nacos 不带环境的配置文件 本地 application.yml 配置文件 本地 bootstrap.yml 配置文件 Nacos 相关配置 遇到的问题 问题1：客户端 nacos 无法连接服务端 nacos 服务端 nacos 的版本为 2.3.1，客户端使用的 nacos 版本为 2.2.0。因为 nacos 客户端 2.0 以上的版本新增了长连接方式，采用的 gPRC 通信，此时客户端需要通过服务端的 9848 端口进行通信。如果没有把服务端的 9848 端口（主端口偏移 1000）暴露出来就无法连接 nacos 服务端。 将 nacos 客户端的 版本改为 1.4.1 也可以，因为 nacos 客户端 2.0 以下版本依旧采用短连接方式，不需要使用服务端的 9489 端口。 问题2：无法通过服务提供者的 id，获取服务提供者的地址 因为 nacos 在某个版本之后就没有自带 ribbon 的整合，所以需要引入 loadbalancer 依赖包，以及注册 RestTemplate 时需要使用 @LoadBalanced 注解标注。 问题3：无法读取 bootstrap.yml 文件 SpringCloud 2020.* 以后的版本把 bootstrap 禁用了，导致在读取文件的时候读取不到而报错。需要把 boostrap 依赖包导入才会生效。 "},{"title":"【Eureka】基本使用","date":"2024-03-26T01:00:00.000Z","url":"/blog/2024/03/26/SpringCloud/Eureka/Eureka%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["Eureka","/blog/tags/Eureka/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"RestTemplate 远程调用 服务提供者： 服务消费者，先注册 RestTemplate 为 bean 对象： 服务消费者，使用 RestTemplate 调用服务提供者提供的服务： Eureka 介绍Eureka 作为服务的注册中心，服务提供者可以将自己的唯一标识和访问服务的地址注册到 Eureka 中，然后服务消费者就可以根据服务提供者的唯一标识调用服务了。 把项目名称作为服务提供者&#x2F;消费者的唯一标识。 搭建 Eureka 环境搭建 Eureka 注册中心 导入 Eureka 注册中心依赖包： 编写 Eureka 配置： 添加 @EnableEurekaServer 注解： 访问 http:&#x2F;&#x2F;{eureka 服务端 ip}:{eureka 服务端 port}&#x2F;： Eureka 服务提供者 导入 Eureka 客户端依赖包： 编写 Eureka 配置： Eureka 服务消费者 导入 Eureka 客户端依赖包： 编写 Eureka 配置： 为 RestTemplate 添加 @LoadBalanced 负载均衡注解，否则 Eureka 服务不可用： 使用 restTemplate 对象访问服务提供者提供的服务： Ribbon 组件Ribbon 组件介绍Ribbon 是 SpringCloud 的一个负载均衡组件。 负载均衡策略 负载均衡策略 描述 RoundRobinRule 轮询服务提供者，它是 Ribbon 默认的负载均衡规则。 RandomRule 随机选择一个可用的服务提供者。 WeightedResponseTimeRule 根据服务器的权重来随机选择。 ZoneAvoidanceRule 把服务器以 Zone 地区划分，对 Zone 内的多个服务提供者做轮询。 BestAvailableRule 忽略那些短路的服务器，并选择并发数较低的服务器 AvailabilityFilteringRule 忽略以下两种服务器：（1）短路的服务器。如果服务器连续三次连接失败则短路，等待一段时间后再重新连接，如果连接失败等待时间增长。（2）服务器的并发数达到阈值就被忽略，可以设置并发数的阈值。 修改 Ribbon 配置Spring Cloud Netflix 3.0 以后的版本就没有 Ribbon 的依赖了，所以以下的配置是针对 Spring Cloud Netflix 3.0 之前的版本。 修改负载均衡策略 代码方式： 配置文件方式修改： 注：3.0 之后默认只有轮询和随机策略了，可以通过 ReactorServiceInstanceLoadBalancer 接口查看。 懒加载和饥饿加载Ribbon 默认是采用懒加载模式，即第一次访问时才会去创建 LoadBalanceClient 对象。 配置饥饿加载模式： "},{"title":"【SpringCloud】介绍","date":"2024-03-25T01:00:00.000Z","url":"/blog/2024/03/25/SpringCloud/SpringCloud%E4%BB%8B%E7%BB%8D/","tags":[["SpringCloud","/blog/tags/SpringCloud/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"SpringCloud 概述SpringCloud 集成了各种微服务组件，并基于 SpringBoot 实现了这些组件的自动装配功能。 SpringCloud 与 SpringBoot 版本对应关系 SpringCloud 版本 SpringBoot 版本 SpringCloud Alibaba 版本 2021.0.9 2.6.15 2021.0.6.0 2021.0.5 2.6.13 2021.0.5.0 Hoxton.SR12 2.3.12.RELEASE 2.2.9.RELEASE Hoxton.SR10 2.3.9.RELEASE 2.2.6.RELEASE Hoxton.SR9 2.3.2.RELEASE 2.2.6.RELEASE Hoxton.SR3 2.2.5.RELEASE 2.2.1.RELEASE 版本依赖详细说明 创建 SprngCloud 项目创建 SpringBoot 项目，然后引入以下配置 "},{"title":"【Dubbo】基本使用","date":"2024-03-24T01:00:00.000Z","url":"/blog/2024/03/24/Dubbo/Dubbo/","tags":[["Dubbo","/blog/tags/Dubbo/"]],"categories":[["undefined",""]],"content":"Dubbo 介绍架构演进 单体架构一个项目包含多个模块，缺点是可伸缩性差。 垂直架构将单体架构中的多个模块进行划分，形成多个独立的单体项目，多个单体项目之间不会通过网路进行交互。缺点是多个单体项目可能会有重复功能。 分布式架构把垂直架构中的公共业务模块抽取出来，作为独立的服务，供其它消费者使用，以实现服务的共享和重用，模块之间需要通过网络进行交互。缺点是服务的 ip 地址和端口号需要在消费端写死，不好维护。 RPC：远程过程调用协议。一种通过网络从远程计算机上请求服务，而不需要了解网络细节的协议。RPC 框架则是实现了 RPC 协议的框架。 SOA 架构 SOA：面向服务的架构。思想是按系统的不同功能单元（服务）进行拆分，服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中，服务之间通过网络进行交互。 ESB：企业服务总线。ESB 主要是提供了一个服务供其它服务之间相互通信。 微服务架构微服务架构在划分服务的粒度上更小，并且每个服务有它自己的数据库。原来的单个系统会被拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。 Dubbo 概述Dubbo 是 SOA 时代的产物，是一个实现了 RPC 协议以及 SOA 治理方法的框架。 Dubbo 架构 节点角色说明： Provider：服务提供方。 Container：运行服务的容器。 Consumer：服务消费方。 Registry：注册中心，用来注册服务和发现服务的。 Monitor：服务监控中心，用来统计服务的调用次数和调用时间的。 服务注册与发现的三要素 注册中心的地址。 项目的 id。 项目要注册&#x2F;发现的服务。 入门示例Spring 整合 Dubbo 服务提供者和消费者导入相同的依赖包： 服务提供者提供的服务： 服务提供者的 dubbo 配置： 服务消费者获取远程调用对象： 服务消费者的 duboo 配置： Dubbo 可视化管理界面dubbo-admin 是一个 dubbo 可视化管理平台，它通过注册中心获取服务提供者和服务消费者的数据并进行配置管理。dubbo-admin 的官网下载地址。 搭建 dubbo-admin 步骤： 由于 dubbo-admin 的前端界面是由 vue 编写的，因此需要先搭建 node.js 环境。如果 node.js 的版本太高会导致 vue 运行不起来，考虑使用 16 以下的版本。 修改 dubbo-admin-server 中的 application.properties 文件的注册中心配置。 使用 maven 把 dubbo-admin 打成 jar 包。 使用 java -jar 运行 dubbo-admin-distribution 目录中的 dubbo-admin.jar 包。 切换到 dubbo-admin-ui 目录，使用 npm run dev 命令启动前端。 访问 {dubbo-admin ip}:{dubbo-admin port}，账号和密码默认都是 root。 dubbo 可视化界面，元数据信息栏配置： 在服务提供者的 dubbo 配置文件中添加一下配置： 注：在部分版本的 dubbo 可视化界面，服务消费者使用了服务提供的服务，才会在界面上显示，不使用则不会显示。 Dubbo 高级特性序列化需要在网络传输的 Java POJO 对象都需要先实现 Serializable 序列化接口，否则将会抛出 IllegalStateException：must implement java. io. Serializable 的异常。 地址缓存dubbo 的服务消费者在第一次调用服务的时候会将服务提供方的地址缓存到本地，以后再调用的时候就不会访问注册中心了。因此如果注册中心挂了，服务消费者可能还可以调用服务提供者提供的服务。 如果服务提供者的地址发生了变化，注册中心会通知服务消费者修改缓存中的地址。 超时与重试dubbo 使用 timeout 属性配置超时时间，默认值 1000，单位毫秒。在这个时间段内，如果调用服务没有响应，则自动断开连接。 服务消费者如果调用服务失败了，可以重试调用。dubbo 通过 retries 属性来设置重试次数，默认为 2 次。如果设置为 2，最多可调用 3 次。 在服务提供者设置超时与重试： 在服务消费者设置超时与重试： 多版本dubbo 通过 version 属性来设置和调用同一个接口的不同版本。 服务提供者，提供两个不同版本的服务： 服务消费者，获取远程调用对象的时候，需要指定对象的版本： 负载均衡dubbo 提供了 4 种负载均衡策略： RandomLoadBalance：默认策略，按权重随机。 RoundRobinLoadBalance：按权重轮询。 LeastActiveLoadBalance：按服务效率调度，效率高的服务被调度次数多。服务效率相同则随机调度。 ConsistentHashLoadBalance：根据 hash 调度，相同参数的请求总是调用同一服务提供者。 通过 loadbalance 属性定义负载均衡策略。 服务消费者定义负载均衡策略： 服务提供者定义负载均衡策略： 集群容错但服务提供者提供服务时候出现了错误，处理的措施。 dubbo 提供了多种集群容错模式： FailoverCluster：默认值，失败重试。当服务调用失败时，默认重试 2 次，使用 retries 配置。一般用于读操作。 FailfastCluster：快速失败，只发起一次调用，失败立即报错。通常用于写操作。 FailsafeCluster：安全失败，出现异常时，返回一个空结果。 FailbackCluster：失败后定时重发。 ForkingCluster：并行调用多个服务器，只要有一个成功返回即可。 BroadcastCluster：广播所有服务提供者，逐个调用，任意一台服务器报错则报错。 通过 cluster 属性配置集群容错模式。 服务消费者定义集群容错策略： 服务降级服务降级：一台服务器可能有支付服务、广告服务等，如果服务器达到性能瓶颈，可以关掉广告服务等不重要的服务，释放性能供核心服务使用。 dubbo 的服务降级方式： mock&#x3D;force:return null：表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 mock&#x3D;fail:return null：表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。 遇到的问题空指针异常可能的原因1：返回的对象的实体类没有实现 Serializable 接口，不支持序列化，也不支持在网络传输。 远程代理对象注入为 null不管是使用 @DubboReference 注解还是 @Reference，远程代理对象注入都为 null。 原因：Spring 容器里的 Bean 使用 @DubboReference 注入属性时可以注入远程代理对象，但是 SpringMVC 容器里的 Bean 用 @DubboReference 注入属性时为 null。"},{"title":"【Zookeeper】基本使用","date":"2024-03-22T01:00:00.000Z","url":"/blog/2024/03/22/Zookeeper/Zookeeper/","tags":[["Zookeeper","/blog/tags/Zookeeper/"]],"categories":[["undefined",""]],"content":"Zookeeper 介绍Zookeeper 简介zookeeper 是一个分布式应用程序的协调服务，主要功能有：配置管理、分布式锁、集群管理。 Zookeeper 的数据模型zookeeper 是一个树形目录服务，以 / 作为根目录。 zookeeper 的每个节点称为 ZNode，每个节点都会保存节点信息和自己的数据。 节点可以拥有子节点，同时也允许少量数据（1MB）存储在该节点之下。 节点分为四大类： PERSISTENT：持久节点，客户端断开跟服务端的连接，重新连接后节点不会消失。 EPHEMERAL：临时节点，客户端断开跟服务端的连接，重新连接后节点会消失。 PERSISTENT_SEQUENTIAL：持久顺序节点 ，创建的时候会在节点名称后面加编号，编号递增，所有节点共用一个编号。 EPHEMERAL_SEQUENTIAL：临时顺序节点，创建的时候会在节点名称后面加编号，编号递增，所有节点共用一个编号。 Zookeeper 命令操作服务端命令 启动 ZooKeeper 服务: .&#x2F;zkServer.sh start 停止 ZooKeeper 服务: .&#x2F;zkServer.sh stop 重启 ZooKeeper 服务: .&#x2F;zkServer.sh restart 查看 ZooKeeper 服务状态: .&#x2F;zkServer.sh status 客户端命令连接 zookeeper 服务端 断开跟服务端的连接 查询指定节点下的子节点 选项： -s：显示指定节点的详细信息。 详细信息内容包括： cZxid：节点被创建的事务ID。 ctime：节点被创建的时间。 mZxid：最后一次被更新的事务ID。 mtime：最后一次被修改的时间。 pZxid：子节点列表最后一次被更新的事务ID。 cversion：子节点的版本号。 dataVersion：数据版本号。 aclVersion：权限版本号。 ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为 0。 dataLength：节点存储的数据的长度。 numChildren：当前节点的子节点个数。 创建节点 选项： -s：创建持久顺序节点。 -e：创建临时节点。 -es：创建临时顺序节点。 删除节点删除单个节点，要求被删除的节点下没有子节点： 删除所有节点： 查询指定节点的 value 修改节点的 value Curator API 操作 ZookeeperCurator 介绍Curator 是一个提供了一组 Java API 来操作 Zookeeper 的框架。 注：低版本的 Curator 无法操作高版本的 Zookeeper，注意 Curator 版本跟 Zookeeper 版本的兼容问题。 curator 依赖包： Curator API 操作建立连接 第一种建立连接的方式： 第二种建立连接的方式： 查询指定节点下的子节点 创建节点 删除节点删除单个节点： 删除所有节点： 确保删除操作成功。遇到网络波动等原因，指令没有发送到服务器，会重复发送： 删除执行完成后回调方法： 查询指定节点的 value查询指定节点的 value 获取节点的详细信息： 修改节点的 value Watch 事件监听zookeeper 允许客户端监听节点，当被监听的节点的状态发生改变时，例如创建、删除、修改 value 值等，客户端的监听器会执行相关的方法。 Curator 提供了三种监听类型： NodeCache : 只是监听某一个特定的节点。 PathChildrenCache : 监听指定节点的子节点. TreeCache : 可以监听指定树上的所有节点。 NodeCache 监听器示例： PathChildrenCache 监听器示例： TreeCache 监听器示例： 分布式锁分布式锁：用来协调分布式应用程序获取共享资源的锁。 zookeeper 实现分布式锁的原理 核心思想：当应用程序想要获取锁的时候，先创建节点，使用完锁就删除节点。 应用程序想要获取锁，先在 lock 节点下创建临时顺序节点。 然后获取 lock 节点下的子节点，如果自己创建的节点的编号最小则表示获取锁。 如果自己创建的节点的编号不是最小，则监听比自己编号小的节点。 如果监听到比自己编号小的节点被删除了，则表示自己获取到了锁。 在 Curator 中已实现的五种分布式锁的方案： InterProcessSemaphoreMutex：分布式排它锁，不可重入。 InterProcessMutex：分布式可重入排它锁。 InterProcessReadWriteLock：分布式读写锁。 InterProcessMultiLock：将多个锁作为单个实体管理的容器。 InterProcessSemaphoreV2：共享信号量。 InterProcessMutex 锁示例： 集群集群角色Leader 领导者：处理事务请求（增删改），同步事务处理结果给其它 zookeeper 服务器。 Follower 跟随着：处理非事务请求（查询），转发事务请求给 Leader，可以参与投票。 Observer 观察者：处理非事务请求（查询），转发事务请求给 Leader，不可以参与投票。 Leader 选举leader 选举：根据 zookeeper 集群的投票结果选出 leader，如果票数过半就可以成为 leader。 选举指标： ServerId：服务器 id，id 越大权重越大。 Zxid：数据 id，id 越大权重越大。 "},{"title":"【Spring】多数据源","date":"2024-03-20T01:00:00.000Z","url":"/blog/2024/03/20/Spring/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/","tags":[["Spring","/blog/tags/Spring/"]],"categories":[["undefined",""]],"content":"Spring 多数据源原理ORM 框架通过 Spring-JDBC 获取 DataSource 对象，通过 DataSource.getConnection() 获取 Connection 数据库连接对象。ORM 框架拿到 Connection 数据库连接对象就可以操作数据库了。 如果 DataSource.getConnection() 可以根据需要返回不同的数据库的 Connection 连接对象，那么 ORM 框架就可以操作不同的数据库了。 AbstractRoutingDataSource抽象类的作用AbstractRoutingDataSource 作为 DataSource 的抽象类，提供了 getConnection() 方法来根据不同的要求提供不同的 Connection 连接对象。继承 AbstractRoutingDataSource 抽象类，可以实现多数据源的功能。 AbstractRoutingDataSource 抽象类有三个重要的部分： Map&lt;Object, Object&gt; targetDataSources 属性：用来存放所有的数据源。 Object defaultTargetDataSource 属性：默认的数据源。 Object determineCurrentLookupKey() 方法：用来定义获取 DataSource 的策略，返回 targetDataSources 的 key。 自定义多数据源需求：定义一个查询接口，根据传入的 dataSourceName 参数值来确定使用哪个数据库。 实现方式：使用 AbstractRoutingDataSource 接口 + 自定义注解 + AOP 实现该需求。 yml 配置文件： 向 Spring 容器注册多个数据源： 实现 AbstractRoutingDataSource 抽象类： 编写 @DataSource 注解，把方法的参数名传给 value，作用是获取方法中指定参数的值： mapper 接口 前置通知，作用是在执行 SQL 前解析 @DataSource 注解，然后获取方法上指定的参数值，也就是获取数据源的唯一标识，后续才能获取指定的数据源执行 SQL： pom.xml 配置： 项目启动类： 测试多数据源代码： 测试结果： Dynamic Datasource 组件作用Dynamic Datasource 组件主要用来完成数据源切换的工作。 入门示例 导入依赖： yaml 配置： UserDao 类： UserMapper 接口 测试： 测试结果： User(id&#x3D;1, name&#x3D;Jone, age&#x3D;18, email&#x3D;test1@baomidou.com)User(id&#x3D;1, name&#x3D;Lin, age&#x3D;18, email&#x3D;test1@baomidou.com) @DS 注解动态解析数据源使用 spel 语法从方法参数取值 接口方法 + @DS 存在的问题 使用 @DS 注解标注接口方法，无法通过 spel 获取参数值。因为编译器的默认配置不会将接口方法的参数名写入字节码文件中，因此 spring spel 无法识别参数名称，也无法获取参数值。 可以通过修改 maven 配置和 java 编译配置将接口参数信息写入字节码文件中： 记得执行 maven 的 clean 和 compile 命令，重新生成编译文件。"},{"title":"【Mybatis】MyBatis Plus 扩展功能","date":"2024-03-19T01:00:00.000Z","url":"/blog/2024/03/19/Mybatis/mybatis_plus%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/","tags":[["Mybatis","/blog/tags/Mybatis/"]],"categories":[["undefined",""]],"content":"代码生成下载 MyBatisPlus 插件 使用示例： 逻辑删除逻辑删除要被当作物理删除看待，不要对被逻辑删除的数据做任何操作，包括查询和修改。 使用逻辑删除后，不能通过更新修改逻辑删除字段，只能通过删除操作修改逻辑删除字段。 全局配置 单表配置 逻辑删除失效场景 自定义 SQL + Wrapper 枚举处理器配置从 MyBatis Plus 3.5.2 版本开始只需完成声明通用枚举属性即可使用。 示例： 实体类 枚举返回结果默认情况下，Jackson ObjectMapper 将枚举类型 Enum 转换为它的名称。使用 @JsonValue 标记响应 json 值。 可能存在的问题如何处理 enum -&gt; json 和 json -&gt; enum。 JSON 处理器数据库字段类型为 json。 分页插件配置分页插件 使用分页插件 mapper 接口： 测试插件： 注： 返回类型如果是 IPage，那么参数 IPage 不能为 null，如果不想分页了可以把 size 设置为负数。 如果返回类型为 List，那么参数 IPage 可以为 null，为 null 则不分页。但是 IPage.getRecords 返回的是空列表。 Page 对象page 对象的属性： 属性名 默认值 描述 records emptyList 查询数据列表 total 0 查询列表总记录数 current 1 当前页 size 10 每页显示条数，默认 10 自动填充功能作用：每次 insert 或 update 时候，自动为实体对象指定的属性赋值。例如：创建时间、更新时间等。 需要自动填充的属性要被 @TableField 注解标记，并在 fill 属性说明需要在哪个阶段填充： 实现 MetaObjectHandler 接口，编写自动填充的逻辑： "},{"title":"【Mybatis】MyBatis Plus","date":"2024-03-17T01:00:00.000Z","url":"/blog/2024/03/17/Mybatis/mybatis_plus/","tags":[["Mybatis","/blog/tags/Mybatis/"]],"categories":[["undefined",""]],"content":"MyBatis Plus 介绍MyBatis Plus 简介MyBatis 可以让我们更方便的在 Java 中编写 SQL 查询数据库，MyBatis Plus 在 MyBatis 的基础上实现了对单表操作的 SQL、能够更方便的构建 SQL 的 where 条件，还扩展了多数据源、逻辑删除、字段自动填充等功能。 MyBatis Plus 入门导入依赖项目基于 SpringBoot 2 创建 配置数据源 创建实体类 创建 mapper 接口 扫描 mapper 目录 创建 Dao 类 数据库 SQL 测试类 测试结果： User(id&#x3D;1, name&#x3D;Jone, age&#x3D;18, email&#x3D;test1@baomidou.com)User(id&#x3D;2, name&#x3D;Jack, age&#x3D;20, email&#x3D;test2@baomidou.com)User(id&#x3D;3, name&#x3D;Tom, age&#x3D;28, email&#x3D;test3@baomidou.com)User(id&#x3D;4, name&#x3D;Sandy, age&#x3D;21, email&#x3D;test4@baomidou.com)User(id&#x3D;5, name&#x3D;Billie, age&#x3D;24, email&#x3D;test5@baomidou.com) 总结MyBatis Plus 使用实体类映射表结构，通过 BaseMapper 接口实现了对单表的 SQL 操作。实体类的属性就是 SQL 查询的字段。 MyBatis Plus 提供的注解@TableName实体类映射数据表。 @TableId实体类属性映射数据表主键。 属性： type：指定主键类型，有以下取值。 IdType.AUTO：数据库自增。 IdType.NONE：无状态，跟随全局设置。 IdType.ASSIGN_ID：根据雪花算法生成 id。 @TableField实体类属性映射数据库表字段。 属性： exist：被注解标注的字段是否存在，默认为 true。 @TableLogic被标注的表字段用逻辑删除处理。 属性： value：逻辑未删除值。 delval：逻辑删除值。 MyBatis Plus 相关配置 条件构造器构造器 eq：字段 &#x3D; val ne：字段 !&#x3D; val gt：字段 &gt; val ge：字段 &gt;&#x3D; val lt：字段 &lt; val le：字段 &lt;&#x3D; val between：字段 between (v1, v2) like：字段 like ‘%值%’ likeLeft：字段 like ‘%值’ likeRight：字段 like ‘值%’ isNull：字段 is null isNotNull：字段 is not null in：字段 in (v1, v2, v3 …) groupBy：group by 字段 orderByAsc：order by 字段 asc orderByDesc：order by 字段 desc or：拼接 or。例如 or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))---&gt;or (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;) and：拼接 and and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))---&gt;and (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;) lambdaQuery 链式 lambdaUpdate 链式 LambdaQueryWrapper 链式 LambdaUpdateWrapper 链式 单表 SQLIService save saveOrUpdate remove update get list page count chain BaseMapper insert delete update select 自定义 SQL + Wrapper由 wrapper 对象来完成 SQL 中的 where 部分，SQL 的其它部分由我们来完成。 mapper 接口： mapper.xml： 测试类： 注：使用该方式会导致 MyBatis Plus 无法自动处理逻辑删除。 IService 批量新增插入 10 万条数据。 for 循环一条一条插入：程序跟数据库 io 10 万次，执行 insert 语句 10万次。 IService 每 1000 条批量插入：程序跟数据库 io 100 次，执行 insert 语句 10 万次。 mysql url 添加 rewriteBatchedStatements&#x3D;true 参数：程序跟数据库 io 100 次，执行 insert 语句 100 次。 MyBatis Plus 使用规范继承 ServiceImpl 类的类，不可以在继承类中编写链式查询和跟 wrapper 相关的代码。如果这么做会造成 mapper 层的代码入侵 service 层，使得 service 层的职责不那么明确。而且在复杂业务中，在 service 层编写本属于 mapper 层的代码，可能会导致 service 代码过长，导致 service 层代码的可读性差。 解决方案-1： 三层架构 controller 层、service 层、mapper 层。service 层不再继承 ServiceImpl 类，也不实现 IService 接口。 解决方案-2： 改成四层架构：controller 层、service 层、dao 层、mapper 层。dao 层继承 ServiceImpl 类。service 层引用 dao 层的对象，不需要引用 mapper 层的对象，因为通过 dao 对象可以获取到 mapper 对象。这样在 dao 层依然可以使用 MyBatis Plus 的功能，同时保证代码不会入侵 service 层。 "},{"title":"【Idea】功能","date":"2024-03-13T06:00:00.000Z","url":"/blog/2024/03/13/Idea/IDEA%E5%8A%9F%E8%83%BD/","tags":[["Idea","/blog/tags/Idea/"]],"categories":[["Idea","/blog/categories/Idea/"]],"content":"隐藏指定的文件或文件类型 标签页多行显示 SpringBoot 配置文件缺少提示功能 例如输入 port 没有弹出提示框： 为项目模块添加 Spring 框架： 将指定的配置文件添加到 Spring 框架中： 再次输入 port 有提示功能了： 跳过 Maven 测试插件 为程序添加运行属性 启用 lombok 注解"},{"title":"【SpringBoot】原理","date":"2024-03-13T06:00:00.000Z","url":"/blog/2024/03/13/SpringBoot/SpringBoot%E5%8E%9F%E7%90%86/","tags":[["SpringBoot","/blog/tags/SpringBoot/"]],"categories":[["SpringBoot","/blog/categories/SpringBoot/"]],"content":"Spring Bean 的创建方式配置文件通过 Spring.xml 配置文件声明 Bean，可以使用 @ImportResource 注解导入配置文件。 配置类通过配置类声明 Bean。 注解通过注解声明 Bean。 FactoryBean 接口通过 FactoryBean 接口的实现类声明 Bean。 @Import 注解使用 Import 注解导入要注入的 Bean 对应的字节码。 注：如果 SpringConfig 类没有被注册到 Spring 容器中，那么 @Import 注解不会生效。 ImportSelector 接口使用 ImportSelector 接口的实现类，返回需要被注册的 Bean 的全限定类名。 importingClassMetadata 对象存储的是被 @Import 注解标注的类的相关信息。例如上述代码的 importingClassMetadata 对象可以获取 SpringConfig 对象相关的信息。 ImportBeanDefinitionRegistrar 接口 通过 BeanDefinitionRegistry 对象注册 Bean。相较于 ImportSelector 接口的注册方式，ImportBeanDefinitionRegistrar 接口可以在注册 Bean 的时候设置属性，例如 Bean 的 id，是否懒加载等。 BeanDefinitionRegistryPostProcessor 接口Bean 的注册后置处理器。在把 Bean 的信息封装成 BeanDefinition 对象，添加到 map 集合后，执行 BeanDefinitionRegistryPostProcessor 接口的方法。 Bean 的加载控制使用 @Conditional 注解的派生注解配置注册 Bean 需要满足的条件。 @ConditionalOnClass如果存在指定的类，就注册 Bean。 @ConditionalOnMissingClass如果不存在指定类，就注册 Bean。 @ConditionalOnBean如果容器有指定的 Bean，就注册 Bean。 @ConditionalOnNotWebApplication如果项目不是 Web 环境，就注册Bean。 @ConditionalOnProperty 源码如下： Properties 属性类将业务功能和业务功能需要的配置分离，用一个 Properties 类专门管理业务功能需要的配置。 例如：官方编写 Redis 的自动配置类 RedisAutoConfiguration，将自动配置业务需要的配置由 RedisProperties 类来管理。 SpringBoot 自动装配原理 收集开发者开发过程中常用的技术，整理成技术集。技术集中的每个技术都有对应的自动装配类。。 收集技术集中每个技术常用的配置参数，整理成配置集。 SpringBoot 创建后，根据用户导入的坐标和自定义的 bean，形成初始化环境。 每个技术的自动装配类能否生效，取决于 SpringBoot 的初始环境，也就是用户导入的坐标和自定义的 bean。 如果自动装配类生效，从配置集中获取该自动装配需要的配置，减少开发者配置的工作量。 对外开放配置集的覆盖接口，由开发者根据自身需要决定是否覆盖默认配置。 @SpringBootApplication 注解 @SpringBootApplication 注解的实现： @SpringBootApplication 注解具有以下三个注解的功能： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan @SpringBootConfiguration表示该类是 SpringBoot 的一个配置类。 @EnableAutoConfiguration作用是向 Spring 容器注册两个 Bean： AutoConfigurationPackages.Registrar.class：作用是注册一个名称为 AutoConfigurationPackages 的 BasePackages.class 实例。这个实例的作用在于保存自动扫描的包路径。后续通过 AutoConfigurationPackages Bean 可以获取自动扫描的包路径。 AutoConfigurationImportSelector.class：注入 spring.factories 文件中 EnableAutoConfiguration 对应的类的实例。该实例要经过 spring.factories 文件中 AutoConfigurationImportFilter 对应的过滤器过滤，还要排除掉 @EnableAutoConfiguration 中的 exclude 和 excludeName 指定的实例。 控制 SpringBoot 内置自动配置加载： 或者： @ComponentScan将路径下合适的类加载到容器中。 自定义 starter需求统计 ip 访问网址的次数。 后台每 5 秒输出一次监控信息（IP+访问次数）。 只需要在 pom 文件引入 starter 就拥有该功能，不需要额外操作。 属性配置 统计与输出功能 Web 拦截器 自动配置类 spring.factories 文件 yaml 配置提示功能添加以下依赖 "},{"title":"【SpringBoot】Yaml 配置文件","date":"2024-03-13T01:00:00.000Z","url":"/blog/2024/03/13/SpringBoot/Yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","tags":[["SpringBoot","/blog/tags/SpringBoot/"]],"categories":[["SpringBoot","/blog/categories/SpringBoot/"]],"content":"Yaml 文件介绍Yaml 是一种数据序列化格式。Yaml 作为配置文件，容易阅读、容易与脚本语言交互。 文件扩展名： .yml（主流） .yaml Yaml 语法规则语法规则 大小写敏感。 属性层级关系使用多行描述，每行结尾使用冒号结束。 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格，不允许使用 Tab 键。 属性值前面添加空格（属性名与属性值之间使用冒号 + 空格作为分隔）。 # 表示注释。 字面量表示方式 数组表示方式数组表示方式：在属性名书写位置的下方使用减号作为数组的开始符号。每行书写一个数据，减号与数据间空格分隔。 数组示例： 对象数组格式示例： 引用变量的值在配置文件中可以使用 ${变量名} 的方式引用变量值。 引用变量值示例： 转义字符如果属性值中出现了转义字符，需要使用双引号包裹，转义字符才能够生效，否则只会原样输出。 示例： 输出结果： Spring bootlesson "},{"title":"【SpringBoot】各种配置","date":"2024-03-12T06:00:00.000Z","url":"/blog/2024/03/12/SpringBoot/SpringBoot%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AE/","tags":[["SpringBoot","/blog/tags/SpringBoot/"]],"categories":[["SpringBoot","/blog/categories/SpringBoot/"]],"content":"SpringBoot 内置属性查询 服务器相关的配置访问项目的端口 访问项目的路径 整合 Junit 导入依赖包： 创建测试类，并在测试类上添加 @SpringBootTest 注解： 注：如果测试类在 SpringBoot 启动类的包或子包中，可以省略 classes 属性的配置。如果不在就必须要配置。也可以使用 @ContextConfiguration 注解配置。 整合 MyBatis导入依赖包 相关配置 数据源配置： MyBatis 配置： @Mapper 注解映射 SQL 接口需要添加 @Mapper 注解修饰，才能被容器识别到。 示例： 整合 Druid添加依赖 注：创建项目的时候，没有 Druid 相关的依赖项可以添加。到 Maven 仓库查询版本的时候注意跟 SpringBoot 版本的兼容问题。 相关配置 第一种配置，指定数据源的类型： 第二种配置，配置 Druid 数据源的相关信息： 日志相关的配置获取日志对象 使用 lombox 提供的 @Slf4j 对象： 配置日志的级别 日志有 6 种级别： 配置日志的输出格式 SpringBoot 日志默认地输出格式： %d：打印日志的时间。 %clr()：彩色符号。 %p：日志级别。%clr(%p) 表示打印彩色的日志级别。 %t：线程名。 %c：类名 %m：日志输出信息。 %n：换行符。 修改日志输出格式： 转存日志文件 存储日志配置： 输出结果： banner 配置关闭 banner 图标 banner 图片所在的位置 "},{"title":"【SpringBoot】基础","date":"2024-03-12T01:00:00.000Z","url":"/blog/2024/03/12/SpringBoot/SpringBoot%E5%9F%BA%E7%A1%80/","tags":[["SpringBoot","/blog/tags/SpringBoot/"]],"categories":[["SpringBoot","/blog/categories/SpringBoot/"]],"content":"SrpingBoot 介绍SpringBoot 简介SpringBoot 是用来简化 Spring 应用的搭建过程和开发过程。 创建 SpringBoot 项目自动创建 SpringBoot 项目 构建 SpringBoot 用到的 URL： 选取当前模块需要使用的技术集（Web 功能）： 创建完成即可运行 SpringBoot 项目。 手动创建 SpringBoot 项目 创建一个 QuickStart 类型 maven 项目 在 pom.xml 文件加入以下内容： 创建项目启动的入口： Controller 示例： 完成上述工作即可运行 SpringBoot 项目。 SpringBoot 项目的结构parent 标签的作用parent 整理了若干个依赖的版本，制作出了最合理的依赖版本配置方案。继承 parent 模块可以避免多个依赖使用相同技术时出现依赖版本冲突的问题。 spring-boot-starter-parent 依赖管理示例： starter 标签的作用SpringBoot 将常用的功能所需要的多个依赖组合成一个 starter 依赖配置，只需要导入一个 starter 依赖就可以使用该功能，减少依赖配置。 Web 功能（spring-boot-starter-web）引入的依赖示例： 引导类 SpringBoot 启动方式： SpringBoot 项目提供引导类用来启动程序。 SpringBoot 项目启动会后初始化 Spring 容器，然后加载引导类所在的包及其子孙包下的所有 bean。 SpringBoot 的优点SpringBoot 项目创建完成后，可以直接运行该项目，不需要导入 web 相关的依赖包，不需要编写 web.xml 配置文件，也不需要编写 Spring 和 SpringMVC 的配置类，SpringBoot 都默认帮我们处理好了。 SpringBoot 的配置文件不同配置文件类型的优先级 相同配置文件类型的优先级 读取配置文件的方式 配置文件内容： 使用 @Value 注解配合 SpEL 语法读取单个数据： 注：@Value(“${变量名}:默认值”)，当变量名不存在时，使用默认值。 使用 @ConfigurationProperties 注解将配置信息绑定到指定的 bean 对象： 如果使用 @ConfigurationProperties 注解时遇到以下提示信息： 添加以下依赖后，提醒就会消失： 使用 Environment 对象读取配置文件数据示例： 自定义配置文件名–spring.config.name&#x3D;文件名：指定 springboot 配置文件的名称，默认是 applicaton。文件名不需要带文件类型后缀。 示例： 自定义配置文件路径–spring.config.location&#x3D;文件路径：指定配置文件路径。文件的加载顺序为指定的顺序，后加载的配置覆盖先加载的配置。 示例： 配置文件高级第三方 Bean 绑定自定义配置 配置文件内容： 将自定义配置与第三方 Bean 属性进行绑定： 注：前缀必须全部小写的。 @EnableConfigurationProperties@EnableConfigurationProperties 注解的作用：表明 Spring 容器中有哪些 Bean 需要绑定配置信息。 使用该注解得到的 Bean 的 id 是 Bean 的全限定类名。 使用示例： 表示 AuthorConfig 类需要绑定配置信息： AuthorConfig 类如果没有被 @ConfigurationProperties 标注会抛异常，同时 Spring 容器会默认将其标注的类定义为 Bean，因此不需要标注 @Component 注解了。 宽松绑定 在 ServerConfig 类中的 ipAddress 属性名。 可以与下面的配置属性名规则全兼容： 匹配规则：配置中的名称去掉中划线和下划线后，忽略大小写的情况下去与类中的属性名进行忽略大小写的等值匹配。@Value 注解不支持松散绑定规则。 四种命名规则中，官方推荐使用中划线做分隔符。 计量单位绑定有以下配置： 没有说明的情况下，对 timeout 和 data-size 的使用的单位是不清楚的。我们可以在配置类使用注解说明属性的单位，例如： Duration：表示时间间隔，可以通过 @DurationUnit 注解描述时间单位。 DataSize：表示存储空间，可以通过 @DataSizeUnit 注解描述存储空间单位。 配置数据校验导入校验依赖 使用注解编写校验规则 在配置文件遇到的问题数据类型转换 有以下配置： 问题：数据库的密码是 0127，但是启动项目的时候显示密码错误。 原因：0127 在 SpringBoot 看来是一个八进制的数字。当后台使用 String 类型接收数据时，如果配置文件中配置了一个整数值，SpringBoot 先按整数进行处理，读取后再转换成字符串。0127 最终以十进制数字 87 的结果存在了。 多环境开发多环境配置文件 主启动配置文件 application.yml 环境分类配置文件 application-pro.yml 环境分类配置文件 application-dev.yml 环境分类配置文件 application-test.yml 注：主配置文件的配置与环境配置文件的配置冲突，以环境配置文件为主。 多环境多功能配置文件 根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下： 加载指定的配置文件： 读取 Maven 属性 pom.xml 文件添加以下内容： 使用 ${变量名} 读取 pom.xml 定义的变量值： Spring Boot 测试临时属性和命令临时属性 临时命令 测试临时专用配置 在测试包 test 中创建在测试环境专用的配置类： 使用 @Import 注解导入配置类： 模拟 Web 测试环境启动 web 测试环境 通过设置 webEnvironment 属性可以在测试中启动 web 环境。 WebEnvironment 枚举值： MOCK：根据当前设置确认是否启动 web 环境，例如使用了 Servlet 的 API 就启动 web 环境，属于适配性的配置。 DEFINED_PORT：使用自定义的端口作为 web 服务器端口。 RANDOM_PORT：使用随机端口作为 web 服务器端口（一般用这个）。 NONE：不启动 web 环境。 在 web 测试中发送请求 开启 web 虚拟调用功能： 通过 MockMvc 对象发起请求： 注：写访问路径时候，不需要 ip 和端口，指定请求路径即可，因为 ip 和端口都是虚拟出来的。 对比请求结果 对比响应状态： 对比响应体（非 json 数据格式）： 对比响应体（json数据格式）： 对比响应头： 数据层测试回滚数据使用 @Transactional 和 @Rollback(true) 注解表示测试用例执行的事务不需要提交。 如果需要提交事务，可以把 @RollBack 注解的回滚状态改为 false。 打包并运行项目Windows 添加 SpringBoot maven 插件 执行 Maven 打包命令 运行项目 选项–-server.port&#x3D;80：指定访问项目的端口。 –spring.config.name&#x3D;文件名：指定 springboot 配置文件名称，默认是 applicaton。 –spring.config.location&#x3D;文件路径：指定配置文件路径。例如 --spring.config.location=classpath:/project-config.yml,D:/project-config.yml。文件的加载顺序为指定的顺序，后加载的配置覆盖先加载的配置。 遇到的问题xxx.jar 中没有主清单属性。 原因是 jar 包下的 META-INF 目录中的 MANIFEST.MF 文件缺少 Main-Class 和 Start-Class属性。 解决方式：将 SpringBoot Maven 插件中的下面内容注释掉，然后重新打包。 去掉后的打包结果，也能够运行 jar 包了。 Linux在 Linux 安装 JDK 环境。 上传 springboot jar 包。 执行 jar 命令：java –jar 工程名.jar Windows 与 Linux 下执行 SpringBoot 打包程序流程相同，仅需确保运行环境有效即可。 监控监控概述监控的意义 监控服务是否可用。 监控服务运行指标（内容、线程、请求等）。 监控服务运行日志。 管理服务（服务下线）。 监控的实施方式 显示监控信息的程序：用于获取其它程序的信息，并显示。 被监控的服务：启动时主动上报，告知监控程序自己需要受到监控。 可视化监控平台监控程序 导入依赖包： 在引导类上添加 @EnableAdminServer 注解： 被监控的服务 导入依赖包： 配置文件： 配置客户端被监控的指标 监控原理通过 &#x2F;actuator 请求，可以获取查询监控信息对于的路径： 例如 health 路径，发起 health 请求可以获取以下用来展示的 json 数据： Actuator 称为端点，描述了一组监控信息。SpringBootAdmin 提供了多个内置端点，以下列出了所有端点信息说明： ID 描述 默认启用 auditevents 暴露当前应用程序的审计事件信息。 是 beans 显示应用程序中所有 Spring bean 的完整列表。 是 caches 暴露可用的缓存。 是 conditions 显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。 是 configprops 显示所有 @ConfigurationProperties 的校对清单。 是 env 暴露 Spring ConfigurableEnvironment 中的属性。 是 flyway 显示已应用的 Flyway 数据库迁移。 是 health 显示应用程序的健康信息，例如 redis 信息。 是 httptrace 显示 HTTP 追踪信息（默认情况下，最后 100 个 HTTP 请求&#x2F;响应交换）。 是 info 显示应用程序的信息，需要自己配置。 是 integrationgraph 显示 Spring Integration 图。 是 loggers 显示和修改应用程序中日志记录器的配置。 是 liquibase 显示已应用的 Liquibase 数据库迁移。 是 metrics 显示当前应用程序的指标度量信息。 是 mappings 显示所有 @RequestMapping 路径的整理清单。 是 scheduledtasks 显示应用程序中的调度任务。 是 sessions 允许从 Spring Session 支持的会话存储中检索和删除用户会话。当使用 Spring Session 的响应式 Web 应用程序支持时不可用。 是 shutdown 正常关闭应用程序。 否 threaddump 执行线程 dump。 是 heapdump 返回一个 hprof 堆 dump 文件。 是 jolokia 通过 HTTP 暴露 JMX bean（当 Jolokia 在 classpath 上时，不适用于 WebFlux）。 是 logfile 返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 HTTP Range 头来检索部分日志文件的内容。 是 prometheus 以可以由 Prometheus 服务器抓取的格式暴露指标。 是 自定义监控指标自定义 INFO 端点配置文件形式： 编程方式： 自定义 Health 端点health 端点描述当前应用的运行健康指标，即应用依赖的组件的运行是否成功。通过编程的形式可以扩展指标信息： 自定义 Metrics 端点metrics 端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标： 自定义端点 热部署热部署：修改了程序，只需要把修改后的程序重新加载一遍，不需要重启服务器。 SpringBoot 热部署原理：提供一个程序 X 监控我们开发的程序 A。如果开发的程序 A 发生了变化，那么程序 X 就通知 Tomcat 容器重新加载程序 A。 重启与重载的概念一个 SpringBoot 项目在运行时是分两个过程进行的，根据加载的东西不同，划分成 base 类加载器与 restart 类加载器。 base 类加载器：用来加载 jar 包中的类，jar 包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化。 restart 类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响。 热部署的过程实际上是重新加载 restart 类加载器中的信息。 导入开发者工具包 使用快捷键 CTRL + F9 手动启动热部署。 自动热部署当 IDEA 工具失去焦点 5 秒后进行热部署&#x2F; 配置热部署监控文件范围只有监控范围内的文件做了修改，才会触发热部署。默认情况下，以下目录中的文件做了修改不会触发热部署： &#x2F;META-INF&#x2F;maven &#x2F;META-INF&#x2F;resources &#x2F;resources &#x2F;static &#x2F;public &#x2F;templates 配置不参与热部署的文件或文件夹： 关闭热部署 跨域请求 全局跨域请求： "},{"title":"【Spring】SSM 整合，全注解方式","date":"2024-03-11T06:00:00.000Z","url":"/blog/2024/03/11/Spring/SSM%E6%95%B4%E5%90%88/","tags":[["Spring","/blog/tags/Spring/"]],"categories":[["undefined",""]],"content":"搭建 Spring 环境 导入依赖包 Spring 容器配置类 搭建 SpringMVC 环境 导入依赖包 添加 webapp 目录 web.xml 配置 创建 SpringMVC 配置类 搭建 MyBatis 环境 版本兼容问题 MyBatis-Spring MyBatis Spring Java 2.0 3.5+ 5.0+ jdk 8+ 1.3 3.4+ 3.2.2+ jdk 6+ 导入依赖包 MyBatis 配置类 搭建过程中遇到的问题无法访问 controller 服务原因1：不管怎么样，都需要 webapp 这个目录，哪怕这个目录的内容为空。 原因2：Controller 层的 Bean 对象需要注册到 SpringMVC 容器中，如果注册到 Spring 容器中是无法被访问的。 HttpMediaTypeNotAcceptableException忘记在 SpringMVC 配置类添加 @EnableWebMvc 注解，导致 SpringMVC 容器缺少必要的组件。 无法启动 Tomcat 服务异常信息：A child container failed during start 原因：Tomcat 有自己的 servlet-api 依赖包，自己添加的 servlet-api 不能打包到 Tomcat 环境中 启动 MyBatis 环境时抛出异常异常全称：Invalid default: public abstract java.lang.Class org.mybatis.spring.annotation.MapperScan.factoryBean() 原因：缺少 spring-jdbc 包 导入 spring-jdb 依赖包 只想在单元测试中执行某个方法，不想启动 Tomcat需要注释掉 SpringMVC 相关的配置类，否则会抛出 No ServletContext set 异常。"},{"title":"【Spring】声明式事务控制","date":"2024-03-11T01:00:00.000Z","url":"/blog/2024/03/11/Spring/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/","tags":[["Spring","/blog/tags/Spring/"]],"categories":[["undefined",""]],"content":"编程式事务控制相关对象PlatformTransactionManagerPlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法： TransactionStatus getTransaction(TransactionDefination defination) ：获取事务的状态信息。 void commit(TransactionStatus status) ：提交事务。 void rollback(TransactionStatus status) ：回滚事务。 注：PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类。例如：Dao 层技术是jdbc 或 mybatis时，实现类为 DataSourceTransactionManager。Dao 层技术是 hibernate时，实现类为 HibernateTransactionManager。 TransactionDefinitionTransactionDefinition 是事务的定义对象，有以下方法： int getIsolationLevel() ：获得事务的隔离级别。 int getPropogationBehavior()：获得事务的传播行为。 int getTimeout() ：获得超时时间。 boolean isReadOnly() ：是否只读。 事务的隔离级别： ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 事务的传播行为： REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 是否只读：建议查询时设置为只读。 TransactionStatusTransactionStatus 接口提供事务具体的运行状态，有以下方法： boolean hasSavepoint() ：是否存储回滚点。 boolean isCompleted() ：事务是否完成。 boolean isNewTransaction() ：是否是新事务。 boolean isRollbackOnly() ：事务是否回滚。 声明式事务处理的作用业务逻辑对象不会意识到正在事务管理之中，如果想要改变事务管理策略的话，也只需要在定义文件中重新配置即可。在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译。 基于 XML 的声明式事务控制 添加 aspectj 依赖： XML 事务配置： 基于注解实现声明式事务 开启事务管理： 向 Spring 容器中添加事务管理器对象： 使用 @Transactional 注解标注事务： "},{"title":"【Mybatis】基本使用","date":"2024-03-10T01:00:00.000Z","url":"/blog/2024/03/10/Mybatis/mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["Mybatis","/blog/tags/Mybatis/"]],"categories":[["undefined",""]],"content":"MyBatis 介绍MyBatis 简介MyBatis 是一款用来操作数据库的框架，支持定制化 SQL 以及将 SQL 与接口方法映射。 入门示例 添加依赖包： sql 语句： 创建 MyBatis 配置文件： 实体类： Mapper 接口： Mapper 配置文件： 测试代码： MyBatis 打印 Sql 日志Log4j 2 添加依赖： resource 目录下新增 log4j2.xml 文件： mybatis-config.xml 添加配置： MyBatis 的配置文件properties 标签 引入 properties 文件，然后可以使用 ${属性名} 的方式访问属性值。 settings 标签 修改 Mybatis 的全局配置： 常见的属性配置： mapUnderscoreToCamelCase：是否将表中字段的下划线自动转换为驼峰，默认为 false。 lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认为 false。 aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载。在 3.4.1 及之前的版本中默认为 true，之后默认为 false。 cacheEnabled：是否开启二级缓存，默认为 true。 logImpl：指定日志接口的实现类，例如：SLF4J、LOG4J、LOG4J2、COMMONS_LOGGING等。 typeAliases 标签 为全限定类名起别名，可以以类为单位，也可以以包为单位： 注：如果设置了别名，后续在 MyBatis 中只能使用别名。 plugins 标签 配置插件，例如配置分页插件： environments 标签 用来配置数据库环境，可以配置多个： mappers 标签 用来告诉 MyBatis 到哪去找到 Sql 语句： Mapper 配置文件增删改查 增： 删： 改： 查询一个实体类对象： 查询集合： 注： 查询标签 select 必须设置 resultType 或 resultMap 的属性值，用于设置实体类和数据库表的映射 关系。 resultType：自动映射，用于属性名和表中字段名一致的情况。 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况。 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常 TooManyResultsException。 获取接口参数值MyBatis 获取参数值的两种方式：${} 和 #{}。${} 的通过字符串拼接实现，#{} 的通过占位符赋值实现。${} 使用字符串拼接的方式拼接 sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号。但是 #{} 使用占位符赋值的方式拼接 sql，若为字符串类型或日期类型的字段进行赋值时，不需要手动加单引号，会自动添加。 单个字面量类型的参数@Param 注解标识参数使用 ${} 和 #{} 以任意的名称获取参数的值，注意 ${} 需要手动加单引号。 多个字面量类型的参数使用 @Param 注解标识参数，MyBatis 会将这些参数放在 map 集合中，以 @Param 注解的 value 属性值为键，以参数为值，通过 ${} 和 #{} 访问 map 集合的键就可以获取相对应的值，注意 ${} 需要手动加单引号。 map 集合类型的参数通过 ${} 和 #{} 访问 map 集合的键就可以获取相对应的值，注意 ${} 需要手动加单引号。 实体类类型的参数通过 ${} 和 #{} 访问实体类对象中的属性名获取属性值，注意 ${} 需要手动加单引号 处理特殊 SQL模糊查询 3 种模糊查询： 动态设置表名 动态设置表名： 添加时获取自增的主键 新增数据时获取自增的主键： 自定义映射 resultMap字段和属性的映射关系 sql 字段和 JavaBean 属性名不一致，可以通过 resultMap 设置自定义映射： 多对一映射处理例如：查询员工信息以及员工对应的部门信息。可以把员工和员工对应的部门信息一起查出来，也可以分步查询。 级联映射关系示例： 使用 association 标签处理多对一关系： 分布查询： 注：可以通过 association 标签中的 fetchType 属性设置当前的分步查询是否使用延迟加载， fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”。 一对多映射处理例如：查询部门以及部门下的员工信息。 使用 collection 标签处理一对多关系： 分步查询： 注：可以通过 collection 标签中的 fetchType 属性设置当前的分步查询是否使用延迟加载， fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”。 动态拼装 SQL动态 SQL 是一种根据条件动态拼装 SQL 的功能。 ifif 标签通过 test 属性的表达式进行判断，若表达式的结果为 true，则拼装 if 标签中的内容。 if 示例： wherewhere 一般和 if 结合使用： 若 where 标签中的 if 条件都不满足，不会添加where关键字。 若 where 标签中的有 if 条件满足，则 where 标签会自动添加where关键字，并将条件最前方多余的 and 去掉。 where 示例： trimtrim 用于处理标签的前后内容，常用属性： prefix：在 trim 标签中的内容的前面添加指定内容。 prefixOverrides：在 trim 标签中的内容的前面去掉指定内容。 suffix：在 trim 标签中的内容的后面添加指定内容。 suffixOverrides：在 trim 标签中的内容的后面去掉指定内容。 trim 标签的使用示例： choose、when、otherwisechoose、when、otherwise 相当于 if…else if..else。 使用示例： foreachforeach 用来循环遍历集合。有以下属性： collection：设置要循环的数组或集合。 item：表示集合或数组中的每一个数据。 separator：设置循环体之间的分隔符。 open：设置 foreach 标签中的内容的开始符。 close：设置 foreach 标签中的内容的结束符。 foreach 示例： SQL 片段sql 片段用于存储一段共享 sql 片段，在使用的地方通过 include 标签进行引入。 sql 片段使用示例： MyBatis 缓存一级缓存一级缓存是 SqlSession 级别的，通过同一个 SqlSession 查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问。 一级缓存失效的四种情况： 不同的 SqlSession 对应不同的一级缓存。 同一个 SqlSession 但是查询条件不同。 同一个 SqlSession 两次查询期间执行了任何一次增删改操作。 同一个 SqlSession 两次查询期间手动清空了缓存。 使用一级缓存示例： 执行结果，两次查询但只打印了一条查询 sql 日志 ： DEBUG [main] - &#x3D;&#x3D;&gt; Preparing: select * from user where id &#x3D; ?DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(Integer)DEBUG [main] - &lt;&#x3D;&#x3D; Total: 1User(id&#x3D;1, name&#x3D;lin, email&#x3D;lin@qq.com, birthdate&#x3D;2000-01-01)User(id&#x3D;1, name&#x3D;lin, email&#x3D;lin@qq.com, birthdate&#x3D;2000-01-01) 清空一级缓存数据示例： 执行结果，两次查询打印了两条查询 sql 日志： DEBUG [main] - &#x3D;&#x3D;&gt; Preparing: select * from user where id &#x3D; ?DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(Integer)DEBUG [main] - &lt;&#x3D;&#x3D; Total: 1User(id&#x3D;1, name&#x3D;lin, email&#x3D;lin@qq.com, birthdate&#x3D;2000-01-01)DEBUG [main] - &#x3D;&#x3D;&gt; Preparing: insert into user values(null, ?, ?, ?)DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: tony(String), tony@qq.com(String), 2024-03-14(LocalDate)DEBUG [main] - &lt;&#x3D;&#x3D; Updates: 1DEBUG [main] - &#x3D;&#x3D;&gt; Preparing: select * from user where id &#x3D; ?DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(Integer)DEBUG [main] - &lt;&#x3D;&#x3D; Total: 1User(id&#x3D;1, name&#x3D;lin, email&#x3D;lin@qq.com, birthdate&#x3D;2000-01-01) 二级缓存二级缓存是 SqlSessionFactory 级别，通过同一个 SqlSessionFactory 创建的 SqlSession 查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取。 二级缓存开启条件： 在 MyBatis 配置文件中，在 settings 标签设置属性 cacheEnabled&#x3D;”true”，默认为 true。 在映射文件中设置标签 &lt;cache &#x2F;&gt;。 二级缓存必须在 SqlSession 关闭或提交之后有效。 查询的数据所转换的实体类必须实现序列化的接口。 二级缓存失效的情况： 两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效。 二级缓存示例： 开启二级缓存配置： mapper.xml 添加 &lt;cache&#x2F;&gt; 标签： 实体类实现 Serializable 接口，不实现会报错： 测试代码： 测试结果，两个会话中分别查询只打印一条查询 sql 日志： DEBUG [main] - &#x3D;&#x3D;&gt; Preparing: select * from user where id &#x3D; ?DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(Integer)DEBUG [main] - &lt;&#x3D;&#x3D; Total: 1User(id&#x3D;1, name&#x3D;lin, email&#x3D;lin@qq.com, birthdate&#x3D;2000-01-01)DEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1b955cac]DEBUG [main] - Returned connection 462773420 to pool.DEBUG [main] - Cache Hit Ratio [blog.lin.mapper.UserMapper]: 0.5User(id&#x3D;1, name&#x3D;lin, email&#x3D;lin@qq.com, birthdate&#x3D;2000-01-01) 二级缓存的相关配置cache 标签常用属性设置： eviction 属性：缓存回收策略。LRU（最近最少使用的）、FIFO（先进先出）。默认的是 LRU。 flushInterval 属性：刷新间隔，单位毫秒。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。 size 属性：缓存的数量，正整数。代表缓存最多可以存储多少个对象，太大容易导致内存溢出。 readOnly 属性：只读，true&#x2F;false。因此默认为 false。 true：只读缓存。会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。 false：读写缓存。会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全。 缓存查询的顺序 先查询二级缓存。 如果二级缓存没有命中，再查询一级缓存。 如果一级缓存也没有命中，则查询数据库。 SqlSession 关闭之后，一级缓存中的数据会写入二级缓存。 逆向工程正向工程：先创建 Java 实体类，由框架根据实体类生成数据库表。Hibernate 是支持正向工程 的。 逆向工程：先创建数据库表，由框架根据数据库表，生成 Java 实体类、Mapper 接口、Mapper 映射文件。 逆向工程示例： 导入插件和依赖包： generatorConfig.xml 配置文件： pagehelper 分页插件配置分页插件 添加依赖包： 在 Mybatis 的配置文件中配置分页插件： 使用方式在调用查询接口前使用 PageHelper.startPage(pageNum, pageSize) 开启分页功能，然后会返回一个 Page 对象，Page 对象包含一些分页信息。 使用示例： 执行结果： User(id&#x3D;5, name&#x3D;tony, email&#x3D;tony@qq.com, birthdate&#x3D;2024-03-14)User(id&#x3D;6, name&#x3D;tony, email&#x3D;tony@qq.com, birthdate&#x3D;2024-03-14)Page{count&#x3D;true, pageNum&#x3D;3, pageSize&#x3D;2, startRow&#x3D;4, endRow&#x3D;6, total&#x3D;10, pages&#x3D;5, reasonable&#x3D;false, pageSizeZero&#x3D;false}[User(id&#x3D;5, name&#x3D;tony, email&#x3D;tony@qq.com, birthdate&#x3D;2024-03-14), User(id&#x3D;6, name&#x3D;tony, email&#x3D;tony@qq.com, birthdate&#x3D;2024-03-14)] Page 对象常用的属性 pageNum：当前页的页码。 pageSize：每页显示的条数。 size：当前页显示的真实条数。 total：总记录数。 pages：总页数。 prePage：上一页的页码。 nextPage：下一页的页码。 isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页。 hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页。 navigatePages：导航分页的页码数。 navigatepageNums：导航分页的页码，[1,2,3,4,5]。 "},{"title":"【Spring】SpringMVC","date":"2024-03-07T01:00:00.000Z","url":"/blog/2024/03/07/Spring/SpringMVC/","tags":[["Spring","/blog/tags/Spring/"]],"categories":[["undefined",""]],"content":"SpringMVC 简介SpringMVC 概述SpringMVC 是一个基于 Spring 开发的 MVC 框架，使用 DispatcherServlet 作为前端控制器，且内部提供了处理器映射器、处理器适配器、视图解析器等组件，可以简化 JavaBean 封装，Json 转化、文件上传等操作。 SpringMVC 入门示例 SpringMVC 的依赖包 web.xml 配置内容： spring-mvc.xml 配置内容： spring.xml 配置内容： controller 层代码： SpringMVC 的请求处理请求路径映射服务的配置 注解 作用 使用位置 @RequestMapping 设置控制器方法的访问资源路径，可以接收任何请求 方法和类上 @GetMapping 设置控制器方法的访问资源路径，可以接收GET请求 方法和类上 @PostMapping 设置控制器方法的访问资源路径，可以接收POST请求 方法和类上 注：@RequestMapping 、@GetMapping、@PostMapping 等注解可以在 Controller 类上标注。在类上用 @RequestMapping 标注后，该类的所有方法都公用 @RequestMapping 设置的属性，访问路径则为类上的映射 地址 + 方法上的映射地址。 接收请求参数接收 query 数据 传参名与接收参数名对应： 传参名与接收参数名不对应，使用 @RequestParam 注解： 用数组接收参数： 用集合接收参数，需要使用 @RequestParam 注解： 接收 JavaBean 属性，传参名只要与 JavaBean 的属性名一致，就可以自动封装： 输出结果： User(id&#x3D;1001, name&#x3D;lin, age&#x3D;18, hobbies&#x3D;[美食, 逛街], address&#x3D;Address(city&#x3D;广州, area&#x3D;天河区)) 注：JavaBean 不能使用 @RequestParam 注解，所以属性不能用别名，也不能用集合接收参数。 接收 Json 数据 添加 MappingJackson2HttpMessageConverter 转换器： 导入 jackson 依赖包，MappingJackson2HttpMessageConverter 转换器依赖 jackson 包： 传递 json 数据： controler 层。接收 Json 数据，需要使用 @RequestBody 标注： 执行结果： User(id&#x3D;1001, name&#x3D;lin, age&#x3D;18, hobbies&#x3D;[美食, 逛街], address&#x3D;Address(city&#x3D;广州, area&#x3D;天河区)) 接收 Restful 风格的数据 接收 Restful 风格的数据，需要使用 @PathVariable 注解： 接收文件数据文件上传的表单需要满足以下条件： 表单的提交方式为 POST。 表单的 enctype 属性值为 multipart&#x2F;form-data。 文件上传项需要有 name 属性。 添加文件上传解析器，id 固定为 multipartResolver： 添加依赖包。CommonsMultipartResolver 依赖 Common-fileuplad 等工具的 API 进行文件上传： controller 层代码： 接收请求头数据 接收请求头数据，需要使用 @RequestHeader 注解： 接收所有请求头数据： 接收 Cookie 数据 接收 Cookie 数据，需要使用 @CookieValue 注解： 获得转发 Request 域中数据 获得转发 Request 域中数据，需要使用 @RequestAttribute 注解： 请求参数乱码问题 使用 Spring 提供的 CharacterEncodingFilter 过滤器处理编码转换问题： 获取 JavaWeb 原生对象 只需要将对象以形参的形式写在方法上，SpringMVC 框架在调用 Controller 方法时，会自动传递实参： 请求静态资源失败的问题请求静态资源失败的原因 当 DispatcherServlet 的映射路径配置为 / 时，请求静态资源会失败的原因： 因为在 Tomcat 的 config 目录下有一个 web.xml，是对所有的 web 项目的全局配置，有以下配置： DefaultServlet 的作用是，当请求资源路径没有匹配的 Servlet 时，就使用 DefaultServlet 服务，而 DefaultServlet 具备二次去匹配静态资源的功能。但是因为 DispatcherServlet 的映射路径配置为 / ，请求静态资源时会使用 DispatcherServlet 服务，不会使用 DefaultServlet 服务，而 DispatcherServlet 服务会将请求的静态资源的名称当成 Controller 的映射路径去匹配，即静态资源访问不成功了。 3 种解决方法 在项目的 web.xml 中新增 DefaultServlet 服务的映射路径，使请求静态资源时使用的是 DefaultServlet 服务： 在 spring-mvc.xml 中去配置静态资源映射，匹配映射路径的请求到指定的位置去匹配资源： 在 spring-mvc.xml 中去配置 &lt;mvc:default-servlet-handler&gt;，该方式是注册了一个 DefaultServletHttpRequestHandler 处理器，静态资源的访问都由该处理器去处理： 第二种和第三种可以正常访问静态资源，但是 Controller 又无法访问了。因为第二和第三种方案会在 SpringMVC 容器中添加 SimpleUrlHandlerMapping 映射器，导致 DispatcherServlet 初始化的时候不会再加载默认的处理器 RequestMappingHandlerMapping 了。解决方法是将 RequestMappingHandlerMapping 也注册到 SpringMVC 容器中。这样 DispatcherServlet 在进行初始化时，就会从容器中同时获得 RequestMappingHandlerMapping 对象，然后存储到 DispatcherServlet 中名为 handlerMappings 的 List 集合中，对 @RequestMapping 注解进行解析。 请求配置总结要想使用 @RequestMapping 正常映射到资源方法，同时静态资源还能正常访问，还可以将请求的 json 格式字符串和 JavaBean 之间自由转换，就需要在 spring-mvc.xml 中完成以下配置： 可以简化成： &lt;mvc:annotation-driven&gt; 标签会帮我们在 SpringMVC 容器中注册 RequestMappingHandlerMapping 映射器，注册 RequestMappingHandlerAdapter 适配器，并在适配器中注入 JSON 转换器等。 SpringMVC 的响应处理请求转发与重定向请求转发 请求重定向 响应模型数据 直接返回数据SpringMVC 默认的方法返回值是视图，可以通过 @ResponseBody 注解显示的告知该方法的返回值不要进行视图处理，是要以响应体的方式处理的。 可以将 @ResponseBody 写到 Controller 上，那么该 Controller 中的所有方法都具备了返回响应体数据的功能了。进一步优化，@RestController内部具备的 @Controller 和 @ResponseBody 这两个注解的功能。 SpringMVC 的拦截器拦截器 Interceptor 简介SpringMVC 的拦截器 Interceptor 规范，主要是对 Controller 资源访问时进行拦截操作的技术。拦截后可以进行权限控制等功能。SpringMVC 的拦截器跟 Filter 的区别如下图： 拦截器接口拦截器接口方法 preHandle：对拦截到的请求进行处理，处理结果为 true 放行执行处理器方法，false 不放行，且所有后置方法都不执行。handler 参数是拦截到的 Controller 方法处理器。 postHandle：在处理器的方法执行完成后，对拦截到的请求进行处理。handler 参数是拦截到的 Controller 方法处理器，modelAndView 参数是返回的模型视图对象。 afterCompletion：视图渲染完成后（整个流程结束之后），进行最后的处理，如果请求流程中有异常，可以处理异常对象。handler 参数是拦截到的 Controller 方法处理器，ex 参数是异常对象。 拦截器示例 导入拦截器依赖包： 编写拦截器： 配置拦截器： 拦截器执行顺序拦截器的执行顺序取决于 interceptor 的配置顺序： 如果拦截器都放行的执行顺序： 拦截器部分放行的执行顺序： SpringMVC 全注解开发spring-mvc.xml 注解开发文件上传解析器 处理静态资源路径在 SpringMvc 配置类添加 @EnableWebMvc 注解，并重写 WebMvcConfigurer 接口中的 configureDefaultServletHandling 方法。@EnableWebMvc 具有 &lt;mvc:annotation-driven&#x2F;&gt; 标签的作用 ，会帮我们在 SpringMVC 容器中注册 RequestMappingHandlerMapping 映射器，注册 RequestMappingHandlerAdapter 适配器，并在适配器中注入 JSON 转换器等。 添加拦截器在 SpringMvc 配置类添加 @EnableWebMvc 注解，并重写 WebMvcConfigurer 接口中的 addInterceptors 方法。拦截器的执行顺序取决于添加顺序。 web.xml 加载 SpringMVC 配置类定义了一个 AnnotationConfigWebApplicationContext 父类，在 web.xml 配置 SpringMVC 的配置类： 消除 web.xml首先了解 ServletContainerInitializer 接口内容 实现类实现了 ServletContainerInitializer 接口后，在类加载路径的 META-INF&#x2F;services 目录创建一个名为 javax.servlet.ServletContainerInitializer 的文件，文件内容是 ServletContainerInitializer 的实现类的全限定类名。当 web 容器启动时就会执行这个实现类的 onStartup 方法。 onStartup 方法中有个集合参数 c，集合中的数据都是被注解 @HandlesTypes() 指定的类的所有父类或实现类。如果没有匹配项，则返回 null。 Spring 定义了一个 SpringServletContainerInitializer 实现了 ServletContainerInitializer 接口，并进行了相关配置，所以 SpringServletContainerInitializer 会在 web 容器启动时获取 AbstractAnnotationConfigDispatcherServletInitializer 的父类对象。通过该父类对象我们可以配置 web.xml 相关的内容。 示例： SpringMVC 的异常处理机制异常处理流程SpringMVC 处理异常的思路：一路向上抛异常，最终抛给前端控制器 DispatcherServlet ，DispatcherServlet 再调用异常处理器 ExceptionResolver 进行处理，如下图： 实现方式 简单异常处理器：使用 SpringMVC 内置的异常处理器处理 SimpleMappingExceptionResolver。 自定义异常处理器：实现 HandlerExceptionResolver 接口，自定义异常进行处理。 注解方式：使用 @ControllerAdvice + @ExceptionHandler 定义异常处理器。 SimpleMappingExceptionResolver 示例： HandlerExceptionResolver 示例： 注：要让 SpringMVC 配置类扫描到该类 @ControllerAdvice + @ExceptionHandler 配置异常示例： 如果全局异常处理器响应的数据都是 Json 格式的字符串，可以使用 @RestControllerAdvice 替代 @ControllerAdvice 和 @ResponseBody。 注：要让 SpringMVC 配置类扫描到该类。 常用的异常解析器 HandlerExceptionResolver：异常处理器类的顶级接口，实现了该接口的类都会作为异常处理器类。 MyHandlerExceptionResolver：自定义的处理器类，实现了HandlerExceptionResolver接口。 HandlerExceptionResolverComposite：异常解析器混合器，内部存在集合存储多种异常解析器。 SimpleMappingExceptionResolver：简单映射异常处理器，可以配置异常与对应的错误视图。 ExceptionHandlerExceptionResolver：异常解析器，默认会被注册到 Spring 容器中。该解析器用来解析 @ExceptionHandler 方式的异常处理。 DefaultHandlerExceptionResolver：默认处理器异常解析器，所有异常处理器都不匹配时，最后执行的异常处理器。 ResponseStatusExceptionResolver：响应状态异常解析器，结合使用 @ResponseStatus 标注的异常使用。 SpringMVC 的原理剖析 Servlet 的生命周期： 创建 Servlet 对象。 执行 init(config) 方法，初始化 Servlet 对象。 执行 service(req, resp) 方法，Servlet 对象对外提供服务。 销毁 Servlet 对象。 DispatcherServlet 初始化过程SpringMVC 的前端控制器 DispatcherServlet 作为 Servlet 的子类，在初始化过程主要做两件事： 初始化 Spring 容器和 SpringMVC 容器，并把 Spring 容器作为父容器。 注册 SpringMVC 九大组件。 初始化容器的过程Servlet 被子类层层封装，通过模板设计模式封装了必要的初始化步骤，并对外暴露部分方法让子类参与到初始化的步骤中。最终初始化容器的核心过程在 FrameworkServlet 类中的 initServletBean() 方法完成。 Spring 容器初始化过程：ContextLoaderListener 监听器的作用就是启动 Web 容器时，自动装配 ApplicationContext 的配置信息。因为它实现了 ServletContextListener 这个接口，在 web.xml 配置了这个监听器。启动容器时，就会默认执行它实现的 contextInitialized() 方法初始化 WebApplicationContext 实例，并放入到 ServletContext中 。 在 initServletBean() 方法中，设计了一个计时器来统计初始化的执行时间，还提供了一个 initFrameworkServlet() 用于子类的覆盖操作，而关键的初始化逻辑在 initWebApplicationContext() 方法。 initWebApplicationContext() 方法主要用于创建或刷新 WebApplicationContext 实例，并对 Servlet 功能所使用的变量进行初始化。 注册 SpringMVC 九大组件当 SpringMVC 容器初始化完成后，会在 finishRefresh() 方法中发布一个事件，该事件由 FrameworkServlet 父类定义的内部类监听器 ContextRefreshListener 接收，并执行 onApplicationEvent(event) 方法。最终会调用 DispatcherServlet 类中的 initStrategies(context) 方法注册 SpringMVC 的九大组件。 以注册映射器方法 initHandlerMappings(context) 为例，注册逻辑大致为，如果 SpringMVC 容器有映射器对象，那么就从 SpringMVC 容器中获取映射器，如果没有，那么就根据 DispatcherServlet.properties 配置文件，加载默认的注册器。 DispatcherServlet.properties 文件内容： DispatcherServlet 服务过程执行 DispatcherServlet 的父类 Servlet 中的 init(config) 方法，核心的服务过程最终由 DispatcherServlet 类中的 doDispatch(req, resp) 方法完成。 执行流程图： "},{"title":"【JavaWeb】核心功能","date":"2024-03-06T01:00:00.000Z","url":"/blog/2024/03/06/JavaWeb/JavaWeb/","tags":[["JavaWeb","/blog/tags/JavaWeb/"]],"categories":[["undefined",""]],"content":"Tomcat 服务器Tomcat 安装Tomcat 官方网站下载 JavaEE 版本和 Servlet 版本号对应关系 Servlet Version EE Version 6.1 Jakarta EE ? 6.0 Jakarta EE 10 5.0 Jakarta EE 9&#x2F;9.1 4.0 JAVA EE 8 3.1 JAVA EE 7 3.1 JAVA EE 7 3.0 JAVAEE 6 Tomcat 版本和 Servlet 版本之间的对应关系 Servlet Version **Tomcat ** Version JDK Version 6.1 11.0.x 17 and later 6.0 10.1.x 11 and later 5.0 10.0.x (superseded) 8 and later 4.0 9.0.x 8 and later 3.1 8.5.x 7 and later 3.1 8.0.x (superseded) 7 and later 3.0 7.0.x (archived) 6 and later (7 and later for WebSocket) Tomcat 日志中文乱码问题修改 conf&#x2F;logging.properties 文件，将所有的 UTF-8 修改为 GBK。 Tomcat 目录结构bin：该目录下存放的是二进制可执行文件。 如果是安装版，那么这个目录下会有两个 exe 文件：tomcat10.exe、tomcat10w.exe。前者是在控制台下启动 Tomcat，后者是弹出 GUI 窗口启动 Tomcat。 如果是解压版，那么会有 startup.bat 和 shutdown.bat 文件。startup.bat 用来启动 Tomcat，但需要先配置 JAVA_HOME 环境变量才能启动。shutdawn.bat 用来停止 Tomcat。 conf：Tomcat 的配置文件，有四个非常重要的文件： server.xml：配置整个服务器信息，例如端口号。 tomcat-users.xml：存储 Tomcat 用户的文件，这里保存的是 Tomcat 的用户名及密码，以及用户的角色信息。 web.xml：部署描述符文件。这个文件中注册了很多 MIME 类型，即文档类型。这些 MIME 类型是客户端与服务器之间说明文档类型的。 context.xml：对所有应用的统一配置，通常不会去配置它。 lib：Tomcat的类库。 logs：日志文件，记录了 Tomcat 启动和关闭的日志。 temp：存放 Tomcat 的临时文件，这个目录下的东西可以在停止 Tomcat 后删除。 webapps：存放 web 项目的目录，其中每个文件夹都是一个项目。 work：运行时生成的文件，最终运行的文件都在这里。可以把这个目录下的内容删除，再次运行时会生再次生成 work 目录。 LICENSE：许可证。 NOTICE：说明文件。 Web 项目的标准结构 app 应用的根目录： static：非必要的目录，用来存放静态资源，例如：css、js、img 等。 WEB-INF：必要的目录，用来存放受保护的资源。浏览器通过 url 不可以直接访问的目录。 classes：必要的目录，用来存放被编译后的 .class 文件和配置文件。 lib：必要的目录，用来存放项目依赖的 jar 包。 web.xml：必要的文件，web 项目的基本配置文件。 index.html：非必要的文件，默认的欢迎页。 Web 项目部署的方式 将编译好的项目打成 war 包，然后放到 webapps 目录下，Tomcat 启动后会自动解压 war 包。 将编译好的项目放在 webapps 目录下。 Servlet Servlet 依赖包： Servlet 介绍Servlet 是运行在服务端的 Java 程序，是 sun 公司定义的一套获取动态资源规范。作用： 用来接收、处理客户端请求以及返回响应数据的程序。 Servlet 是运行在服务端的，所以 Servlet 需要在 Web 项目中开发且在类似 Tomcat 服务容中运行。 入门示例 入门示例： 定义一个类，继承 HttpServlet。 重写 service 方法，用于处理用户请求。 HttpServletRequest 为请求对象，HttpServletResponse 为响应对象，由 Tomcat 负责转换。 Servlet 对象的生命周期：创建、初始化、处理服务、销毁，由 Tomcat 管理。 web.xml 中的配置： @WebServlet 替代 web.xml 配置 Servlet 的生命周期 生命周期 对应方法 执行时机 构造对象 构造器 第一次请求或者容器启动 初始化 init() 构造完毕后 处理服务 service(req, resp) 每次请求 销毁 destory() 容器关闭 Filter 过滤器入门示例 Servlet 服务： Filter 过滤器： web.xml 配置： 执行结果： filter beforeuser service running…filter after @WebFilter 替代 web.xml 配置 过滤器生命周期 阶段 对应方法 执行时机 创建对象 构造器 web 应用启动时 初始化方法 void init(FilterConfig filterConfig) 构造完毕 过滤请求 void doFilter(req, resq, FilterChain filterChain) 每次请求 销毁 default void destroy() web 应用关闭时 监听器监听器：是一个对域对象身上发生的事件或状态改变进行监听以及进行相应处理的对象。"},{"title":"【Spring】AOP 部分","date":"2024-03-05T01:00:00.000Z","url":"/blog/2024/03/05/Spring/AOP%E9%83%A8%E5%88%86/","tags":[["Spring","/blog/tags/Spring/"]],"categories":[["undefined",""]],"content":"AOP 相关概念 概念 单词 描述 目标对象 Target 被增强的方法所在的对象 代理对象 Proxy 对目标对象进行增强后的对象，客户端实际调用的对象 连接点 Joinpoint 目标对象中可以被增强的方法 切入点 Pointcut 目标对象中实际被增强的方法 通知 Advice 增强部分的代码逻辑 切面 Aspect 增强和切入点的组合 织入 Weaving 将通知和切入点组合动态组合的过程 AOP 离不开以下五个因素： 要被增强的对象，需要被 Spring 管理。 被增强的方法。 包含增强方法的对象，需要被 Spring 管理。 增强方法。 被增强方法和增强方法的位置关系说明。 基于 XML 配置的 AOP主要配置内容 配置哪些包、哪些类、哪些方法需要被增强。 配置目标方法要被哪些通知方法增强，以及在哪个位置增强。 Spring AOP 的依赖包： 注：注意 aop 依赖包跟 Spring 版本的兼容问题。 入门实例： XML 配置详情切点表达式的配置方式 直接将切点表达式配置在通知上： 将切点表达式抽取到外面，在通知上进行引用： 切点表达式语法 execution 表达式： 语法：execution([访问修饰符]返回值类型 包名.类名.方法名(参数)) 作用：匹配方法、类、包。 说明： 访问修饰符可以省略不写。 返回值类型、某一级包名、类名、方法名，都可以使用 * 表示任意。 包名与类名之间使用单点 . 表示该包下的类，使用双点 .. 表示该包及其子包下的类。 参数列表可以使用两个点 .. 表示任意参数。 示例： within 表达式： 语法：within(declaring-type) 作用：匹配指定类的任意方法，不能匹配接口。 示例： @within 表达式： 作用：匹配被指定注解标注的类的方法，但在接口上使用注解不匹配。 示例： @target 表达式： 作用：匹配被指定注解标注的对象的方法，在接口上使用注解不匹配。 示例： @annotation 表达式： 作用：匹配被指定注解标注的方法，在接口方法上使用注解不匹配。 示例： 通知的位置 通知名称 配置方法 执行时机 前置通知 &lt;aop:before&gt; 目标方法执行之前执行 后置通知 &lt;aop:after-returning&gt; 目标方法执行之后执行目标方法异常时，不再执行 异常通知 &lt;aop:after-throwing&gt; 目标方法抛出异常时执行 最终通知 &lt;aop:after&gt; 不管目标方法是否有异常，最终都会执行 环绕通知 &lt;aop:around&gt; 目标方法执行前后执行目标方法异常时，环绕后方法不在执行 通知位置示例： 环绕通知示例： 通知方法参数 参数类型 作用 JoinPoint 连接点对象，任何通知都可使用。可以获得当前目标对象、目标方法参数等信息。 ProceedingJoinPoint JoinPoint 子类对象。主要是在环绕通知中执行 proceed()，进而执行目标方法。 Throwable 异常对象，使用在异常通知中。需要在配置文件中指出异常对象名称。 JoinPoint 对象的使用： 方法名 功能 Signature getSignature(); 通过该对象中可以获取到目标方法名，所属类的 Class 等信息 Object[] getArgs(); 获取传入目标方法的参数对象 Object getTarget(); 获取被代理的对象 Object getThis(); 获取代理对象 ProceedingJoinPoint 使用实例： 执行结果： 异常通知示例： 执行结果： 基于 advisor 标签实现通知一个通知类实现前置通知、后置通知等接口后，再在 advisor 标签中配置通知。 基于 advisor 标签实现通知示例： 基于注解配置的 AOP开启 AOP 注解解析 通知类型 环绕通知示例： 异常通知示例： 执行结果： 抽取切点表达式使用一个空方法，将切点表达式标注在空方法上，通过**方法名()或类名.方法名()**的方式引用切点。 类调用自己方法的情况 类调用自己的方法： 切点通知： 测试 doSomething1 方法： 执行结果： do some important things before… CustomerServiceImpl.doSomething1() CustomerServiceImpl.doSomething2() 存在的问题： 通过 doSomething1 方法调用 doSomething2 方法时，doSomething2 没有前置通知。如果单独调用 doSomething2 方法，有前置通知。 解决方法： 修改类，不要出现“自调用”的情况（推荐）。 如果一定要“自调用”，把 this.doSomething2() 修改为 ((CustomerService) AopContext.currentProxy()).doSomething2()。并且开启 AOP 功能时，注解要添加以下配置： 动态代理的实现方式JDK 动态代理技术目标类有接口，是基于接口动态生成实现类的代理对象。目标类有接口的情况下，默认方式。 Cglib 动态代理技术目标类无接口且不能使用 final 修饰，是基于被代理对象动态生成子对象为代理对象。目标类无接口时，默认使用该方式；目标类有接口时，手动配置 &lt;aop:config proxy-target-class=“true”&gt; 强制使用 Cglib 方式。"},{"title":"【Spring】IOC 部分","date":"2024-03-03T01:00:00.000Z","url":"/blog/2024/03/03/Spring/IOC%E9%83%A8%E5%88%86/","tags":[["Spring","/blog/tags/Spring/"]],"categories":[["undefined",""]],"content":"IOC、DI 和 AOP 思想IOC 思想IOC 思想：控制反转。由原来手动创建对象，改为由第三方创建对象。 优点：一个接口的实现类，如果每次获取该实现类的对象都是手动创建出来的，将来该接口有了新的实现类，并且希望新实现类的对象替换所有旧实现类的对象，不好调整。但如果旧实现类的对象都是第三方创建的，例如 IOC 容器，只需要调整一些配置就能够完成。 DI 思想DI 思想：依赖注入。对象的属性由第三方容器来赋值，不需要程序员手动给对象的属性赋值。 AOP 思想AOP 思想：面向切面编程。OOP 面向对象编程是对对象的属性和方法进行抽象，根据业务的需要可以通过添加方法，以完善实体的整体功能。AOP 面向切面编程用于扩展对象已实现的方法，使已有的方法的功能更强大。 Spring 框架Sprng 框架介绍Spring 是一款实现了 IOC、DI、AOP 思想的框架。 Data Access：数据访问。 Data Integration：数据集成。 Web：Web 开发。 AOP：面向切面编程。 Aspects：AOP 思路实现。 Core Container：核心容器。 Test：单元测试与集成测试。 Spring 依赖包 基于 xml 的 Bean 配置在 Spring 开发中主要是要从 Spring 容器中获取对象，所以首先要为 Spring 容器添加各种各样的对象： XML 配置方式 功能描述 &lt;bean id&#x3D;”” class&#x3D;””&gt; Bean 的 id 和全限定名配置 &lt;bean name&#x3D;””&gt; 通过 name 设置 Bean 的别名，通过别名也能直接获取到 Bean 实例 &lt;bean scope&#x3D;””&gt; Bean 的作用范围，BeanFactory 作为容器时取值 singleton 和 prototype &lt;bean lazy-init&#x3D;””&gt; Bean 的实例化时机，是否延迟加载。BeanFactory 作为容器时无效 &lt;bean init-method&#x3D;””&gt; Bean 实例化后自动执行的初始化方法，method 指定方法名 &lt;bean destroy-method&#x3D;””&gt; Bean 实例销毁前的方法，method 指定方法名 &lt;bean autowire&#x3D;”byType”&gt; 设置自动注入模式，常用的有按照类型 byType，按照名字 byName &lt;bean factory-bean&#x3D;”” factory-method&#x3D;””&#x2F;&gt; 指定哪个工厂 Bean 的哪个方法完成 Bean 的创建 Bean 的范围 singleton：单例，默认值。Spring 容器创建的时候，就会进行 Bean 的实例化，并存储到容器内部的单例池中，每次 getBean 都是从单例池中获取相同的 Bean 实例； prototype：原型。Spring 容器初始化时不会创建 Bean 实例，当调用 getBean 时才会实例化 Bean，每次 getBean 都会创建一个新的 Bean 实例。 Bean 的延迟加载当 lazy-init 设置为 true 时为延迟加载，也就是当 Spring 容器创建的时候，不会立即创建 Bean 实例，等用到时再创建 Bean 实例并存储到单例池中去，后续再使用该 Bean 直接从单例池获取即可。 Bean 的初始化和销毁方法Bean 在被实例化后，可以执行指定的初始化方法完成一些初始化的操作，Bean 在销毁之前也可以执行指定的销毁方法完成一些操作，初始化方法名称和销毁方法名称通过 init-method 和 destroy-method 配置。除此之外，还可以通过实现 InitializingBean 接口，完成一些 Bean 的初始化操作。 示例： Bean 的实例化构造方式实例化 Bean：通过构造方法对 Bean 进行实例化。 示例： 工厂方式实例化 Bean：通过调用自定义的工厂方法对 Bean 进行实例化。 静态工厂实例化 Bean： 实例工厂实例化 Bean： FactoryBean 接口实现工厂类，实例化 Bean： 注：FactoryBean 接口实现工厂类，工厂类生成的 Bean 不会立刻加入到 Spring 容器中，需要用到的时候才会加入到 Spring 容器中。 Bean 的属性配置 注入方式 配置方式 通过 Bean 的 set 方法注入 &lt;property name&#x3D;”userDao” ref&#x3D;”userDao”&#x2F;&gt;&lt;property name&#x3D;”userDao” value&#x3D;”haohao”&#x2F;&gt; 通过构造 Bean 的方法注入 &lt;constructor-arg name&#x3D;”name” ref&#x3D;”userDao”&#x2F;&gt;&lt;constructor-arg name&#x3D;”name” value&#x3D;”haohao”&#x2F;&gt; 自动装配方式 &lt;bean id&#x3D;”userService” class&#x3D;”com.service.impl.UserServiceImpl” autowire&#x3D;”byType”&gt; 注：ref 用于引用其他 Bean 的 id，value 用于注入普通属性值。 Spring 的其他配置标签&lt;import&gt; 标签：用于导入其他配置文件。 &lt;alias&gt; 标签：为某个 Bean 添加别名，与在 &lt;bean&gt; 标签上使用 name 属性添加别名的方式一样。 基于注解的 Bean 配置配置注解扫描路径 base-packages 属性：Spring 会扫描指定的包以及子孙包下的所有类。 use-default-filters 属性：默认为 true，会将被 @Component、@Repository、@Service、@Controller 等注解标注的类实例化到 Spring 容器中。如果设置为 false，即使类被注解标注，也不会实例化到容器中。 context:include-filter 标签：只将被指定注解标注的类添加到 Spring 容器中，需要把 use-default-filters 设置为 false。 context:exclude-filter 标签：忽略被指定注解标准的类，不添加到 Spring 容器中。 Bean 的基本注解@Component对应 &lt;bean id&#x3D;”” class&#x3D;””&gt; 标签。被 @Component 注解标识的类，会在指定扫描范围内被 Spring 加载并实例化，value 属性指定当前 Bean 实例的 beanName。 @Scope对应 &lt;bean scope&#x3D;””&gt; 标签。在类上或使用了 @Bean 标注的方法上使用该注解。标注 Bean 的作用范围，取值为 singleton 或 prototype。 @Lazy对应 &lt;bean lazy-init&#x3D;””&gt; 标签。在类上或使用了 @Bean 标注的方法上使用该注解。标注 Bean 是否延迟加载，取值为 true 和 false。 @PostConstruct对应 &lt;bean init-method&#x3D;””&gt; 标签。在方法上使用，标注 Bean 被实例化后执行的方法。 @PreDestroy对应 &lt;bean destroy-method&#x3D;””&gt; 标签。在方法上使用，标注 Bean 被销毁前执行的方法。 @Primary@Primary 用于标注相同类型的 Bean 优先被使用权，与@Component 和 @Bean 一起使用，标注该Bean的优先级更高。 Bean 的依赖注入注解 属性注入注解 描述 @Value 使用在字段或方法上，用于注入普通数据 @Autowired 使用在字段或方法上，用于根据类型（byType）注入引用数据 @Qualifier 使用在字段或方法上，结合 @Autowired，根据名称注入 @Resource 使用在字段或方法上，根据类型或名称进行注入无参就是根据类型注入，有参数就是根据名称注入 @Value 使用示例 @Autowired 使用示例 非自定义 Bean 的配置非自定义 Bean 不能像自定义 Bean 一样使用 @Component 进行管理，非自定义 Bean 要通过工厂的方式进行实例化，使用 @Bean 标注方法即可。@Bean 的属性为 beanName，如不指定为当前工厂方法名称。 如果 @Bean 工厂方法需要参数的话，有以下注入方式： 使用 @Autowired 根据类型自动进行 Bean 的匹配，@Autowired 可以省略； 使用 @Qualifier 根据名称进行 Bean 的匹配； 使用 @Value 根据名称进行普通数据类型匹配； 示例： 输出结果： Spring 配置类注解 注解 描述 @Configuration 被标识的类为配置类，替代原有 xml 配置文件。该注解具有 @Component 的作用。 @ComponentScan 扫描注解配置。可以指定一个或多个包名，不指定表示扫描当前 @componentScan 注解配置类所在包及其子包下的类替代 &lt;context:component-scan base-package&#x3D;””&#x2F;&gt; 标签 @PropertySource 用于加载外部 properties 资源配置替代&lt;context:property-placeholder location&#x3D;””&#x2F;&gt;标签 @Import 用于加载其他配置类替代 &lt;import resource&#x3D;””&#x2F;&gt; @Configuration 使用示例： 注：proxyBeanMethods 属性值为 true，表示调用配置类中的方法得到的对象是从容器中获取的而不是重新创建的。为 false 表示每次执行都会重新创建对象。 Spring 读取配置类 Spring 的基本使用配置非自定义 Bean例如配置日期对象交由 Spring 管理，Java 代码如下： XML 配置如下： Bean 实例化的基本流程 加载 xml 配置文件，解析获取配置中的每个 &lt;bean&gt; 的信息，封装成一个个的 BeanDefinition 对象; 将 BeanDefinition 存储在一个名为 beanDefinitionMap 的 Map&lt;String,BeanDefinition&gt; 中; ApplicationContext 底层遍历 beanDefinitionMap，创建 Bean 实例对象; 创建好的 Bean 实例对象，被存储到一个名为 singletonObjects 的 Map&lt;String,Object&gt; 中; 当执行 applicationContext.getBean(beanName) 时，从 singletonObjects 去匹配 Bean 实例返回。 Spring 的后置处理器Spring 的后处理器是 Spring 对外开发的重要扩展点，允许我们介入到 Bean 的整个实例化流程中来，以达到动态注册、修改或删除 BeanDefinition，以及动态修改 Bean 的作用。Spring 的后置处理器： BeanFactoryPostProcessor：Bean 工厂后处理器，在 BeanDefinitionMap 填充完毕，Bean 实例化之前执行。可以动态注册、修改或删除 BeanDefinition 对象。 BeanDefinitionRegistryPostProcessor：BeanFactoryPostProcessor 的子接口，专门用来动态添加 BeanDefinition 对象。 BeanPostProcessor：Bean 后处理器，一般在 Bean 实例化之后，填充到单例 singletonObjects 之前执行。可以将 Bean 替换成代理对象 Bean。 BeanFactoryPostProcessor 动态添加 BeanDefinition 对象 示例： BeanPostProcessor 将 Bean 替换成代理对象 Bean 示例： Bean 的生命周期Bean 的生命周期：从 Bean 实例化之后，即通过反射创建出对象之后，到 Bean 成为一个完整对象，最终存储到单例池中的过程。Bean 的生命周期大体上分为三个阶段： Bean 的实例化阶段：Spring 框架会取出 BeanDefinition 的信息进行判断当前 Bean 的范围是否是 singleton 的，是否不是延迟加载的，是否不是 FactoryBean 等，最终将一个普通的 singleton的Bean 通过反射进行实例化； Bean 的初始化阶段：Bean 创建之后还仅仅是个空壳对象，还需要对 Bean 实例的属性进行填充、执行一些 Aware 接口方法、执行 BeanPostProcessor 方法、执行 InitializingBean 接口的初始化方法等。 Bean 的完成阶段：经过初始化阶段，Bean 就成为了一个完整的 Bean，被存储到单例池 singletonObjects 中，即完成了 Bean 的整个生命周期。 Bean 的初始化涉及如下几个过程： Bean 实例的属性填充； Aware 接口属性注入； BeanPostProcessor 的 before() 方法回调； InitializingBean 接口的初始化方法回调； BeanPostProcessor 的 after() 方法回调； Spring 循环依赖问题Bean 在进行属性注入时，分以下几种情况： 注入普通属性：String、int 或存储基本类型的集合时，直接通过 set 方法的反射赋值进去； 注入对象引用属性：从容器中 getBean 获取 Bean 后通过 set 方法反射设置进去，如果容器中没有该 Bean，则会先创建被注入对象 Bean 实例（完成整个生命周期）后，再进行注入操作，如果对象之间相互引用可能会发生循环依赖异常。 循环依赖示例： Spring 解决循环依赖的方式： ClassA 创建对象。 将 Class A 对象存储到三级缓存。 ClassA 属性注入 ClassB 对象时，在一、二、三级缓存都找不到 ClassB 对象。 ClassB 创建对象。 将 Class B 对象存储到三级缓存。 ClassB 属性注入时在三级缓存找到 ClassA 对象，注入 ClassA 对象。 将 ClassA 对象从三级缓存移到二级缓存。 执行其它初始化过程，最终成为一个完整的 ClassB 对象。 将 ClassB 对象存储到一级缓存，删除二三级缓存的 ClassB 对象。 ClassA 属性注入时在一级缓存找到 ClassB 对象，注入 ClassB 对象。 执行其它初始化过程，最终成为一个完整的 ClassA 对象。 将 ClassA 对象存储到一级缓存，删除二三级缓存的 ClassA 对象。 常用的 Aware 接口 Aware 接口 回调方法 作用 ApplicationContextAware setApplicationContext(ApplicationContext applicationContext) 注入 applicationContext 对象 BeanNameAware setBeanName(String beanName) 注入当前 Bean 在容器中的 beanName BeanFactoryAware setBeanFactory(BeanFactory factory) 注入 beanFactory 对象 ServletContextAware setServletContext(ServletContext context) 注入 ServletContext 对象，web 环境下才生效 classpath 和 classpath* 的区别classpath：只会到项目的 class 路径中找指定的文件。 classpath*：查找范围不仅包含项目的 class 路径，还包含 jar 包中的 class 路径。 XML 配置文件整合第三方框架两种整合方案： 不需要使用 Spring 的配置文件配置第三方框架本身内容，也不需要自定义名空间，例如：MyBatis。 需要使用 Spring 的配置文件配置第三方框架本身内容，需要引入第三方框架命名空间，例如：Dubbo。 "},{"title":"【Maven】基本使用","date":"2024-03-02T01:00:00.000Z","url":"/blog/2024/03/02/Maven/maven%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["Maven","/blog/tags/Maven/"]],"categories":[["undefined",""]],"content":"Maven 介绍Maven 是什么Maven 的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）。 POM：全称 Project Object Model，项目对象模型。 Maven 的作用项目构建：提供标准的自动化项目构建方式。 依赖管理：方便快捷地管理项目依赖的资源（jar包），避免资源间的版本冲突问题。 统一开发结构：提供标准的、统一的项目结构。 Maven 的基础概念仓库仓库：用于存储资源，包含各种 jar 包。 仓库分类： 本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源。 远程仓库：非本机电脑上的仓库，为本地仓库提供资源。 中央仓库：Maven 团队维护，存储所有资源的仓库。 私服：公司范围内存储资源的仓库，从中央仓库获取资源。 私服的作用： 保存具有版权的资源，包含购买或自主研发的 jar。中央仓库的资源都是开源的，不能存储具有版权的资源。 一定范围内共享资源，仅对内部开放，不对外共享。 坐标坐标：仓库中的资源的唯一标识符。 坐标的组成： groupId：表示当前 maven 项目隶属的组织，通常是域名反写，例如：org.apache。 artifactId：表示当前 maven 项目的名称。 version：表示当前项目的版本号。 Maven 命令编译 清理 测试 打包 推送到本地仓库 推送到私服 下载项目依赖的源代码 选项-D skipTests：跳过测试。 pom 文件pom 文件格式 依赖管理依赖配置 依赖传递依赖具有传递性：项目依赖的资源如果依赖其它资源，当前项目间接依赖其它资源，项目也可以使用其它资源。 依赖传递冲突问题： 路径优先：当依赖中出现相同的资源时，层级越浅，优先级越高。 声明优先：当依赖在相同层级被依赖时，配置顺序考前的优先级高。 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。 依赖范围依赖范围：指依赖的作用范围，默认情况是可以在任何地方使用。 作用范围： 主程序范围有效（main 文件夹范围内） 测试程序范围有效（test 文件夹范围内） 是否参与打包（package 指令范围内） scope 主代码 测试代码 打包 示例 compile（默认） √ √ √ log4j test √ junit provided √ √ servlet-api runtime √ jdbc 带有依赖范围的资源在进行传递时，作用范围将受影响。横轴为直接依赖，纵轴为间接依赖： compile test provided runtime compile compile test provided runtime test provided runtime runtime test provided runtime 插件管理插件配置 插件的生命周期 validate（校验）：校验项目是否正确并且所有必要的信息可以完成项目的构建过程。 initialize（初始化）：初始化构建状态，比如设置属性值。 generate-sources（生成源代码）：生成包含在编译阶段中的任何源代码。 process-sources（处理源代码）：处理源代码，比如说，过滤任意值。 generate-resources（生成资源文件）：生成将会包含在项目包中的资源文件。 process-resources （处理资源文件）：复制和处理资源到目标目录，为打包阶段最好准备。 compile（编译） ：编译项目的源代码。 process-classes（处理类文件）：处理编译生成的文件，比如说对Java class文件做字节码改善优化。 generate-test-sources（生成测试源代码）：生成包含在编译阶段中的任何测试源代码。 process-test-sources（处理测试源代码）：处理测试源代码，比如说，过滤任意值。 generate-test-resources（生成测试资源文件）：为测试创建资源文件。 process-test-resources（处理测试资源文件）：复制和处理测试资源到目标目录。 test-compile（编译测试源码）：编译测试源代码到测试目标目录. process-test-classes（处理测试类文件）：处理测试源码编译生成的文件。 test（测试）：使用合适的单元测试框架运行测试（Juint是其中之一）。 prepare-package（准备打包）：在实际打包之前，执行任何的必要的操作为打包做准备。 package（打包）：将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。 pre-integration-test（集成测试前）：在执行集成测试前进行必要的动作。比如说，搭建需要的环境。 integration-test（集成测试）：处理和部署项目到可以运行集成测试环境中。 post-integration-test（集成测试后）：在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。 verify （验证）：运行任意的检查来验证项目包有效且达到质量标准。 install（安装）：安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。 deploy（部署）：将最终的项目包复制到远程仓库中与其他开发者和项目共享。 tomcat 插件 读取 pom.xml 文件属性 pom.xml 文件添加以下内容： 引用方式：${属性名称} 父模块管理子模块父模块的作用统一管理多个项目&#x2F;模块，快速构建 maven 项目。 父模块的 pom.xml 文件创建一个空模块，没有代码，只有 pom.xml 文件。 注：参与聚合操作的模块的执行顺序与模块间的依赖关系有关，与配置顺序无关。 子模块能够继承父模块的资源 groupld：项目组ID； version：项目版本； description：项目的描述信息； organization：项目的组织信息； inceptionYear：项目的创始年份； ur：项目的URL地址； developers：项目的开发者信息； contributors：项目的贡献者信息； distributionManagement：项目的部署配置； issueManagement：项目的缺陷跟踪系统信息； ciManagement：项目的持续集成系统信息； scm：项目的版本控制系统信息； malilingLists：项目的邮件列表信息； properties：自定义的 Maven 属性； dependencies：项目的依赖配置； dependencyManagement：项目的依赖管理配置； repositories：项目的仓库配置； build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等； reporting：包括项目的报告输出目录配置、报告插件配置等； Maven 配置本地仓库配置 镜像仓库配置 配置私服的账号密码 私服安装、访问、配置私服maven 私服官网下载地址，解压即可使用。 启动服务器：nexus.exe /run nexus。 访问服务器：;私服 ip&#125;:&#123;私服端口&#125;/ 修改基础配置信息：安装路径下 etc 目录中 nexus-default.properties 文件保存有 nexus 基础配置信息，例如默认访问端口。 修改服务器运行配置信息：安装路径下 bin 目录中 nexus.vmoptions 文件保存有 nexus 服务器启动对应的配置信息，例如默认占用内存空间。 仓库分类 宿主仓库 hosted：保存无法从中央仓库获取的资源，例如自主研发的项目、第三方非开源的项目。 代理仓库 proxy：代理远程仓库，通过 nexus 访问其他公共仓库，例如中央仓库。 仓库组 group：将若干个仓库组成一个群组，简化配置。仓库组不能保存资源，属于设计型仓库。 IDEA 上传&#x2F;访问私服 在 maven 的 setting.xml 配置文件添加访问私服的账号和密码 配置私服镜像，指定本地仓库资源的来源（setting.xml）。 在项目的 pom.xml 配置上传资源到私服时的保存位置。 target 目录结构 classes：存放 main 目录下的编译文件。 test-classes：存放 test 目录下的编译文件 surefire-reports：存放测试报告。 jar 包：项目的 jar 包。 Maven 异常Could not find artifact xxx jar 包： 本地仓库、远程仓库、中央仓库都不存在该 jar 包。 No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK? 可能是因为在环境变量没有配置 JAVA_HOME 变量导致的。 Maven 打包配置将 maven 项目打成 zip 包或完成 jar 配置 package.xml 文件内容： IDEA 各版本对 Maven 版本兼容问题 IDEA 2022 兼容 Maven 3.8.1 及之前所有版本 IDEA 2021 兼容 Maven 3.8.1 及之前所有版本 IDEA 2020 兼容 Maven 3.6.3 及之前所有版本 IDEA 2018 兼容 Maven 3.6.1 及之前所有版本 "},{"title":"【Selenium】基本使用","date":"2024-02-29T01:00:00.000Z","url":"/blog/2024/02/29/Selenium/selenium%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["Selenium","/blog/tags/Selenium/"]],"categories":[["Selenium","/blog/categories/Selenium/"]],"content":"定位元素id 定位 id 指标签的唯一标识，在页面中唯一。如果匹配不到元素会抛出 NoSuchElementException 异常。 示例 name 定位 name 指标签的名称，在页面中可以不唯一。如果有多个匹配的元素，会返回第一个匹配的元素。如果没有匹配的元素会抛出 NoSuchElementException 异常。 示例 xpath 定位 XPath 是用来定位 XML 文档节点的语言。不过 HTML 可以看成是 XML(XHTML) 的一种实现。 用 XPath 的主要理由之一，就是想定位的元素没有合适的 id 或者 name 属性的时候，你可以用 XPath 来对元素进行绝对定位（不推荐）或者把这个元素和另外一个有确定 id 或者 name 的元素关联起来（相对定位）。XPath 定位器也可以用来找出那些具有 id ，name 以外属性的元素。 常用语法 表达式 描述 &#x2F; 从根节点选取&#x2F;取子节点。 &#x2F;&#x2F; 从匹配选择的当前节点选取子孙节点，不考虑位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 路径表达式 结果 &#x2F;bookstore&#x2F;book[1] 选取属于 bookstore 子元素的第一个 book 元素。 &#x2F;bookstore&#x2F;book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 &#x2F;bookstore&#x2F;book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 &#x2F;bookstore&#x2F;book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 &#x2F;&#x2F;title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 &#x2F;&#x2F;title[@lang&#x3D;’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 示例 定位 form 元素： 定位 username 元素： 定位 clear 元素： class 定位 class 指标签的类名，在页面中可以不唯一。如果有多个匹配的元素，会返回第一个匹配的元素。如果没有匹配的元素会抛出 NoSuchElementException 异常。 示例 tag 定位 使用元素的标签名定位，如果没有匹配的元素，会抛出NoSuchElementException异常。 示例 css 定位 使用 css 选择器的语法来定位元素。如果有多个，只返回第一个匹配成功的元素，无元素匹配会抛出 NoSuchElementException 异常。 常用语法 方法 例子 描述 .class .toolbar-search-container 选择 class = &#39;toolbar-search-container&#39; 的所有元素 #id #toolbar-search-input 选择 id = &#39;toolbar-search-input&#39; 的元素 element input 选择所有 &lt;input\\&gt; 元素 element&gt;element div&gt;input 选择父元素为 &lt;div\\&gt; 的所有 &lt;input\\&gt; 元素 [attribute&#x3D;value] type=&#39;text&#39; 选择 type = &#39;text&#39; 的所有元素 示例 link 定位 如果一个锚标签使用了文本，就可以使用链接文本定位超链接。如果有多个，只返回第一个匹配成功的元素，无元素匹配会抛出 NoSuchElementException 异常。 实例 注：find_element_by_partial_link_text 使用子串匹配，只要输入子字符串即可匹配。 定位多个元素 下列方法会返回一个 list，其余使用方式相同。 find_elements_by_name find_elements_by_xpath find_elements_by_class_name find_elements_by_tag_name find_elements_by_css_selector find_elements_by_link_text find_elements_by_partial_link_text 示例打印百度首页的热搜列表。 执行结果： 习近平为全国干部学习培训教材作序超80种罕见病用药进医保酒驾最新标准3月1日起实施最新居民收入五档划分中国人在非洲当酋长：能娶4个老婆知名主播小团团被曝涉案金额大 通用的定位方法 使用 find_element 或 find_elements，定位元素。例如： By 类的可用属性如下： key value XPATH “xpath” LINK_TEXT “link text” PARTIAL_LINK_TEXT “partial link text” NAME “name” TAG_NAME “tag_name” CLASS_NAME “class name” CSS_SELECTOR “css selector” 等待元素很多页面都使用 ajax 技术，页面的元素不是同时被加载出来的，为了防止定位这些尚在加载的元素报错，可以设置元素等来增加脚本的稳定性。webdriver 中的等待分为显式等待和隐式等待。 显式等待显示等待：设置一个超时时间，每个一段时间就去检测一次该元素是否存在，如果存在则执行后续内容，如果超过最大时间（超时时间）则抛出超时异常 TimeoutException 。显示等待需要使用 WebDriverWait 中的 until 方法或 until_not 方法，同时配合 ExpectedCondition 使用。 WebDriverWait 介绍 driver：浏览器驱动。 timeout：超时时间，单位秒。 poll_frequency：每次检测的间隔时间，默认为 0.5 秒。 ignored_exceptions：指定忽略的异常，如果在调用 until 或 until_not 的过程中抛出指定忽略的异常，则不中断代码，默认忽略的异常只有 NoSuchElementException 。 method：指定预期条件的判断方法，在等待期间，每隔一段时间调用该方法，判断元素是否存在，直到元素出现。until_not 正好相反，当元素消失或指定条件不成立，则继续执行后续代码。method 中的预期条件判断方法是由 ExpectedCondition 提供。 message: 如果超时，抛出 TimeoutException ，并显示 message 中的内容 expected_conditions 常用方法 方法 描述 title_is(‘百度一下’) 判断当前页面的 title 是否等于预期。 title_contains(‘百度’) 判断当前页面的 title 是否包含预期字符串。 presence_of_element_located(locator) 判断元素是否被加到了 dom 树里，并不代表该元素一定可见。 visibility_of_element_located(locator) 判断元素是否可见，可见代表元素非隐藏，并且元素的宽和高都不等于 0。 visibility_of(element) 跟上一个方法作用相同，但传入参数为 element。 text_to_be_present_in_element(locator , ‘百度’) 判断元素中的 text 是否包含了预期的字符串。 text_to_be_present_in_element_value(locator , ‘某值’) 判断元素中的 value 属性是否包含了预期的字符串。 frame_to_be_available_and_switch_to_it(locator) 判断该 frame 是否可以 switch 进去，True 则 switch 进去，反之 False。 invisibility_of_element_located(locator) 判断元素中是否不存在于 dom 树或不可见。 element_to_be_clickable(locator) 判断元素中是否可见并且是可点击的。 staleness_of(element) 等待元素从 dom 树中移除。 element_to_be_selected(element) 判断元素是否被选中，一般用在下拉列表。 element_selection_state_to_be(element, True) 判断元素的选中状态是否符合预期，参数 element，第二个参数为 True&#x2F;False。 element_located_selection_state_to_be(locator, True) 跟上一个方法作用相同，但传入参数为 locator。 alert_is_present() 判断页面上是否存在 alert。 示例 隐式等待隐式等待：隐式等待也是指定一个超时时间，如果超出这个时间指定元素还没有被加载出来，就会抛出 NoSuchElementException 异常。除了抛出的异常不同外，还有一点，隐式等待是全局性的，即运行过程中，如果元素可以定位到，它不会影响代码运行，但如果定位不到，则它会以轮询的方式不断地访问元素直到元素被找到，若超过指定时间，则抛出异常。 使用 driver.implicitly_wait() 来实现隐式等待，单位秒。使用难度相对于显式等待要简单很多。 示例 注：代码运行到 driver.find_element_by_id(&#39;kw&#39;) 时触发隐式等待，在轮询检查 5s 后仍然没有定位到元素，抛出 NoSuchElementException 异常。 显示等待跟隐式等待的选择：始终使用显式等待。忘记隐式等待的存在。 浏览器操作修改浏览器窗口大小 方法 driver.set_window_size(width, height)：修改浏览器宽度和高度。 driver.maximize_window()：浏览器全屏显示。 示例1s 后浏览器全屏显示： 浏览器前进&#x2F;后退 方法 driver.back()：浏览器后退操作。 driver.forward()：浏览器前进操作。 示例打开百度，搜索 selenium，然后后退到百度界面，再前进到 selenium 搜索界面。 刷新浏览器 方法 driver.refresh()：刷新页面。 示例刷新百度的 selenium 搜索页面。 浏览器窗口切换 切换窗口需要获取窗口对应的句柄，这些信息的保存在 driver.window_handles 中。保存顺序是按照时间来的，最新打开的窗口放在数组的末尾。 注意：通过页面打开新的页面，句柄还是原来页面的句柄。 方法 driver.switch_to.window(window_handle)：切换浏览器，window_handle 为窗口句柄。 driver.switch_to.frame( id&#x2F;name&#x2F;element )：将操作对象切换到 frame&#x2F;iframe 内嵌的页面。可以使用 id 或 name 属性定位，也可以传入 frame&#x2F;iframe 元素对象。 示例示例1：先打开百度页面，在新标签打开 csdn 页面，然后切换到百度页面。 示例2：打开第一个页面，再打开第二个页面，句柄还是第一个页面的句柄。 执行结果： 第一个页面的句柄&#x3D;21，第二个页面的句柄&#x3D;4294967297打开第一个页面时指向的句柄&#x3D;21，打开第二个页面指向的句柄&#x3D;21 示例3：操作 iframe 内嵌的页面。 页面： 鼠标操作单击左键 方法 element.click()：左键不需要用到 ActionChains。 示例单击百度首页的摄像头图标。 单击右键 方法 ActionChains(driver).context_click(element).perform() 示例对百度的 logo 右键： 双击 方法 ActionChains(driver).double_click(element).perform() 示例双击百度首页的换一换图标，点一次是展示下一页热搜，点两次是展示第三也热搜。 拖动 方法 ActionChains(driver).drag_and_drop(source, target).perform() 示例将百度第一条热搜拖动到搜索框中。 鼠标悬停 方法 ActionChains(driver).move_to_element(element).perform() 示例 执行结果： 键盘操作 方法 常见的键盘操作 操作 描述 Keys.F1 F1键 Keys.SPACE 空格 Keys.TAB Tab键 Keys.ESCAPE ESC键 Keys.ALT Alt键 Keys.SHIFT Shift键 Keys.ENTER Enter 键 Keys.BACK_SPACE Backspace 键 Keys.ARROW_DOWN 向下箭头 Keys.ARROW_LEFT 向左箭头 Keys.ARROW_RIGHT 向右箭头 Keys.ARROW_UP 向上箭头 示例打开百度首页，搜索框输入 “selenium”，复制搜索框的内容。在新标签中打开另一个百度首页，把拷贝内容复制到搜索框中。 弹窗处理JavaScript 有三种弹窗：alert（确认）、confirm（确认、取消）、prompt（文本框、确认、取消）。 获取弹窗方式switch_to.alert：获取当前弹窗 alert 对象。 操作弹窗 方法 描述 alert.text 获取弹窗中的文字 alert.accept() 接受（确认）弹窗内容 alert.dismiss() 解除（取消）弹窗 alert.send_keys() 发送文本至警告框 示例前端页面代码： 前端页面示例： 示例1：操作 alert 弹窗。 示例2：操作 confirm 弹窗。 示例3：操作 prompt 弹窗。 上传&#x2F;下载文件上传文件上传方式：对于 input 标签上传文件，可以直接使用 send_keys(文件路径) 来上传。 示例在百度首页，点击照相机图片，使用百度的图片搜索功能。 执行结果： 文件下载Firefox 浏览器下载文件webdriver.FirefoxProfile() 为火狐浏览器的配置对象，使用 set_preference 方法进行配置。相关配置说明： browser.download.folderList：1 代表浏览器的默认下载路径，2 代表保存到指定目录。 browser.download.dir：下载到指定目录。 browser.helperApps.neverAsk.saveToDisk：对指定的文件类型直接保存到本地磁盘，不需要弹窗询问。 示例： 到 github 上下载 Firefox 浏览器的驱动。 cookies 操作driver 提供的 cookies 操作 get_cookies()：以字典的形式返回当前会话中可见的 cookie 信息。 get_cookie(name)：返回 cookie 字典中 key &#x3D;&#x3D; name 的 cookie 信息。 add_cookie(cookie_dict)：将 cookie 添加到当前会话中。 delete_cookie(name)：删除指定名称的单个 cookie。 delete_all_cookies()：删除会话范围内的所有 cookie。 cookies 操作示例 执行 JavaScript 脚本打开新的标签页 滑动滚动条window.scrollTo(xpos, ypos)作用：滚动到指定的坐标。 参数 描述 xpos 必需。要在窗口文档显示区左上角显示的文档的 x 坐标。 ypos 必需。要在窗口文档显示区左上角显示的文档的 y 坐标。 window.scrollBy(xnum, ynum)作用：向右或向下滚动指定像素。 参数 描述 xnum 必需。把文档向右滚动的像素数。 ynum 必需。把文档向下滚动的像素数。 Element.scrollIntoView()作用：滑动到指定元素的位置。 示例： 在 b 站首页不断下滑刷出新的视频。 截图方式使用 driver.get_screenshot_as_file(图片保存路径) 对当前 driver 指向的页面句柄截图。主要用在测试时记录报错页面。 截图示例"},{"title":"【Selenium】搭建环境","date":"2024-02-28T06:00:00.000Z","url":"/blog/2024/02/28/Selenium/%E6%90%AD%E5%BB%BAselenium%E7%8E%AF%E5%A2%83/","tags":[["Selenium","/blog/tags/Selenium/"]],"categories":[["Selenium","/blog/categories/Selenium/"]],"content":"安装 selenium 安装火狐浏览器火狐浏览器历史版本 安装 89.0.2 版本的火狐浏览器 注：安装完成后需要设置取消自动更新。 安装火狐浏览器驱动火狐浏览器不同版本对应的驱动以及下载 测试安装结果 可能会遇到的问题抛出 ValueError 异常 异常信息：Timeout value connect was &lt;object object at 0x000002A40BE37F80&gt;, but it must be an int, float or None. selenium 会使用到 urllib3 库，版本不兼容会抛出上述异常。解决方式是修改 urllib3 版本： pip install selenium&#x3D;&#x3D;3.141.0pip install –upgrade urllib3&#x3D;&#x3D;1.26.16 "},{"title":"【Request】高级用法","date":"2024-02-28T01:00:00.000Z","url":"/blog/2024/02/28/Python%20Module/Request/Request%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/","tags":[["Request","/blog/tags/Request/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"session 会话对象作用：session 会话对象能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie。session 会话对象具有 Requests API 的所有方法。 示例： 第一个请求用户设置 cookie，第二个请求用于获取设置的 cookie。若两个请求不在同一个会话，第二个请求获取的 cookie 为空。 执行结果： lin session 会话的其他作用：session 会话也可用来设置 headers、cookies、params等参数，作用于当前会话的全部请求。如果方法层有相关的参数，会覆盖会话的参数。方法级别的参数也不会被跨请求保持 示例： 执行结果：  创建 Request 对象request 发送请求的原理当使用 requests 库的 get&#x2F;post 方法发送请求时，requests 在内部构造了一个 Request 对象，并给这个对象赋予了各种参数，包括 url、headers、data 等等。然后直接把这个 Request 对象发送出去，请求成功后会再得到一个 Response 对象。 手动创建 Request 对象 执行结果： &lt;RequestsCookieJar[]&gt;&lt;RequestsCookieJar[&lt;Cookie key1&#x3D;val1 for httpbin.org&#x2F;get&gt;]&gt; 注：使用 request_obj.prepare() 方式发送请求，该请求的 cookies 配置不受 session 的 cookies 配置影响。如果使用 session.prepare_request(request_obj) 方式发送请求，该请求的 cookies 配置受 session 的 cookies 配置影响。 SSL 证书验证当网站的 CA 证书不是官方认证的，此时访问该网站会出现以下画面。 使用 request 访问该 url 也会抛出 SSLError 异常，此时可以使用 verify=False 禁止 request 进行 CA 认证，但还会发出 InsecureRequestWarning 警告。示例： 执行结果： D:\\Workspace\\python\\project\\venv\\lib\\site-packages\\urllib3\\connectionpool.py:1103: InsecureRequestWarning: Unverified HTTPS request is being made to host ‘127.0.0.1’. Adding certificate verification is strongly advised. See:  warnings.warn({‘Content-Length’: ‘0’, ‘Date’: ‘Wed, 28 Feb 2024 02:03:04 GMT’, ‘Server’: ‘’} "},{"title":"【Python】OS 文件/目录方法","date":"2024-02-27T06:00:00.000Z","url":"/blog/2024/02/27/Python/99_%E7%A7%AF%E7%B4%AF/OS%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%96%B9%E6%B3%95/","tags":[["Python","/blog/tags/Python/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"获取 py 文件所在目录的绝对路径 示例： 获取项目的根目录"},{"title":"【Request】基本使用","date":"2024-02-27T01:00:00.000Z","url":"/blog/2024/02/27/Python%20Module/Request/Request%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["Request","/blog/tags/Request/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"发送请求 传递参数构建 URL 参数构建 url 参数示例： 还可以将一个列表作为值传入： 注：字典里值为 None 的键都不会被添加到 URL 的参数中。 构建表单参数构建表单参数示例： 执行结果： 在表单中同一 key 有多个元素的时候，可以使用元组列表。例如： 执行结果： 构建请求主体参数 执行结果： 上传文件上传文件示例： 上传文件时，可以显式地设置文件名，文件类型和请求头： 注：使用二进制模式打开文件，以便 requests 提供正确的 Content-Length 数据。 构建请求头参数构建请求头参数示例： 构建 Cookie 参数request 请求构建 cookie 示例： session 会话构建 cookie示例： 执行结果： 响应内容response.text 作用以 str 类型输出服务器的响应内容。 乱码问题可以通过 response.encoding 查看当前解码方式。也可以通过 response.encoding = utf8 设置解码方式。 response.content 作用以 byte 类型输出服务器的响应内容，主要针对图片、视频、音频等非文本响应内容。 示例 执行结果： response.json() 作用自动将 json 字符串类型的响应内容转换为 python 对象（dict 类型或 list 类型），如果响应结果不是 json 字符串，执行该方法将抛出 ValueError: No JSON object could be decoded 异常。 示例 执行结果： response.url 作用查看响应的 url。如果发送了重定向，那么看到是重定向后的 url。 response.status_code 作用查看响应的状态码。 示例 response.raise_for_status() 作用如果响应状态码为 4xx 或 5xx，调用 response.raise_for_status() 方法来抛出异常。如果是 2xx 或 3xx，调用该方法不会抛出异常。 示例 response.request.headers 作用查看请求头数据，requests模块下的 CaseInsensitiveDict 类型，获取参数值时 key 是不区分大小写的。 response.headers 作用查看响应头数据，requests模块下的 CaseInsensitiveDict 类型，获取参数值时 key 是不区分大小写的。 response.request._cookies 作用查看请求携带的 cookie 数据，返回 RequestsCookieJar 对象。 response.cookies 作用查看响应的 cookie 数据，返回 RequestsCookieJar 对象。 response.history 作用查看重定向的请求历史记录。list 类型，list 中存储每次请求的 response 对象，对象列表按照从最老到最近的请求进行排序。 注：可以使用 allow_redirects&#x3D;False 禁止重定向。 示例 执行结果： timeout 超时作用通过 timeout 参数设定超时时间，如果服务器在规定时间内没有响应数据，则抛出 Timeout 异常。 示例"},{"title":"【Pytest】基本使用","date":"2024-02-26T06:00:00.000Z","url":"/blog/2024/02/26/Python%20Module/Pytest/Pytest%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/","tags":[["Python","/blog/tags/Python/"],["Pytest","/blog/tags/Pytest/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"pytest 简介 pytest 是一个非常成熟的 python 的单元框架，比 unittest 更灵活。 pytest 可以和 selenium，requests，appium 结合实现 web 自动化，接口自动化，app 自 动化。 pytest 可以实现测试函数的跳过以及重新执行失败的测试函数。 pytest 可以和 allure 生成非常美观的测试报告。 pytest 可以和 Jenkins 持续集成。 pytest 有很多非常强大的插件，并且这些插件能够实现很多的实用的操作。 pytest：单元测试。 pytest-xdist：测试函数分布式执行，多CPU分发。 pytest-ordering：用于改变测试函数的执行顺序（从上到下）。 pytest-rerunfailures：测试函数失败后重跑。 pytest-html：生成 html 格式的自动化测试报告。 allure-pytest：用于生成美观的测试报告。 ppyaml：操作 yaml 文件。 编写测试函数的默认规则编写规则 模块名必须以 test_ 开头。 测试类必须以 Test 开头，并且不能有 init 函数。 测试函数必须以 test 开头。 注意：测试模块导入的包如果满足上述条件并且引用了包中的内容，那么包中的测试函数也会被执行。 函数形式编写用例规则：模块名以 test_ 开头，用例方法名以 test 开头。 类形式编写用例规则：模块名以 test_ 开头，测试类名以 Test 开头，用例方法名以 test 开头。 运行 pytest 方式命令行模式pytest 命令的使用指令：pytest 操作对象： 为空表示针对所有符合条件的测试函数。 测试目录。例如：.&#x2F;interface_testcase。 测试文件。例如：.&#x2F;interface_testcase&#x2F;test_login.py。 测试类。例如：测试文件::测试类。 测试函数。例如：测试文件::测试类::测试方法。 选项： -s：表示输出调试信息，包括 print 打印的信息。 -v：显示更详细的信息。 -n=数字：使用多线程或者分布式运行测试函数，数字表示使用多少个线程执行（前提是安装了 pytest-xdist 插件）。 --reruns=数字：失败后可以重新执行的次数（前提是安装了 pytest-rerunfailures 插件）。 -x：出现一个测试函数执行失败就停止测试。 -maxfail=数字：出现几个测试函数执行失败才停止测试。 --html 报告路径：生成 html 的测试报告（前提是安装了 pytest-html 插件）。 -k 字符串：只运行测试函数名称中包含指定字符串的测试函数。支持 and/or/not 逻辑表达式。 -m=&#39;字符串&#39;：执行指定标记的测试函数。支持 and/or/not 逻辑表达式。 --co：全称是 –collect-only，表示只收集用例，不执行。 --timeout=数字：用例执行的最大时长，如果超时没有执行完，就是强制停止用例。单位是秒（前提是安装了 pytest-timeout 插件）。 自定义命令行参数以上参数都是 Pytest 自带的或者三方插件给我们提供的参数，当这些参数不能满足我们的需求的时候，可以使用钩子函数 pytest_addoption 自定义一些命令行参数。例如： parser.addoption() 传入参数说明： name：自定义命令行参数的名字，可以是：”foo”， “-foo” 或 “–foo”； action：在命令行中遇到此参数时要采取的基本操作类型； nargs：应该使用的命令行参数的数量； const：某些操作和nargs选择所需的常量值； default：如果参数不在命令行中，则生成的默认值。 type：命令行参数应该转换为的类型； choices：参数允许值的容器； required：命令行选项是否可以省略（仅可选）； help：对参数作用的简要说明； metavar：用法消息中参数的名称； dest：要添加到 parse_args() 返回的对象中的属性的名称； 例如添加 –logLevel 参数： 参数传进来后的获取途径： （1）fixture 函数可以通过 request 对象获取： （2）hook 函数可以通过 seesion 对象获取： （3）hook 函数可以通过 item 对象获取： （4）测试函数可以通过 pytestconfig 对象获取： 主函数模式在 main 函数使用 pytest.main() 执行测试函数。pytest.main() 可以传入一个数组作为参数，传入的数组可以携带命令模式中的选项或操作对象数据。例如： pytest.ini 全局配置文件pytest.ini 文件是 pytest 框架的核心配置文件： 存放位置：一般放在项目的根目录。 编码：必须是 ANSI 或 GB2312。 作用：修改 pytest 默认的行为。 运行规则：不管是命令行模式运行，还是主函数的模式运行，都会去读取这个配置文件。 pytest.ini 文件内容 markers 的用法： 在测试函数上添加注解 @pytest.mark.smoke ，一个测试函数可以添加多个。 执行 pytest 时添加选项 -m=标记名称，表示只执行被标记的测试函数。如果要执行不同类型标记的函数，可以添加 -m=标记名称1 or 标记名称 2。 markers 的作用：将不同的测试函数进行分组。 使用 fixture 实现部分前后置操作@pytest.fixture() 参数@pytest.fixture() 共有五个参数： scope：被标记的 fixture 函数的作用域。 autouse：该 fixture 函数是否自动实现前后置，默认为 False。 params：实现参数化。 ids：对参数起别名，必须和 params 一起使用。 name：给 fixture 函数起别名。 scope 参数scope 取值： function（默认）：在函数的前后执行。 class：在类的前后执行。 module：在模块的前后执行。 package、session：在整个项目会话的前后执行。需要结合 conftest.py 文件实现。 autouse 参数为 True 时自动实现前后置，为 False 时需要手动实现前后置。 当 scope 不同取值时手动实现前后置地方式： scope&#x3D;function ：在函数参数添加 fixture 函数的名称，如果 fixture 函数有通过 return 或 yield 返回值的话，那么可以把返回值传递到测试函数中。 scope&#x3D;class：在类名上添加装饰器 **@pytest.mark.usefixtures(“fixture 函数名称”)**。 params 参数fixture 函数可以被参数化，在这种情况下，它们将被多次调用，每次执行一组依赖于该 fixture 的测试。 通过给 @pytest 的 params 参数赋值一个列表。 Fixture 函数将执行列表中的每个值，并可以通过 request.param 访问一个值。 结果： 注：如果有多个前后置函数携带 params 参数，那么会将这些前后置函数的 params 参数进行笛卡尔积后依次执行测试函数。 ids 参数作用：给参数起别名，必须和 params 一起使用。 name 参数作用：给 fixture 函数起别名，原来的 fixture 函数的名称会失效。 conftest.py 文件作用：用于存放通用的 fixture 函数。文件名称固定，不能改变。 存放位置：从项目根目录开始，每个层级都可以有个conftest.py 文件。 注：在 conftest.py 文件里面所有的 fixture 函数在被调用时都不需要导包。 各种前后固件的优先级作用域优先级：会话 &gt; 模块 &gt; 类 &gt; 函数 类型优先级：fixtrue &gt; setup&#x2F;teardown fixture 作用域相同的情况下，外层 fixture 先执行。 固件优先级从高到低排序： fixture 的 session&#x2F;package 级别 fixture 的 module 级别 setup_module、teardown_module 级别 fixture 的 class 级别 setup_class、teardown_class 级别 fixture 的 function 级别 setup_method、teardown_method 级别 注1：setup_method 和 setup_function 的区别。setup_function 是在基于函数式的用例写法使用的，setup_method 是基于类式的用例写法使用的。 注2：如果 fixture 出现相同的函数名，只会执行内层的 fixture 函数。在实际项目中，不想用某些外层的 fixture，可以在内层定义一个同名的 fixture，里面写 pass，相当于抵消掉了外层 fixture 的作用。 pytest.mark 标记的使用pytest.mark.parametrize 作用将用例数据和用例执行的逻辑代码分离，并实现根据用例，自动生成测试用例。 参数argnames：参数名称，用于将参数值传递给函数。 argvalues：参数值，参数类型为列表或元组。 示例 执行结果： pytest.mark.skip 作用无条件跳过测试用例。 参数reason：跳过测试测试函数的原因。 示例 执行结果： pytest.mark.skipif 作用根据条件来决定是否跳过用例的执行， 如果条件为 True 则跳过测试函数执行。 参数condition：跳过的条件 reason：跳过的原因 示例 执行结果： pytest.mark.usefixtures 作用手动给测试类添加类级别的 fixture 函数。 示例 执行结果： 自定义标记注册标记pytest.ini 文件注册标记的语法如下： 标记函数 标记类 通过标记筛选测试函数语法：pytest -m=&#39;标签名&#39;，支持 and/or/not 逻辑表达式。 断言常规断言Pytest 直接使用 Python 自带的 assert 语句进行断言。 自定义断言断言失败实际上都是捕获 AssertionError（断言异常） 异常，因此只需要定义一个函数，抛出 AssertionError 异常就可以了。当表达式可能是一些比较复杂的封装时，可以使用自定义断言。 "},{"title":"【Docker】应用部署","date":"2024-02-26T01:00:00.000Z","url":"/blog/2024/02/26/Docker/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/","tags":[["Docker","/blog/tags/Docker/"]],"categories":[["Docker","/blog/categories/Docker/"]],"content":"部署 MySQL拉取镜像MySQL 镜像 创建容器建立目录映射/root/docker/mysql/data /root/docker/mysql/logs /root/docker/mysql/conf 创建 my.cnf 配置文件touch /root/docker/mysql/conf/my.cnf my.cnf 添加以下内容： 创建容器，并在后台运行 注：未知原因，只要映射了 conf 目录卷，mysql 就无法启动。 环境变量： MYSQL_ROOT_PASSWORD：该变量是必填的，作用是为 MySQL root 超级用户帐户设置的密码。 mysql 文件&#x2F;目录： &#x2F;var&#x2F;lib&#x2F;mysql：该目录存放了 MySQL 的数据库文件。可在 my.cnf 配置文件的 [mysqld] 下添加 datadir 属性来修改 MySQL 的数据库文件的存放位置。查询 MySQL datadir 属性的 sql 语句为 show variables like &#39;datadir&#39;。 &#x2F;etc&#x2F;mysql：该目录存放了 MySQL 的全局配置文件。 &#x2F;etc&#x2F;mysql&#x2F;my.cnf：MySQL 的主要配置文件。 注意：启动 MySQL 报如下错误，那是因为 MySQL 新特性 secure_file_priv 对读写文件的影响。 解决方式： 部署 Nacos初始化 Nacos 数据库表nacos-db.sql 拉取镜像 创建挂载目录 application.properties 配置内容： 运行 Nacos 遇到的问题nacos 2.0 以下的版本不需要对外暴露 9848 端口，nacos 2.0 以上版本因为新增了 gRPC 的通信方式，与客户端通信新增了一个 9848 端口（在主端口的基础上偏移 1000）。 nacos 2.0 版本的端口介绍： 端口 与主端口的偏移量 描述 9848 1000 客户端 gRPC 请求服务端端口，用于客户端向服务端发起连接和请求 9849 1001 服务端 gRPC 请求服务端端口，用于服务间同步等 7848 -1000 Jraft 请求服务端端口，用于处理服务端间的 Raft 相关请求 部署 RabbitMQ拉取镜像 创建容器 RABBITMQ_DEFAULT_USER：登录 rabbitmq 管理页面的账号。 RABBITMQ_DEFAULT_PASS：登录 rabbitmq 管理页面的密码。 rabbitmq-management 插件提供了基于 HTTP 的 API 来管理及监控我们的 RabbitMQ 服务器，因此需要进入容器开启它。 创建完成后进入 rabbitmq 容器中： 执行以下命令，开启 rabbitmq_management 插件： 部署 ElasticSearch拉取镜像 创建容器 discovery.type&#x3D;single-node：单点模式启动。 ES_JAVA_OPTS&#x3D;”-Xms256m -Xmx256m”：设置 JVM 占用的内存范围。 &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config：es 存放配置文件的目录。 &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data：es 存放分片数据的目录。 &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins： es 存放插件的目录。 修改 ES 配置在 elasticsearch.yml 配置文件中添加以下配置，表示允许跨域请求： 注：修改了 es 的配置，需要重新 es 才能生效。 部署 Kibana拉取镜像 创建容器 修改 Kibana 配置在 kibana.yml 配置修改以下配置： 部署 es-head 监控插件拉取镜像 创建容器"},{"title":"【Docker】基本使用","date":"2024-02-25T01:00:00.000Z","url":"/blog/2024/02/25/Docker/Docker%E5%9F%BA%E7%A1%80/","tags":[["Docker","/blog/tags/Docker/"]],"categories":[["Docker","/blog/categories/Docker/"]],"content":"认识 Dockerdocker 概念 Docker 是一个开源的应用容器引擎。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。 容器是完全使用沙箱机制，相互隔离。 容器性能开销极低。 Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版） docker 架构 镜像（Image）：Docker 镜像，就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像和容器的关系，就像是面向对象程序设计中的类和对象一 样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心， 用来保存镜像。 Docker 命令docker 进程相关的命令启动 docker 服务 停止 docker 服务 重启 docker 服务 查看 docker 服务状态 开机启动 docker 服务 镜像相关的命令查看镜像查看本地所有的镜像 搜索镜像从网络中查找需要的镜像 拉取镜像从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。 删除镜像 删除本地镜像 容器相关的命令查看容器 创建容器创建并启动容器 -i：保持容器运行。 -t：为容器重新分配一个伪输入终端。 -d：以后台模式运行容器。 -it：创建的容器一般称为交互式容器。容器创建后自动进入容器中，退出容器后，容器自动关闭。 -id：创建的容器一般称为守护式容器。容器创建后不进入容器中，需要使用 docker exec 进入容器。退出后容器不会关闭。 –name：为创建的容器命名。 -v：配置数据卷，可以配置多个。 –volumes-from：继承其它容器的数据卷配置。 -p：端口映射。 –restart&#x3D;always：当 docker 重启时，容器会自动启动。 –privileged&#x3D;true：容器内的 root 拥有真正 root 权限，否则容器内 root 只是外部普通用户权限。 -e：设置默认参数。 进入容器 启动容器 停止容器 删除容器 注：正在运行的容器无法删除。 查看容器信息 查看数据卷映射信息： 查看容器日志 查看数据卷信息 只能查看根据宿主机目录相对路径创建的数据卷，默认情况下位于 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes 目录中。 Docker 容器数据卷数据卷概念及其作用数据卷的概念： 数据卷是宿主机中的一个目录或文件。 当容器目录和数据卷目录绑定后，对方的修改会立即同步。 一个数据卷可以被多个容器同时挂载。 一个容器也可以被挂载多个数据卷。 数据卷的作用： 容器数据持久化。 外部机器和容器间接通信 。 容器之间数据交换。 配置数据卷创建启动容器时，使用选项 -v 设置数据卷。 注意事项： 容器目录必须是绝对路径。 创建容器时，如果宿主机目录不存在，会自动创建。 如果缺少宿主机目录配置，创建容器时会自动在宿主机生成一个目录，用来映射容器目录。可以用 docker inspect 容器名称 查看该目录信息。 如果宿主机目录是相对路径，是相对于 /var/lib/docker/volumes 的目录。可以通过 docker inspect 容器名 命令查看挂载位置。 可以挂载多个数据卷。 配置数据卷容器如果同一镜像下不同的容器，数据卷的配置是相同的。那么可以先创建一个容器，之后创建容器时可以使用 --volumes-from 容器名 继承第一个容器的数据卷配置。例如： 如果宿主目录使用的是相对路径（路径不是以 / 开头），那么会挂载到 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes 目录下。 宿主目录使用相对路径挂载示例： DockerfileDocker 的镜像原理Linux 文件系统由 bootfs 和 rootfs 两部分组成： bootfs：包含 bootloader（引导加载程序）和 kernel（内核）。 rootfs： root 文件系统，包含的就是典型 Linux 系统中的 &#x2F;dev， &#x2F;proc，&#x2F;bin，&#x2F;etc 等标准目录和文件。 不同的 Linux 发行版，bootfs 基本一样，而 rootfs 不同，如 ubuntu ，centos 等。 Docker 的镜像原理： Docker 镜像是由特殊的文件系统叠加而成。 最底端是 bootfs，并使用宿主机的 bootfs。 第二层是 root 文件系统 rootfs，称为 base image。 然后再往上可以叠加其他的镜像文件。 统一文件系统技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角 ，这样就隐藏了多层的存在，在用户的角度看来，只存在 一个文件系统。 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。 当从一个镜像启动容器时，Docker 会在最顶层加载一个读写文件系统作为容器。 思考： Docker 镜像本质是什么？ 是一个分层文件系统。 Docker 中一个centos镜像为什么只有200MB，而一个 centos操作系统的iso文件要几个个G？ Centos 的 iso 镜像文件包含 bootfs 和 rootfs，而 docker 的 centos 镜像复用操作系统的 bootfs，只有 rootfs 和其他镜像层。 Docker 中一个tomcat镜像为什么有500MB，而一个 tomcat安装包只有70多MB？ 由于 docker 中镜像是分层的，tomcat 虽然只有 70 多 MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的 tomcat 镜像大小 500 多 MB。 制作镜像容器转为镜像第一步：docker commit 容器id 镜像名称:版本号，将容器转为镜像。 第二步：docker save -o 压缩文件名称 镜像名称:版本号，将镜像打包成压缩文件。 第三步：docker load –i 压缩文件名称，将压缩文件转为镜像。 注意：挂在数据卷上的容器目录&#x2F;文件并不会持久化在新的镜像中。其他对容器做的改变都会持久化在新的镜像中。 Dockerfile 制作镜像Dockerfile 概念和作用： Dockerfile 是一个文本文件，包含了一条条的指令，每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像。 对于开发人员来说，可以为开发团队提供一个完全一致的开发环境。 对于测试人员来说，可以直接拿开发时所构建的镜像或者通过 Dockerfile文件 构建一个新的镜像开始工作。 对于运维人员来说，在部署时，可以实现应用的无缝移植。 案例： 需求： 自定义 centos 7 镜像。 默认登录路径为 &#x2F;usr。 可以使用 vim。 实现步骤： 定义父镜像：FROM centos:7 执行安装vim命令： RUN yum install -y vim 定义默认的工作目录：WORKDIR &#x2F;usr 定义容器启动执行的命令：CMD &#x2F;bin&#x2F;bash 通过dockerfile构建镜像： Dockerfile 关键字： 关键字 作用 备注 FROM 指定父镜像 指定 dockerfile 基于哪个 image 构建 WORKDIR 工作目录 指定容器内部的工作目录，如果没有创建则自动创建。如果指定 &#x2F; 使用的是绝对地址，如果不是&#x2F;开头那么是在上一条 workdir 的路径的相对路径 COPY 给镜像添加文件 构建镜像的时候把指定宿主机的目录或文件复制到指定 image 的目录中。格式 COPY 文件名路径 目录路径 ADD 给镜像添加文件 构建镜像的时候，可以通过 url 给指定 image 的目录添加文件 RUN 执行命令 执行一段命令，默认是&#x2F;bin&#x2F;sh。格式：RUN command 或者 RUN [“command” , “param1”,”param2”] CMD 容器启动命令 运行容器时执行的命令，格式：CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”] NTRYPOINT 容器启动命令 跟CMD作用类似，一般在制作一些执行就关闭的容器中会使用 EXPOSE 暴露端口 提醒看 Dockerfile 的人，容器运行时会暴露哪些端口，配不配置 EXPOSE 都不影响使用 -p 映射端口。使用 EXPOSE 暴露的端口，在启动容器时，用 -p 将宿主机的端口跟 EXPOSE 暴露的端口进行绑定，这样对外就能访问容器的接口了。格式：EXPOSE 8080 或者 EXPOSE 8080&#x2F;udp VOLUME 暴露目录 提醒看 Dockerfile 的人，容器运行时可以映射哪些数据卷，配不配置都不影响使用 -v 映射数据卷。使用 VOLUME 暴露的目录路径，在启动容器时，用 -v 将宿主机的目录路径跟 VOLUME 暴露的目录路径进行绑定，这样在宿主机就能访问容器内的目录了。格式 VOLUME [“目录”] ENV 环境变量 构建镜像时，设置环境变量，在容器运行时全程生效，可以在启动容器时通过 -e 覆盖。格式：ENV name&#x3D;value ARG 构建参数 只在构建镜像的时候生效，运行容器时不生效。如果 ARG 的变量名跟 ENV 的变量名冲突，那么以 ENV 为准。可以在执行“docker build –build-arg key&#x3D;value”命令时指定 ARG 参数。格式：ARG name&#x3D;value ONBUILD 触发器 当存在 ONBUILD 关键字的镜像作为基础镜像的时候，执行FROM完成之后会执行 ONBUILD 的命令。格式：ONBUILD 其他命令 SHELL 指定执行脚本的shell 指定 RUN CMD ENTRYPOINT 执行命令的时候使用的 shell MAINTAINER 作者信息 用来标明这个 dockerfile 是谁写的 LABEL 标签 用来标明 dockerfile 的标签，可以使用 Label 代替 Maintainer，最终都是在 docker image 基本信息中可以查看 USER 指定执行用户 指定 build 或者启动的时候，用户在 RUN CMD ENTRYPONT 执行时的用户 使用 Dockerfile 部署 jar 包Linux Jdk 压缩包下载路径 Docker 私有仓库Docker 官方的 Docker hub 是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。 搭建私有仓库 上传镜像到私有仓库 从私有仓库拉取镜像 Docker 容器虚拟化与传统虚拟机比较容器就是将软件打包成标准化单元，以用于开发、交付和部署： 容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、 系统库和设置。 容器化软件在任何环境中都能够始终如一地运行。 容器赋予了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。 Docker 容器虚拟化与传统虚拟机比较： 相同： 容器和虚拟机具有相似的资源隔离和分配优势 不同： 容器虚拟化的是操作系统，虚拟机虚拟化的是硬件。 传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统。 "},{"title":"【Linux】搭建环境","date":"2024-02-23T06:00:00.000Z","url":"/blog/2024/02/23/Linux/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/","tags":[["Linux","/blog/tags/Linux/"]],"categories":[["Linux","/blog/categories/Linux/"]],"content":"搭建 Java 环境jdk 8 下载地址 将 jdk tar 包存放到 /usr/local/software/java 目录中。 解压命令：tar -zxvf jdk-8u401-linux-x64.tar.gz 配置环境变量，在 &#x2F;etc&#x2F;profile 文件末尾添加以下内容： 使 &#x2F;etc&#x2F;profile 文件生效：source /etc/profile 检查是否安装成功：java -version 搭建 Zookeeper 环境ZooKeeper 服务器是用 Java 编写的，它运行在 JVM 之上，所以需要安装 JDK 7 以上的版本。 Zookeeper 下载路径 将 zookeeper tar 包放到 /usr/local/softwawre/zookeeper 目录下。 解压 tar 包 创建 zoo.cfg 文件 修改 zoo.cfg 配置中的存储目录，先把 zkdata 目录创建出来： 也可以在 clientPort 修改 zookeeper 的端口。 启动 zookeeper 查看 zookeeper 服务状态 standalone 表示单节点，没有搭建集群。 zookeeper 集群： 在存储目录中创建 myid 文件，文件内容是服务器的编号。 在 zoo.cfg 配置文件中添加 zookeeper 服务器的 IP 列表。 搭建 MySQL 环境检查 MariaDB因为MariaDB 和 MySQL 有冲突，所以先检查一下是否有安装，如果有安装需要先卸载。 检查是否已经安装 MySQL MySQL 官网下载地址 搭建环境下载安装包 查看 Linux 的环境： centos 7 的安装选择如下： "},{"title":"【Linux】shell 编程","date":"2024-02-23T01:00:00.000Z","url":"/blog/2024/02/23/Linux/shell%E7%BC%96%E7%A8%8B/","tags":[["Linux","/blog/tags/Linux/"]],"categories":[["Linux","/blog/categories/Linux/"]],"content":"变量变量的定义和使用shell 定义变量的语法为：user_name=&quot;lin&quot;。使用变量的时候需要在变量名前加 $ 符号。 shell 变量名的规范： 变量名后面的等号左右不能有空格 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线 “_”。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 单引号、双引号、反引号的作用： 单引号是不能识别变量，只会原样输出。单引号是不能转义。 双引号能够识别变量，同时能够实现转义（类似于“\\n”）。 当在脚本中需要执行一些指令并且将执行的结果赋给变量的时候需要使用“反引号”。 只读变量定义只读变量：readonly user_name=&quot;lin&quot;。 接收用户输入语法：read -p 提示信息 变量名 删除变量语法：unset 变量名。 注：变量被删除后不能再次使用。unset 命令不能删除只读变量。 变量类型字符串变量在 shell 中，变量通常被视为字符串。可以使用单引号 ‘ 或双引号 “ 来定义字符串，例如： 单引号字符串限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。 双引号的优点：双引号能够识别变量，同时能够实现转义。 拼接字符串： 整数变量可以使用 declare 或 typeset 命令来声明整数变量，例如： 这样的声明将 my_integer 视为整数，如果尝试将非整数值赋给它，shell 会尝试将其转换为整数。 数组变量数组可以是整数索引数组或关联数组。 定义整数索引数组，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为 数组名=(值1 值2 ... 值n)，例如： 关联数组： 读取数组的方式：$&#123;数组名[下标]&#125;，使用 @ 符号可以获取数组中的所有元素，例如：$&#123;array_name[@]&#125; 环境变量环境变量是由操作系统或用户设置的特殊变量，用于配置 shell 的行为和影响其执行环境。例如，PATH 变量包含了操作系统搜索可执行文件的路径： 特殊变量有一些特殊变量在 shell 中具有特殊含义，例如 $0 表示脚本的名称，$1, $2, 等表示脚本的参数。$# 表示传递给脚本的参数数量，$? 表示上一个命令的退出状态等。 shell 注释单行注释以 # 开头。 多行注释还可以使用以下格式： 流程控制语句条件判定语句语法格式： 注：条件判定语句需要以 fi 作为结尾。 if else 的 […] 判断语句中大于使用 -gt，小于使用 -lt，等于用 **&#x3D;&#x3D;**。 如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 **&lt;**，等于还是用 **&#x3D;&#x3D;**。 "},{"title":"【Linux】权限管理","date":"2024-02-22T01:00:00.000Z","url":"/blog/2024/02/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","tags":[["Linux","/blog/tags/Linux/"]],"categories":[["Linux","/blog/categories/Linux/"]],"content":"权限概述Linux 系统将文件的操作权限的身份分为 3 个类别：owner、group、others，并且 3 种身份各有 read、write、execute 等权限。 权限介绍在多用户计算机系统的管理中，权限是指某个特定的用户具有特定的系统资源使用权力，像是文件夹、特定系统指令的使用或存储量的限制。 在 Linux 中分别有读、写、执行权限： 读权限： 对于文件夹来说，读权限影响用户是否能够列出目录结构。 对于文件来说，读权限影响用户是否可以查看文件内容。 写权限： 对文件夹来说，写权限影响用户是否可以在文件夹下“创建&#x2F;删除&#x2F;复制到&#x2F;移动到”文档。 对于文件来说，写权限影响用户是否可以编辑文件内容 执行权限： 一般都是对脚本文件来说。 身份介绍owner 身份owner 身份为文件所有者，默认为文档的创建者。 由于 Linux 是多用户、多任务的操作系统，因此可能常常有多人同时在某台主机上工作，但每个人均可在主机上设置文件的权限，让其成为个人的“私密文件”，即个人所有者。因为设置了适当的文件权限，除文件所有者之外的用户无法查看文件内容。 group 身份group 身份是与文件所有者同组的用户。 与文件所有者同组最有用的功能就体现在多个团队在同一台主机上开发资源的时候。例如主机上有 A、B 两个团体，A 中有 a1,a2,a3 三个成员，B 中有 b1,b2 两个成员，这两个团体要共同完成一份报告 F。由于设置了适当的权限，A、B 团体中的成员都能互相修改对方的数据，但是团体 C 的成员则不能修改 F 的内容，甚至连查看的权限都没有。同时，团体的成员也能设置自己的私密文件，让团队的其它成员也读取不了文件数据。在 Linux 中，每个账户支持多个用户组。如用户 a1、b1 即可属于 A 用户组，也能属于 B 用户组【主组和附加组】 others 身份others 身份是指不跟所有者同组的其它人。 root 用户root 用户就是 Linux 的超级用户，它是在所有用户中拥有最大权限的用户，能够管理普通用户。 Linux 的权限介绍Linux 中存在用户、用户组和其他人概念，各自有不同的权限，对于一个文档来说，其权限具体分配如下： 第 1 位：表示文档类型，取值常见的有“d 表示文件夹”、“- 表示文件”、“l 表示软连接”、“s 表示套接字”等等。 第 2-4 位：表示文档所有者的权限。 第 5-7 位：表示与所有者同在一个组的权限。 第 8-10 位：其他人的权限。 权限分配中,均是 rwx 的三个参数组合，且位置顺序不会变化。没有对应权限就用 – 代替。 注：文件夹没有读权限，即使文件夹中的文件有全部权限也无法访问该文件。 权限设置权限设置语法：chmod 选项 权限模式 文档路径 选项： -R：递归设置权限，当文档类型为文件夹的时候。 注：如果要给文档设置权限，操作者要么是 root 用户，要么就是文档的所有者。 权限模式-字母形式权限身份： u：表示 owner，给所有者身份设置权限。 g：表示 group，给所有者同组用户设置。 o：表示 others，给其他用户设置权限。 a：表示 all，给所有人设置权限。 权限字符： r：读。 w：写。 x：表示执行。 -：表示没有权限。 权限分配方式： +：表示给具体的用户新增权限（相对当前）。 -：表示删除用户的权限（相对当前）。 =：表示将权限设置成具体的值（注重结果）。 示例： 给 anaconda-ks.cfg 文件的 owner 添加执行权限，group 添加读、执行权限，others 添加读权限。 chmod u+x,g+rx,o+r anaconda-ks.cfg anaconda-ks.cfg 文件中的 owner 拥有全部权限，group 拥有读、执行权限，others 拥有读权限。 chmod u=rwx,g=rx,o=r anaconda-ks.cfg 注：chmod ug=rwx 形式，如果有两部分权限一样则可以合在一起写。 注：当文件拥有执行权限（任意部分），则其颜色在终端中是绿色。 权限模式-数字形式每个数字代表的含义： 读（r）：4 写（w）：2 执行（x）：1 没有任何权限：0 全部权限：读 + 写 + 执行&#x3D;4+2+1&#x3D;7 读和执行：读 + 执行&#x3D;4+1&#x3D;5 读权限：读&#x3D;4 实例： 赋予 owner、group、others 全部权限： chmod 777 a.txt 属主与属组设置属主：文件所属的用户（创建文件的用户）。 属组：文件所属的用户组。 前一个 root 就是属主，后一个 root 就是属组。这两项信息在文档创建的时候会使用创建者的信息（用户名、用户所属的主组名称）。如果删除某个用户，则该用户对应的文档的属主和属组信息就需要去修改。 chown作用：更改文档的所属用户。 语法：chown -R username 文档路径 注：通过一个命令实现既可以更改所属的用户，也可以修改所属的用户组。语法：chown -R username:groupname 文档路径。 chgrp作用：更改文档的所属用户组。 语法：chgrp -R groupname 文档的路径 扩展目前普通用户无法执行 reboot、shutdown 等指令。可以让管理员（root）事先定义某些特殊命令谁可以执行，然后用户使用 sudo 即可执行对于的指令。 操作方式： 第一步：修改 sudo 配置文件需要使用 visudo 指令，用 vim /etc/sudoers 是无法修改 sudo 配置文件。 第二步：配置普通用户的权限： root 表示用户名，如果是用户组，可以写成 %组名。 第一个 ALL 表示允许登录的远程主机，地址白名单。 第二个 (ALL) 表示以谁的身份执行命令， ALL 表示 root 身份。 第三个 ALL 表示当前用户可以执行的命令，多个命令可以用 , 分割。不建议写直接形式的指令，而是写指令的完整路径。命令的完整路径可以用 which 指令名称 查询。 第三步：对应用户使用 sudo 执行对应指令。如： sudo 需要执行的指令。在输入 sudo 指令之后需要输入当前的用户密码进行确认的操作，输入之后在接下来 5 分钟内再次执行 sudo 指令不需要密码。 注：普通用户可以使用 sudo -l 查看自己具有哪些特殊权限。"},{"title":"【Linux】系统管理","date":"2024-02-21T06:00:00.000Z","url":"/blog/2024/02/21/Linux/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/","tags":[["Linux","/blog/tags/Linux/"]],"categories":[["Linux","/blog/categories/Linux/"]],"content":"运行级别Linux 系统有 7 种运行级别，常用的级别是 3 和 5。 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动。 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆。 运行级别2：多用户状态（没有NFS，网络文件系统），不支持网络。 运行级别3：完全的多用户状态（有NFS），登陆后进入控制台命令行模式。 运行级别4：系统未使用，保留。运行级别5：X11 控制台，登陆后进入图形 GUI 模式。 运行级别6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动。 centos 7 的运行级别简化为：multi-user.target 等价于原运行级别 3。 graphical.target 等价于原运行级别 5。 查看当前运行级别systemctl get-default 修改运行级别systemctl set-default 运行级别 用户与用户组管理概述Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个惟一的用户名和各自的密码。用户在登录时键入正确的用户名和密码后，就能够进入系统和自己的主目录。 要想实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除、修改以及用户密码的管理。 用户组的管理。 三个关键文件： &#x2F;etc&#x2F;passwd：存储用户的关键信息 &#x2F;etc&#x2F;group：存储用户组的关键信息 &#x2F;etc&#x2F;shadow：存储用户的密码信息 passwd 文件结构： passwd 文件的数据格式：用户名:密码:用户ID:用户组ID:注释:家目录:解释器 shell 用户名：创建新用户名称，后期登录时需要输入。 密码：此密码位置一般情况都是 “x”，表示密码的占位。 用户 ID：用户的唯一标识符。 用户组 ID：该用户所属的主组 ID。 注释：解释该用户的作用是什么。 家目录：用户进入系统后默认的工作目录。 解释器 shell：用户输入指令后，该解释器会收集用户输入的指令，传递给内核处理。 group 文件结构： group 文件的数据格式：用户组名:密码:用户组ID:组内用户名 密码：X表示占位符，虽然用户组可以设置密码，但是绝大部分的情况下不设置密码。 组内用户名：表示附加组是该组的用户名称。 用户管理添加用户语法：useradd 选项 用户名。 选项： -g：用于指定用户的用户主组，选项的值可以是用户组的 id，也可以是组名。 -G：用于指定用户的用户附加组，选项的值可以是用户组的 id，也可以是组名。 -u：用户的 id，系统默认会从 500 之后按顺序分配 uid，如果不想使用系统分配，可以通过该选项自定义。 -c：添加注释。 注：在不添加选项的时候，执行 useradd 之后会进行两个操作：创建同名的家目录、创建同名的用户组。 修改用户语法：usermod 选项 用户名。 选项： -g：用于指定用户的用户主组，选项的值可以是用户组的 id，也可以是组名。 -G：用于指定用户的用户附加组，选项的值可以是用户组的 id，也可以是组名。 -u：用户的 id，系统默认会从 500 之后按顺序分配 uid，如果不想使用系统分配，可以通过该选项自定义。 -l：修改用户名 设置密码语法：passwd 用户名。 设置密码后在 shadow 文件体现： 删除用户语法：userdel 选项 用户名。 选项： -r：表示删除用户的同时，删除其家目录。 注：删除登录中的用户会提示失败。可以 kill 对应用户的全部进程。 切换用户语法：su 用户名，如果不指定用户名则表示切换到 root 用户。 退出语法：exit。 注： 从 root 往普通用户切换不需要密码，但是反之则需要root密码。 切换用户之后前后的工作路径是不变的。 普通用户没有办法访问 root 用户家目录，但是反之则可以。 用户组管理添加用户组语法：groupadd 选项 用户组名。 选项： -g：类似用户添加里的 -u，-g 表示自己设置一个自定义的用户组 id 数字，如果自己不指定，则默认从500之后递增。 编辑用户组语法：groupdel 用户组名。 选项： -g：类似用户修改里的 -u，-g 表示自己设置一个自定义的用户组 id 数字。 -n：类似于用户修改 -l，表示设置新的用户组名称。 删除用户组语法：groupdel 用户组名 注：如果需要删除一个组，但是这个组是某个用户的主组时，则不允许删除；如果确实需要删除，则先从组内移出所有用户。 ssh 服务查看 ssh 服务执行情况：systemctl status/start/stop sshd 修改主机名临时修改主机名：hostname 设置的主机名，需要切换用户使之生效。 永久修改主机名：修改 /etc/hostname 配置文件的内容，需要重启（reboot）。 注：如果永久修改主机名，需要将修改后的主机域名添加到 /etc/hosts 配置文件中的 127.0.0.1 末尾。否则可能会出现以下问题： 如果不设置则会影响本地域名的解析。 很多开源服务器软件（例如 Apache）则无法启动，或出现报错。 防火墙服务操作防火墙systemctl status/start/stop firewalld.service 操作端口开放 5672 端口：firewall-cmd --zone=public --add-port=5672/tcp --permanent 关闭 5672 端口：firewall-cmd --zone=public --remove-port=5672/tcp --permanent 配置立即生效：firewall-cmd --reload 查看防火墙所有开放的端口firewall-cmd --zone=public --list-ports 查看监听的端口netstat -lnpt rpm 管理（重点）rpm 作用：对 Linux 服务器上的软件包进行对应管理操作，管理分为：查询、卸载、安装。 查询某个软件的安装情况语法：rpm -qa|grep 关键词。 选项： -q：选项。 -a：全部。 卸载软件语法：rpm -e 软件的名称。 注：如果软件有依赖关系则无法卸载，如果还要卸载可以添加 --nodeps。例如：rpm -e 软件包名 --nodeps。 crontab 计划任务（重点）crontab 作用：执行定时任务。 选项： -l：列出指定用户的计划任务列表。 -e：编辑指定用户的计划任务列表。 -u：指定的用户名，如果不指定，则表示当前用户。 -r：删除指定用户的计划任务列表。 编辑计划任务书计划任务的语法格式，以行为单位，一行则为一个计划：分 时 日 月 周 需要执行的命令。 取值范围： 分：0~59 时：0~23 日：1~31 月：1~12 周：0~7，0和7表示星期天 四个符号： *：表示取值范围中的每一个数字。 -：做连续区间表达式的，要想表示1~7，则可以写成：1-7。 /：表示每多少个，例如：想每10分钟一次，则可以在分的位置写：*&#x2F;10。 ,：表示多个取值，比如想在1点，2点6点执行，则可以在时的位置写：1,2,6。 练习： 问题1：每月1、10、22日的4:45重启network服务 45 4 1,10,22 * * service network restart 问题2：每周六、周日的1:10重启network服务 10 1 * * 6,0 service network restart 问题3：每天18:00至23:00之间每隔30分钟重启network服务 *&#x2F;30 18-23 * * * service network restart 问题4：每隔两天的上午8点到11点的第3和第15分钟执行一次重启 3,15 8-11 *&#x2F;2 * * reboot crontab 权限问题默认情况是任何用户都可以创建自己的计划任务，但是超级管理员可以通过配置来设置某些用户不允许设置计划任务。在配置文件 /etc/cron.deny 编辑，一行一个用户名。加入黑名单后，用户编辑的效果图如下： 此外还有一个白名单配置文件 /etc/cron.allow，本身不存在，需要自己创建。 注：白名单优先级高于黑名单，如果一个用户同时存在两个名单文件中，则会被默认允许创建计划任务。"},{"title":"【Linux】vim 编辑器","date":"2024-02-21T01:00:00.000Z","url":"/blog/2024/02/21/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8/","tags":[["Linux","/blog/tags/Linux/"]],"categories":[["Linux","/blog/categories/Linux/"]],"content":"vi 介绍vi 编辑器是所有 Unix 及 Linux 系统下标准的文本编辑器。由于在 Unix 及 Linux 系统的任何版本，vi 编辑器是完全相同的，因此可以在其它任何介绍 vi 的地方了解它。vi 也是 Linux 中最基本的文本编辑器，学会它后，我们将在 Linux 的世界里畅行无阻，尤其是在终端中。 vi 和 vim 都是 Linux 中的编辑器，不同的是，vim 比较高级，可以视为 vi 的升级版本。vi 使用于文本编辑，但是vim更适用于写代码的。 vim 重点是光标的移动，模式切换，删除，查找，替换，复制，粘贴，撤销命令的使用。 vim 三种模式vim 的三种模式：命令模式、编辑模式、末行模式。 命令模式：在该模式下是不能对文件直接编辑，可以输入快捷键进行一些操作（删除行，复制行，移动光标，粘贴等等）。 编辑模式：在该模式下可以对文件的内容进行编辑。 末行模式：可以在末行输入命令来对文件进行操作（搜索、替换、保存、退出、撤销、高亮等等）。 模式间的切换 命令模式 -&gt; 编辑模式：i 编辑模式 -&gt; 命令模式：esc 命令模式 -&gt; 末行模式：：英文 末行模式 -&gt; 命令模式：esc 命令模式光标移动光标移动到行首：shift + 6 光标移动到行尾：shift + 4 光标移动到首行：gg 光标移动到末行：G 向上翻屏：ctrl + b 向下翻屏：ctrl + f 快速将光标移动到指定行：数字 + G 以当前光标为准向上&#x2F;向下移动 n 行：数字 + ↑，数字 + ↓ 复制操作复制光标所在行：yy 以光标所在行为准（包含当前行），向下复制指定的行数：数字 + yy 可视化复制：ctrl + v，然后按下 ↑↓←→ 方向键来选中需要复制的区块，按下 y 键进行复制。 粘贴：p 剪切&#x2F;删除剪切&#x2F;删除光标所在行：dd 剪切&#x2F;删除光标所在的当前以及行之后的内容，删除之后下一行上移：数字 + dd 剪切&#x2F;删除光标所在的当前以及行之后的内容，但是删除之后下一行不上移：D 可视化删除：ctrl + v，然后按下 ↑↓←→ 方向键来选中需要删除的区块。按下D表示删除选中行，d表示删选中块。 撤销&#x2F;恢复撤销：u 恢复：ctrl + r 末行模式保持操作保持文件：:w 另存为：:w 文件路径 退出退出文件：:q 强制退出：:q!，做的修改不保存。 搜索&#x2F;查找搜索&#x2F;查找：/关键词 切换上下结果：N/n 取消高亮：:nohl 替换： 替换光标所在行的第一处符合条件的内容：:s/搜索的关键词/新的内容 替换光标所在行的全部符合条件的内容：:s/搜索的关键词/新的内容/g 替换整个文档中每行第一个符合条件的内容：:%s/搜索的关键词/新的内容 替换整个文档的符合条件的内容：:%s/搜索的关键词/新的内容/g % 表示整个文件 g 表示全局（global） 显示行号显示行号：:set nu 取消显示：:set nonu 实用功能代码着色显示：:syntax on 关闭显示：:syntax off vim 中使用计算器 进入编辑模式 按下按键 ctrl + r，然后输入 =，此时光标会变到最后一行 输入需要计算的内容，按下回车 vim 的扩展vim 的配置vim 的配置有三种情况： 在末行模式下输入的配置，临时的。 个人配置文件（~&#x2F;.vimrc），如果没有可以自行新建。 全局配置文件（&#x2F;etc&#x2F;vimrc） 注：如果某个配置项，在个人配置与全局配置产生冲突的时候，以个人配置为准。 异常退出在编辑文件之后并没有正常的去 wq，而是遇到突然关闭终端或者断电的情况，则会显示下面的效果： 解决方式：将交换文件（在编程过程中产生的临时文件）删除即可。 退出方式vim 的退出方式除了 :q 和 :wq，还有第三种方式 :x。 :x 文件没有修改的情况下，表示直接退出，在文件修改的情况下表示保存并退出。 如果文件没有被修改，但是使用 wq 进行退出的话，则文件的修改时间会被更新；但是如果文件没有被修改，使用 x 进行退出的话，则文件修改时间不会被更新的； 建议以后都使用 :x 对文件保存退出。 注：不要使用 X，X 表示对文件进行加密操作。"},{"title":"【Linux】常用命令","date":"2024-02-20T01:00:00.000Z","url":"/blog/2024/02/20/Linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["Linux","/blog/tags/Linux/"]],"categories":[["Linux","/blog/categories/Linux/"]],"content":"Linux 系统的文件目录结构 bin：该目录中存储的都是一些二进制文件，文件都是可以被运行的； dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载； etc：该目录主要存储一些配置文件； home：该目录存储了除 root 用户以外其他用户的家目录； proc：全称 process，表示进程。该目录存储的是 Linux 运行时的进程； root：该目录是 root 用户的家目录； sbin：全称 super binary。该目录也存储了一些可被执行的二进制文件，但是必须拥有 super 权限的用户才能执行； tmp：当系统运行时产生的临时文件会存储在这个目录； 基础指令ls 指令作用：列出指定路径下的所有文件&#x2F;文件夹的名称。 操作对象：路径（默认为当前路径）。 选项： -l：表示以详细列表的形式进行展示。 -a：表示显示所有的文件&#x2F;文件夹（包含了隐藏文件&#x2F;文件夹）。 -lh：列出指定路径下的所有文件&#x2F;文件夹的名称，以列表的形式展示，并且在显示文档大小的时候以可读性较高的形式显示。 pwd 指令作用：打印当前工作目录。 cd 指令作用：用于切换当前的工作目录。 操作对象：相对路径&#x2F;绝对路径。 mkdir 指令作用：根据路径创建目录。 操作对象：相对路径&#x2F;绝对路径（可以有多个路径）。 选项： -p：一次性创建多层不存在的目录。 touch 指令作用：创建文件。 操作对象：文件路径。 cp 指令作用：复制文件&#x2F;文件夹到指定的位置。 操作对象：被复制的路径 复制到的路径。 选项： -r：表示递归复制，复制文件夹的时候需要添加该选项，否则目录将被忽视。 注：Linux 在复制过程中是可以重新对新位置的文件&#x2F;文件夹进行重命名的，如果不需要重命名，复制路径为指定目录即可。 mv 指令作用：移动文件&#x2F;文件夹到指定目录。 操作对象：需要移动的路径 需要保存的位置路径。 注1：移动之后，原始的文件&#x2F;文件夹不在原来的位置。 注2：mv 指令也可以对文件&#x2F;文件夹改名，修改方式跟 cp 指令一样。 rm 指令作用：删除文件&#x2F;文件夹。 操作对象：路径。 选项： -f：强制删除，不会提醒是否要删除。 -r：表示递归。 vim 指令作用：文本编辑器。 操作对象：文件路径。 输出重定向输出重定向：大部分命令的执行结果在终端输出，输出重定向可以将命令的执行结果保存到文件中。 重定向符号： &gt;：覆盖重定向。会覆盖掉原先的文件内容。 &gt;&gt;：追加重定向。不会覆盖原文件内容，会在原有内容的末尾继续添加。 注：文件可以不存在，不存在则会新建文件。 cat 指令作用：查询指定文件的内容。 操作对象：文件路径。 进阶指令df 指令作用：查看磁盘空间。 选项： -h：表示以可读性较高的形式展示磁盘空间大小。 free 指令作用：查看内存使用情况。 选项： -m：表示以 mb 为单位查看。 head 指令作用：查看一个文件前 n 行的内容，如果不指定 n，则默认显示前 10 行内容。 操作对象：文件路径。 选项： -n：n 为数字，表示显示前 n 行内容。 tail 指令作用：查看一个文件最后 n 行的内容，如果不指定 n，则默认显示最后 10 行内容。 操作对象：文件路径。 选项： -n：n 为数字，表示显示最后 n 行内容。 -f：查看文件末尾动态变化的内容（变化的内容不能是用户手动增加的）。 less 指令作用：查看文件，以较少的内容进行输出。 操作对象：文件路径。 注：less 指令的功能比较强大，点击查看详细操作 wc 指令作用：统计文件内容信息（如：行数、单词数、字节数） 操作对象：文件路径。 选项： -l：统计行数。 -w：统计单词数，依据空格来判定单词熟练。 -c：统计字节数。 date 指令作用：读取或设置日期时间。 选项： -d + 字符串： 操作日期时间，对年月日时分秒进行加减。例如：date -d &quot;-1 year -1 month -1 day -1 hour -1 minute -1 second&quot; +&quot;%F %T&quot;。 也可以进行时间格式转化。例如：date -d &quot;2023-01-01 12:00:00&quot; +&quot;%Y年%m月%d日 %H时%M分%S秒&quot;。 &#39;+&#39; + 字符串：按指定格式输出日期时间。 %F：表示完整的年月日 %T：表示完整的时分秒 %Y：表示四位年份 %m：表示两位月份（带前导0，%-m不带前导0） %d：表示日期（带前导0，%-d不带前导0） %H：表示小时（带前导0，%-H不带前导0） %M：表示分钟（带前导0，%-M不带前导0） %S：表示秒数（带前导0，%-S不带前导0） 注：点击查看更详细的操作。 cal 指令作用：输出日历信息。 选项： -3：表示输出上一个月+本月+下个月的日历。 -y：表示输出某一个年份的日历。 clear&#x2F;ctrl + L 指令作用：清除终端中已经存在的命令和结果。 注：该命令并不是真的清除了之前的信息，而是把之前的信息隐藏到了最上面，通过滚动条可以继续查看之前的信息。 管道（|）作用：前一个指令的输出结果作为后一个指令的输入。 高级指令hostname 指令作用：查询或设置服务器的主机名。 选项： -f：输出当前主机名中的全限定域名。 id 指令作用：查看一个用户的基本信息（包含用户id，用户组id，附加组id等等），该指令如果不指定用户则默认当前用户。 操作对象：用户名。 whoami 指令作用：获取当前登录的用户名。一般用于 shell 脚本，用于获取当前操作的用户名方便记录日志。 ps -ef 指令作用：查看服务器的进程信息。 选项： -e：列出全部的进程。 -f：显示全部字段。 表头含义： UID：执行该进程的用户 id。 PID：进程 id。 PPID：该进程的父进程 id。如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程。 C：cpu 的占用率，其形式是百分数。 STIME：启动时间。 TTY：终端设备，发起该进程的设备标识符，如果显示”？“则表示该进程并不是由终端设备发起。 TIME：进程的执行时间。 CMD：该进程的名称或对应的路径。 top 指令作用：查看进程占用服务器资源的情况。 表头含义： PID：进程 id。 USER：执行该进程的用户。 PR：进程优先级。 VIRT：虚拟内存。 RES：常驻内存。 SHR：共享内存。计算一个进程实际使用的内存 &#x3D; 常驻内存（RES）- 共享内存（SHR）。 S：表示进程的状态 status（其中S表示睡眠，R表示运行）。 %CPU：表示 CPU 的占用百分比。 %MEM：表示内存的占用百分比。 TIME+：进程的执行时间。 COMMAND：进程的名称或路径。 运行时可执行的操作： M：将结果按内容（MEM）从高到低降序排序。 P：将结果按 CPU 使用率从高到低降序排序。 1：显示各个 CPU 的详细信息。 du -sh 指令作用：查看目录的实际大小。 操作对象：文件夹路径。 选项： -s：只显示汇总的大小。 -h：以高可读性的形式显示。 find 指令作用：用于查找文件。 操作对象：文件夹的目录。 选项： -name：按文档名称搜索（支持模糊查询）。 -type：按文档类型搜索（f 为文件类型，d 为文件夹类型）。 service 指令作用：启动&#x2F;停止&#x2F;重启 Linux 中的服务。 语法：service 服务名 start/stop/restart kill 指令作用：杀死进程。 操作对象：进程 PID killall 指令作用：杀死进程。 操作对象：进程名称。 ifconfig 指令作用：获取网卡信息。 ens33：ens33 是 Linux 中的一个网卡，inet 指该网卡的 ip 地址。 lo：全称 local，本地环回接口，也是 Linux 的一个网卡，ip 地址一般为 127.0.0.1。 reboot 指令作用：重启计算机。 选项： -w：模拟重启，但是不重启，是输出关机与开机的日志信息。 shutdown 指令作用：关机。 选项： -h + 时间：定时关机。例如：shutdown -h 15:25 “关机提示”。 注：如果想取消关机计划，输入shutdown -c。 uptime 指令作用：输出计算机持续在线的时间。 uname 指令作用：获取计算机操作系统相关信息。 选项： -a：获取全部系统信息（类型、全部主机名、内核版本、发布时间、开源计划）。 man 指令作用：查询 Linux 指令的用法。 操作对象：Linux 指令名称。 网络相关的指令ping 指令作用：检测当前主机与目标主机之间的连通性。不是 100% 准确，有的服务器是禁 ping。 操作对象：主机地址（ip地址、主机名、域名等）。 例如：ping www.baidu.com. netstat 指令作用：查看网络的连接信息。 选项： -t：表示只列出 tcp 协议的连接。 -n：表示将地址从字母组合转化成 ip 地址，将协议转化成端口号来显示。 -l：表示过滤出“state（状态）”列中其值为 LISTEN（监听）的连接。 -p：表示显示发起连接的进程pid和进程名称。 -a：列出全部信息。 traceroute 指令作用：查找当前主机与目标主机之间所有的网关。 操作对象：主机地址（ip地址、主机名、域名等）。 arp 指令作用：根据 IP 地址获取（MAC）物理地址的协议。 选项： -a 查看本地缓存mac表。 -d 主机地址：删除指定的缓存记录。 扩展别名机制：创建一些属于自定义的命令。 操作：修改 ~/.bashrc 配置文件。添加alias cls=&#39;clear&#39;，在终端输入 cls 等同于 clear 指令。 注：如果想新创造的命令生效，必须要重新登录当前用户。"},{"title":"【Python】面向对象编程","date":"2023-12-23T16:00:00.000Z","url":"/blog/2023/12/24/Python/06_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","tags":[["Python","/blog/tags/Python/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"基础概念对象在 Python 中，万物皆对象，包括数据类型，函数，类等等一切可操作的基本单元在 Python 中都使用对象表示。每个对象有三个基本属性：ID，类型和值： 类型一个对象必须有 Type 属性。Type 属性决定了这个对象支持的属性和行为。type() 内置方法获取对象的类型： 类在 Python 中定义一个新类（Class）等于创建了一个新类型（Type）的对象。通过 class 关键字可以定义类： 对象之间的关联关系Python 把对象分为两类，类型对象（Type）和非类型对象（Non-type）。 类型对象之间存在继承关系，类型对象和非类型对象之间存在实例关系。 类和实例定义类在 Python 中，定义类是通过 class 关键字： class 后面的 Student 是类名，类名通常是大写开头的单词。紧接着是 (object)，表示该类是从哪个类继承下来的。object 类是所有类最终都会继承的类。 创建实例创建实例通过类名 + () 实现： __init__在创建实例的时候，__init__ 可以把一些必须绑定的属性强制填写进去： 和普通函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量 self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，定义时仍然可以用默认参数、可变参数 、关键字参数和命名关键字参数。 类结构定义类属性实例属性：通过 self 变量绑定的属性为实例属性。 类属性：在类中直接定义的属性为类属性。 访问类属性访问方式：类名.属性名 定义类私有属性类的私有属性以两个下划线 “__” 开头，私有属性不能通过类名直接访问，只能通过类方法访问： 定义类方法类方法的第一个参数总是 cls，它指类自身，在调用时被隐式传递，声明类方法必须加上 @classmethod 装饰器说明符： 定义类的静态方法使用 @staticmethod 装饰器定义类的静态方法： 类的静态方法无法访问类属性。另外，无论是类方法还是类的静态方法都只能通过类名加 ‘.’ 的方式调用，不能间接调用它们。 获取对象信息使用 dir() 查询对象的所有属性和方法，使用 getattr()、setattr() 以及 hasattr() 方法，可以直接操作一个对象的状态。 dir()查询一个对象的所有属性和方法，包括私有属性和私有方法： hasattr()判断对象是否有指定的变量： getattr()获取对象中的数据： setattr()给对象设置属性： 给对象设置方法： 注：动态添加的实例方法不能访问实例私有属性。 封装定义私有属性在 Python 中，实例变量如果以 __ 开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 访问或修改私有属性在类中对外提供访问和修改私有属性的方法： 注_1：在 Python 中，变量名类似 __xxx__ 的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量。 注_2：如果是一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的。但是，按照约定俗成的规定，当看到这样的变量时，当作私有变量，不要在外部访问。 继承但定义一个 class 的时候，可以从某个现有的 class 继承，新的 class 称为子类，而被继承的 class 称父类。 实现继承定义父类： 定义子类，子类继承父类： 继承的作用：子类获得了父类的全部功能，并且允许子类对代码改进。 多继承Python 支持多继承，多继承的实现方式如下： 方法 F.mro() 和 变量 F.__mro__ 都能查看类的多继承顺序。 多继承的顺序python2.3 以后的版本里，多继承顺序都是通过 C3 linearization 的方法计算得到： 把 L[C] 定义为类 C 的 linearization 值(也就是 MRO 里的继承顺序，后面简称L值)，L[C] 等于 C 的所有上一级父类的 L 值的融合，融合的逻辑我们在下面的计算过程中解释： 把 object 类的 L 值定义为 O，即 L(object) &#x3D; O。 L(A) &#x3D; A + merge( L(object) ) &#x3D; A + merge(O) &#x3D; AO。A的继承顺序是AO。同理 L(B) &#x3D; BO。 L(C) &#x3D; C + merge( L(B) ) &#x3D; C + merge( BO ) &#x3D; CBO。C 的继承顺序是 CBO。 L(D) &#x3D; D + merge( L(A) + L(B) + AB) &#x3D; D + merge( AO + BO + AB) &#x3D; D + A + merge( O + BO + B) &#x3D; D + A + B + merge( O + O ) &#x3D; DABO。 L(D) &#x3D; D + merge( AO + BO + AB)。融合的逻辑，merge函数里，即从左到右，选出第一个没有被 merge 函数里其他类继承的类，提取到 merge 函数外，这里我们首先找到 A 既没有被 O 继承，也没有被 B 继承，所以首先提取到外面，即 merge( AO + BO + AB) &#x3D; A + merge( O + BO + B)。 用相同的逻辑计算 L(E) 计算 L(F) 多态多态：一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。 多态的好处：当传入 Dog、Cat ……时，只需要接收 Animal 类型就可以了，然后，按照 Animal 类型进行操作即可。由于 Animal 类型有 run() 方法，因此，传入的任意类型，只要是 Animal 类或者子类，就会自动调用实际类型的 run() 方法，这就是多态。 动态添加属性和方法可以为已定义的类动态的绑定新的属性和方法。 动态添加类属性动态添加类属性：类名.属性名 &#x3D; 值 注：不能动态添加私有类属性。 动态添加类方法 注：动态添加的类方法不能访问类私有属性。 动态添加实例属性 注：不能动态添加私有实例属性。 动态添加实例方法动态添加实例方法，作用访问全部对象。 动态添加实例方法，只针对某个对象添加实例方法。 注：动态添加的实例方法不能访问实例私有属性。"},{"title":"【Python】高级特性","date":"2023-12-22T16:00:00.000Z","url":"/blog/2023/12/23/Python/04_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/","tags":[["Python","/blog/tags/Python/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"切片切片是为了取 list、tuple、str 部分元素的操作。 L[x, y] 表示从索引 x 开始取，直到索引 y 为止，但不包括索引 y。 L[x, y, n] 表示从索引 x 到索引 y 为之间的元素，每 n 个取一个元素，但不包括索引 y。 Python 支持 L[-1] 取倒数第一个元素，那么它同样支持倒数切片。L[x, y, n] 三个参数都可以为负数。 列表生成式列表生成式是用来创建 list 数据的生成式。 列表生成式由三部分组成：[map cycle filter]，其中 cycle 是 for 循环表达式，用于创建原始数据。filter 用来过滤原始数据，可以省略。map 是对原始数据进行映射操作，映射后的数据作为 list 数据。 for 循环可以同时使用两个甚至多个变量： 生成器列表生成式是一次性获取全部 list 数据，生成器是根据某种算法一个一个地获取 list 中的数据。生成器实际上保存的是算法。 生成器的定义有两种定义方式： 第一种：把列表生成式 [map cycle filter] 中的 [] 改成 () 第二种：函数定义中包含 yield 关键字，那么这个函数就不再是一个普通函数，而是一个生成器函数。调用一个生成器函数将返回一个生成器对象。 普通函数跟生成器函数的执行流程不一样。普通函数是顺序执行，遇到 return 语句或者最后一行函数语句就返回。而生成器函数，在每次调用 next() 的时候执行，遇到 yield 语句返回，再次执行时从上次返回的 yield 语句处继续执行。 注意：调用生成器函数会创建一个生成器对象，多次调用生成器函数会创建多个相互独立的生成器对象。 遍历生成器遍历生成器有两种方式，一种是调用 next() 函数，但是写代码不会用这种方式。另一种是用 for 循环。 迭代器什么是迭代器直接作用于 for 循环的对象统称为可迭代对象 Iterable ，例如：list、tuple、dict、set、str等。 可以被 next() 函数调用并不断返回下一个值的对象称为迭代器 Iterator ，例如生成器：generator。 Iterator 对象的特征：Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。"},{"title":"【Python】函数式编程","date":"2023-12-22T16:00:00.000Z","url":"/blog/2023/12/23/Python/05_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","tags":[["Python","/blog/tags/Python/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"匿名函数匿名函数指没有函数名的函数。用关键字 lambda 表示匿名函数，例如： 匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果。 返回函数函数作为返回值在 Python 中，函数也是一个对象，也是可以作为返回值。 闭包闭包：当外部函数返回内部函数时，外部函数的相关参数和变量都保存在内部函数中，称为“闭包”。 注意：返回函数不要引用任何循环变量，或者后续会发生变化的变量。否则会出现以下问题： 结果不是 f1=1, f2=4, f3=9 ，原因就在于返回的函数引用了变量 i，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量i 已经变成了 3，因此最终结果为 9。 如果一定要引用循环变量或后续会发生改变的变量，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： nonlocal如下，使用闭包，如果对外层变量赋值，Python 解释器会把 x 当作函数 fn() 的局部变量，但是 fn() 并没有声明局部变量 x，因此会报错。 加上 nonlocal 声明后，解释器会把 fn() 的 x 看作外层函数的局部变量，再赋值不会报错。 注：内部函数对外部变量的操作，不影响外部变量指向的对象，即便外部变量指向的是可变对象。 装饰器装饰器的作用装饰器的作用：在不改变函数体的情况下，增强函数的功能。 例如：希望函数执行前打印执行时间。 @log 放到 now() 函数的定义处，相当于执行了语句： 由于 log() 是一个 decorator，返回一个函数。所以，原来的 now() 函数仍然存在，只是现在同名的 now 变量指向了新的函数，即在 log() 函数中返回的 wrapper() 函数。 装饰器 decorator 的本质：一个返回函数的高阶函数。 装饰器传参如果 decorator 本身需要传入参数，那就需要编写一个返回 decorator 的高阶函数，要自定义log的文本： 与 2 层嵌套的 decorator 相比，3 层嵌套的效果是这样的： __name__每个函数都有自己名字，通过变量 __name__ 获取。装饰器的作用是让同名函数指向新的函数，此时再获取 __name__ ，获取的是新函数的 __name__ 。如果希望获取的是原函数的 __name__ ，就需要使用 functools.wraps 注解。因此完整的装饰器代码如下： 偏函数定义函数的时候，通过设定参数的默认值，可以降低函数调用的难度。 偏函数的作用是在定义好的函数的基础上设定参数的默认值： 创建偏函数时，实际上可以接收函数对象、*args 和 **kw 这3个参数。*args 参数会自动加到左边。例如： "},{"title":"【Python】函数","date":"2023-12-20T16:00:00.000Z","url":"/blog/2023/12/21/Python/03_%E5%87%BD%E6%95%B0/Python%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/","tags":[["Python","/blog/tags/Python/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"定义函数定义函数使用 def 语句，依次写出函数名、括号、括号中的参数和冒号: ，然后编写函数体。 定义空函数 调用函数调用函数函数名+参数 参数检查调用函数时，如果参数个数不对，Python 解释器会抛出 TypeError： 返回多个值实际返回值是一个 tuple，而多个变量可以同时接受一个 tuple： 函数的参数必选参数对于 power(x) 函数，参数 x 就是一个必选参数。当调用 power 函数时，必须传入有且仅有的一个参数 x。 默认参数对于 power(x, n) 函数，n 是默认参数。当调用 power(5) ，相当于调用 power(5, 2)。 注意： 默认参数必须指向不变对象。如果默认参数指向可变对象，每次调用该函数，改变了可变对象，下次调用该函数，默认参数的内容就改变了。 必选参数在前，默认参数在后，否则 Python 的解释器会报错。 可变参数参数 *numbers 是一个可变参数，调用 sum 函数时，可以传入任意个参数，包括 0 个参数。 如果传入的参数是 list 或者 tuple 类型，可以在变量前加一个 * 号，把 list 或 tuple 的元素变成可变参数传进去： 关键字参数**kw 是关键字参数，关键字参数传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict。 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。如果要限制关键字参数的名字，就可以用命名关键字参数。命名关键字参数需要一个特殊分隔符 * ，* 后面的参数被视为命名关键字参数。例如： 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符 * 了： 命名关键字参数可以有缺省值，从而简化调用： 参数组合在 Python 中定义函数，这5种参数都可以组合使用，但是参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 默认参数 + 可变参数在默认参数 + 可变参数的组合中，如果想使用可变参数，必须要依次给默认参数全部重新赋值才能使用可变参数，并且不能使用 a=0 方式给默认参数赋值： 默认参数 + 命名关键字参数&#x2F;关键字参数在默认参数 + 命名关键字参数/关键字参数中，默认参数的变量名不会作为 key 出现在命名关键字参数/关键字参数中，因此默认参数跟命名关键字参数/关键字参数并没有什么冲突，包括参数的位置也没有限制： "},{"title":"【Python】集合","date":"2023-12-19T16:00:00.000Z","url":"/blog/2023/12/20/Python/02_Python%E5%9F%BA%E7%A1%80/Python%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/","tags":[["Python","/blog/tags/Python/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"Python 有 4 种集合：list 、tuple 、dict 、set。 ListList 的定义 增在末尾添加元素 在指定位置添加元素 删删除末尾元素 删除指定位置的元素 改直接赋值给对应的索引位置 查通过索引下标查询 空列表和初始化空列表是使用不包含任何内容的两个方括号 [] 表示的。使用 None，可以初始化列表的长度，例如： 遍历遍历元素 带索引遍历元素 列表方法append：用于将一个对象附加到列表末尾。 clear：就地清空列表的内容。 copy：复制列表。 count：计算指定的元素在列表中出现了多少次。 extend：使用一个列表来扩展另一个列表。 extend 与拼接的一个重要差别，就是将修改被扩展的序列。在常规拼接中，情况是返回一个全新的序列。 index：列表中查找指定值第一次出现的索引。 insert：将一个对象插入列表指定位置。 pop：从列表中删除一个元素，并返回这一元素。 remove：用于删除第一个为指定值的元素。 reverse：按相反的顺序排列列表中的元素。 sort：用于对列表就地排序，默认从小到大排序。方法sort接受两个可选参数：key 和 reverse。 Tupletuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改，因此没有增删改。 Tuple 的定义 查通过索引下标查询 遍历遍历元素 带索引遍历元素 注意注意空 tuple 和只有一个元素的 tuple的定义方式： DictDict 的定义 增 删pop(key) 方法删除 key 改一个 key 只能对应一个 value，给 key 重新赋值即可。 查根据 key 查询 value get() 方法查询 value，如果 key 不存在返回 None，或者自己指定的 value。 遍历遍历 key 遍历 value 遍历 key 和 value SetSet 的定义 增add(key) 方法添加元素 删remove(key) 方法删除元素 遍历 集合运算并集 交集 差集"},{"title":"【Python】字符串","date":"2023-12-18T16:00:00.000Z","url":"/blog/2023/12/19/Python/02_Python%E5%9F%BA%E7%A1%80/Python%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":[["Python","/blog/tags/Python/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"Python有 5 种数据类型：整数、浮点数、字符串、布尔值（True、False）、空值（None）。其中字符串较为复杂。 字符串的定义字符串有两种定义方式：单引号 &#39;&#39; 和双引号 &quot;&quot; 。 转义字符转义字符 \\ 除了可以转义单引号 &#39; 和 双引号 ”，还可以转义很多字符，比如 \\n 表示换行，\\t 表示制表符，字符 \\ 本身也要转义，所以 \\\\ 表示的字符就是 \\。 如果字符串里面有很多字符都需要转义，就需要加很多 \\，为了简化，Python 还允许用 r&#39;&#39; 表示 &#39;&#39; 内部的字符串默认不转义。 字符串编码ASCII：127 个字符的编码，包括大小写英文字母、数字和一些符号。 Unicode：将全世界上百种语言统一到一套编码中，用两个字节表示一个字符，汉字也是两个字节。特点是字节长度固定。 UTF-8：Unicode 的字节长度是固定的，因此出现了把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节。 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件： 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器： 由于 Python 的字符串类型是 str，在内存中以 Unicode 表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes。Python 对 bytes 类型的数据用带 b 前缀的单引号或双引号表示： encode() 和 decode() 的使用encode()：对字符串编码。 decode() ：对 bytes 字节解码 字符串格式化第一种：占位符 %用 %s 表示字符串，%d 表示整数，%f 表示浮点数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 如果字符串里面的 % 是一个普通字符，这时候用用 %% 来表示一个 % ： 第二种：format()format() 方法需要依次传入参数以替换字符串中的占位符 &#123;0&#125;、&#123;1&#125;…… 第三中：f-string以 f 开头的字符串，字符串如果包含 &#123;xxx&#125;，就会以对应的变量替换： 字符串方法center：在两边添加填充字符（默认为空格）让字符串居中。 find：在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1。 字符串使用小技巧如果字符串里面有很多字符都需要转义，就需要加很多 \\，为了简化，Python 还允许用 r&#39;&#39; 表示 &#39;&#39; 内部的字符串默认不转义。 如果字符串内部有很多换行，用 \\n 写在一行里不好阅读，为了简化，Python 允许用&#39;&#39;&#39; &#39;&#39;&#39;的格式表示多行内容。 由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当 Python 解释器读取源代码时，为了让它按 UTF-8 编码读取，我们通常在文件开头写上这一行： "},{"title":"【Python】常用函数","date":"2023-12-18T16:00:00.000Z","url":"/blog/2023/12/19/Python/99_%E7%A7%AF%E7%B4%AF/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/","tags":[["Python","/blog/tags/Python/"]],"categories":[["Python","/blog/categories/Python/"]],"content":"字符串lower() 数据类型转换int() float() str() bool() 集合相关的len()获取元素的个数： 对象相关的isinstance()判断对象的类型，如判断是否是一个可迭代对象： type()查看对象的类型： dir()查询一个对象的所有属性和方法，包括私有属性和私有方法： 高阶函数mapmap() 函数接收两个参数：一个是函数，一个是 Iterable 对象。 map 将传入的函数依次作用到序列的每个元素，并把结果作为新的 Iterator 返回。 传入函数的特点：接收一个参数，返回一个值。 reducereduce() 函数接收两个参数：一个是函数，一个是 Iterable 对象。 reduce 把结果继续和序列的下一个元素做累积计算，其效果就是： 传入函数的特点：接收两个参数，返回一个值。 filterfilter() 函数接收一个函数和一个序列。filter() 把传入的函数依次作用于每个元素，然后根据返回值 True/False 决定是否保留该元素。 传入函数的特点：接收一个参数，返回 True/False 。 sortedsorted() 函数接收三个参数：序列，key，reverse。其中 key 是个默认参数，接收一个映射函数。reverse 也是个默认参数，传入 True/False 表示是否反转排序后的序列。 sorted() 函数默认按从小到大排序。 传入函数的特点：接收一个参数，返回 int 值。 类中特殊的方法类似 __xxx__ 方法在 Python 中都是有特殊用途的。 __len__()__len__() 方法返回对象的长度。调用 len() 函数获取一个对象的长度，实际上，在 len() 函数内部，它自动去调用该对象的 __len__() 方法。所以，下面的代码是等价的： 类中特殊的属性类似 __xxx__ 属性在 Python 中都是有特殊用途的。 __bases__当一个对象表示数据类型时，比如 int 对象，它就具有了 __bases__ 属性： "},{"title":"分布式事务理论基础","date":"2023-07-01T02:17:31.000Z","url":"/blog/2023/07/01/SpringCloud/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","tags":[["SpringCloud","/blog/tags/SpringCloud/"],["分布式事务","/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"]],"categories":[["SpringCloud","/blog/categories/SpringCloud/"]],"content":"随着微服务架构越来越流行，分布式事务在项目中也越来越普遍，本章主要涉及分布式事务的理论知识，为后续的学习分布式事务框架打下基础。 数据库事务事务的定义数据库事务是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 数据库本地事务的性质 原子性：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。 一致性：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。 隔离性：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。 持久性：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 分布式事务简介什么是分布式事务分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务。例如下图，发起下单请求后会在订单数据库和库存数据库分别创建订单事务和库存事务，通过网络远程协作使得订单事务和库存事务同时提交或同时回滚。 分布式事务产生的场景跨 JVM 进程产生分布式事务： 单体系统访问多个数据库实例： 多服务访问同一个数据库实例： 分布式事务基础理论CAP 理论CAP理论：在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance），这三个要素最多只能同时实现两点，不可能三者兼顾。 C - ConsistencyCAP 中的一致性指的是数据的一致性，是写操作后的读操作可以读取到最新的数据，当数据分布在多个节点上，从任意结点读取到的数据都是最新的。 系统不可能永久的正常运行下去。如果系统内部发生了问题从而导致系统的节点无法发生一致性变化时，就意味着想看到最新数据的读请求们，很可能会看到旧数据，或者说获取到不同版本的数据。此时，为了保证分布式系统对外的数据一致性，于是选择不返回任何数据。 注：上面描述的一致性和 ACID 事务中的一致性是两回事。事务中的一致性包含了实际工程对状态的后续处理。但是 CAP 定理并不涉及到状态的后续处理，对于这些问题，后续出现了 BASE 理论等工程结论去处理，目前，只需要明白 CAP 定理主要描述的是状态。 A - AvailabilityCAP 中的可用性要求系统内的节点们接收到了无论是写请求还是读请求，都要能在规定的时间内处理并回响应结果。只是它有两点必须满足的条件： 条件 1：返回结果必须在合理的时间以内，这个合理的时间是根据业务来定的。如果业务定的 100 毫秒，结果却在 1 秒才返回，那么这个系统就不满足可用性。 条件 2：需要系统内能正常接收请求的所有节点都返回结果。这包含了两重含义： 如果节点不能正常接收请求了，比如宕机了，系统崩溃了，而其他节点依然能正常接收请求，那么，我们说系统依然是可用的，也就是说，部分宕机没事儿，不影响可用性指标。 如果节点能正常接收请求，但是发现节点内部数据有问题，那么也必须返回结果，哪怕返回的结果是有问题的。比如，系统有两个节点，其中有一个节点数据是三天前的，另一个节点是两分钟前的，如果，一个读请求跑到了包含了三天前数据的那个节点上，那么这个节点不能拒绝，必须返回这个三天前的数据，即使它可能不太合理。 P - Partition tolerance分布式的存储系统会有很多的节点，这些节点都是通过网络进行通信。而网络是不可靠的，当节点和节点之间的通信出现了问题，此时，就称当前的分布式存储系统出现了分区。但是，分区并不一定是由网络故障引起的，只要节点通信出现了问题，那么就出现了分区。 CAP 中的分区容忍性是指，如果出现了分区问题，我们的分布式存储系统还需要继续运行。不能因为出现了分区问题，整个分布式节点无法继续工作。 CAP 怎么选择在设计分布式系统时，架构师们在 C、A、P 这三种特性里，只能选择两种。 因为在分布式系统中，P 是必然的发生的，不选 P，一旦发生分区错误，整个分布式系统就完全无法使用了，这是不符合实际需要的。所以，对于分布式系统，我们只能能考虑当发生分区错误时，如何选择一致性和可用性。 而根据一致性和可用性的选择不同，开源的分布式系统往往又被分为 CP 系统和 AP 系统。 当一套系统在发生分区故障后，客户端的任何请求都被卡死或者超时，但是，系统的每个节点总是会返回一致的数据，则这套系统就是 CP 系统。 如果一套系统发生分区故障后，客户端依然可以访问系统，但是获取的数据有的是新的数据，有的还是老数据，那么这套系统就是 AP 系统。 对 CAP 的常见误解误解一：分布式系统因为 CAP 定理放弃了 C 或者 A 中的其中一个 在发生 P 的情况下，根据 CAP 定理，分布式系统只能在 C 或 A 中选择一个。但是 P 发生的概率是非常低的，在没发生时，系统可以即是 C 又是 A。 误解二：C 和 A 之间的选择是针对整个分布式系统的，只能整体考虑 C 和 A 之间的选择 当 P 发生的时候，其实对 C 和 A 的抉择是局部性的，而不是针对整个系统的。 BASE 理论BASE 理论是基本可用（Basically Available）、软状态（Soft-state） 和 最终一致性（Eventually Consistent） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。 BA - Basically Available基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。例如延长响应时间、非核心功能不可用，核心功能依然可用。 S - Soft-state软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点之间进行数据同步的过程存在延时。 E - Eventually Consistent最终一致性强调的是系统中所有的数据副本，在规定的时间内，最终能够达到一个一致的状态。 分布式一致性的 3 种级别： 强一致性：处理读请求时，每个节点的数据副本都是一致的。 弱一致性：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。 最终一致性：弱一致性的升级版，系统会保证在规定时间内达到数据一致的状态。 七种分布式事务解决方案2PC2PC，两阶段提交，将事务的提交过程分为资源准备和资源提交两个阶段，并且由事务协调者来协调所有事务参与者，如果准备阶段所有事务参与者都预留资源成功，则进行第二阶段的资源提交，否则事务协调者回滚资源。 第一阶段 - 准备阶段 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。 各参与者执行本地事务操作，但不提交事务。 如参与者执行成功，给协调者反馈同意，否则反馈中止，表示事务不可以执行。 第二阶段 - 提交阶段 协调者节点向所有参与者节点发出提交/回滚请求。 收到协调者发出提交/回滚请求，参与者正式执行事务提交/回滚操作。 参与者完成事务提交后，向协调者节点发送 ACK 消息。 协调者节点收到所有参与者节点反馈的 ACK 消息后，完成事务。 2PC 的缺点 性能问题：在第一阶段，事务协调者需要收到所有事务参与者的响应信息才能在第二阶段发起提交/回滚请求。 可靠性问题：2PC 非常依赖协调者，当协调者发生故障时，尤其是第二阶段，那么所有的参与者就会都处于锁定事务资源的状态中，而无法继续完成事务操作（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题） 数据一致性问题：在阶段二中，当协调者向参与者发送提交请求之后，因为局部网络异常导致只有一部分参与者接受到了提交请求。而在这部分参与者收到提交请求之后就会执行提交操作。但是其他部分未接到提交请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。 3PC3PC 分为 3 个阶段：准备阶段、预提交阶段、提交阶段。三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点： 在协调者和参与者中都引入超时机制。 在第一阶段前新增一个准备阶段，保证在预提交阶段之前各参与节点的状态是一致的。 第一阶段 - 准备阶段 事务询问：协调者向所有参与者发出包含事务内容的请求，询问是否可以提交事务，并等待所有参与者答复。 响应反馈：参与者收到请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。 第二阶段 - 预提交阶段根据第一阶段的响应结果，有以下两种可能： 假如所有参与者均反馈 Yes，协调者预执行事务，具体如下： 发送预提交请求：协调者向参与者发送执行事务请求，并进入准备阶段。 事务预提交 ：参与者接收到请求后，执行本地事务操作，但不提交事务。 响应反馈 ：参与者根据处理结果向协调者响应信息，同时开始等待最终指令。 假如有任何一个参与者向协调者发送了 No 响应，或者在规定时间内，协调者都没有接到参与者的响应，那么就执行事务的中断，流程如下： 发送中断请求 ：协调者向所有参与者发送中断请求。 中断事务 ：参与者收到来自协调者的中断请求之后，或者超时之后，仍未收到协调者的请求，执行事务的中断。 第三阶段 - 提交阶段 发起提交/回滚请求：若第二阶段所有参与者都响应 Yes 则发起提交请求，若有任何一个参与者响应 No 或协调者在规定的时间内没有收到参与者的响应信息则发起回滚请求。 提交/回滚事务：参与者接收请求并提交/回滚本地事务。 响应反馈：参与者提交/回滚本地事务后，向协调者发送 ACK 响应。 注：参与者们进入第三阶段后，因为种种原因导致参与者们在规定的时间内没用收到协调者发起的提交/回滚请求，参与者们都会在等待超时之后，继续执行事务提交。 3PC 的优缺点优点：与 2PC 相比，3PC 在等待超时后，协调者或参与者会中断事务，避免了协调者单点问题。阶段三中协调者出现问题时，参与者会继续提交事务。 缺点：数据不一致问题依然存在。在第三阶段，如果协调者发起的是回滚事务请求，参与者因为网络问题无法接收协调者的请求，会导致参与者继续提交事务，造成数据不一致。 TCCTCC（Try Confirm Cancel）是应用层的两阶段提交，其核心思想是：针对每个操作，都要实现对应的确认和补偿操作，也就是业务逻辑的每个分支都需要实现 Try、Confirm、Cancel 三个操作。 TCC 的执行流程TCC的执行流程可以分为两个阶段，分别如下： 第一阶段：Try，业务系统做检测并预留资源 (加锁，锁住资源)，比如常见的下单，在 Try 阶段，我们不是真正的减库存，而是把下单的库存给锁定住。 第二阶段：根据第一阶段的结果决定是执行 Confirm 操作还是 Cancel 操作。Confirm 执行真正的业务（执行业务，释放锁），Cancel 是对 Try 阶段预留资源的释放（释放锁）。 TCC 如何保证最终一致性 TCC 事务机制以 Try 为中心的，Confirm 确认操作和 Cancel 取消操作都是围绕 Try 而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有 Cancel 取消操作可以将其执行结果撤销。 Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的，也就是说只要 Try 成功，Confirm 一定成功（TCC设计之初的定义）。 Confirm 与 Cancel 如果失败，由TCC框架进行重试补偿。 存在极低概率在CC环节彻底失败，则需要定时任务或人工介入。 TCC 的注意事项允许空回滚 空回滚出现的原因是 Try 超时或者丢包，导致 TCC 分布式事务二阶段的回滚，触发 Cancel 操作，此时事务参与者未收到 Try，但是却收到了 Cancel 请求。所以 Cancel 接口在实现时需要允许空回滚，也就是 Cancel 执行时如果发现没有对应的事务 xid 或主键时，需要返回回滚成功，让事务服务管理器认为已回滚。 防悬挂控制 悬挂指的是二阶段的 Cancel 比一阶段的 Try 操作先执行，出现该问题的原因是 Try 由于网络拥堵而超时，导致事务管理器生成回滚，触发 Cancel 接口，但之后拥堵在网络的 Try 操作又被资源管理器收到了，但是 Cancel 比 Try 先到。但按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，所以此时应该拒绝执行空回滚之后到来的 Try 操作，否则上锁的资源无法释放。因此我们可以在 Cancel 空回滚返回成功之前，先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口执行前先检查这条事务 xid 或业务主键是否已经标记为回滚成功，如果是则不执行 Try 的业务操作。 幂等控制 由于网络原因或者重试操作都有可能导致 Try - Confirm - Cancel 3个操作的重复执行，所以使用 TCC 时需要注意这三个操作的幂等控制，通常我们可以使用事务 xid 或业务主键判重来控制。 Saga 事务Saga 事务核心思想是将长事务拆分为多个本地短事务并依次正常提交，如果所有短事务均执行成功，那么分布式事务提交；如果出现某个参与者执行本地事务失败，则由 Saga 事务协调器根据相反顺序调用补偿操作，回滚已提交的参与者，使分布式事务回到最初始的状态。Saga 事务基本协议如下： 每个 Saga 事务由一系列幂等的有序子事务 Ti 组成。 每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。 Saga 的恢复策略对于事务异常，Saga 提供了两种恢复策略，分别如下： 1. 向后恢复 当执行事务失败时，补偿所有已完成的事务，是“一退到底”的方式，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。如下图： 2. 向前恢复 对于执行不通过的事务，会尝试重试事务，这里有一个假设就是每个子事务最终都会成功，这种方式适用于必须要成功的场景，事务失败了重试，不需要补偿。流程如下图： Saga 事务的实现方式Saga 事务有两种不同的实现方式，分别如下： 1. 命令协调 中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。整体流程如下图： 中央协调器必须事先知道执行整个事务所需的流程，如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚，基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。 2. 事件编排 命令协调方式基于中央协调器实现，所以有单点风险，但是事件编排方式没有中央协调器。事件编排的实现方式中，每个服务产生自己的事件并监听其他服务的事件来决定是否应采取行动。 在事件编排方法中，第一个服务执行一个事务，然后发布一个事件，该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。整体流程如下图： 如果事务涉及 2 至 4 个步骤，则非常合适使用事件编排方式，它是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。 Saga 事务的优缺点1. 命令协调设计的优缺点 优点： （1）服务之间关系简单，避免服务间循环依赖。 （2）程序开发简单，只需要执行命令&#x2F;回复，降低参与者的复杂性。 （3）易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试。 缺点： （1）中央协调器处理逻辑容易变得庞大复杂，导致难以维护。 （2）存在协调器单点故障风险。 2. 事件编排设计的优缺点： 优点： （1）避免中央协调器单点故障风险。 （2）当涉及的步骤较少服务开发简单，容易实现。 缺点： （1）服务之间存在循环依赖的风险。 （2）当涉及的步骤较多，服务间关系混乱，难以追踪调测。"},{"title":"【Windows】 常用软件","date":"2023-06-20T01:00:00.000Z","url":"/blog/2023/06/20/Windows/Windows%E8%BD%AF%E4%BB%B6/","tags":[["Windows","/blog/tags/Windows/"]],"categories":[["undefined",""]],"content":"接口测试Eolink 版本管理工具Git Java 开发工具jdk Toolbox Maven Tomcat 截图工具snipaste 文本编辑工具Typora VSCode AI 工具Trae 国际版 虚拟机VMware 17 下载地址 VMware 17 安装教程 压缩文件Bandizip 远程连接Xshell Xftp 录制 Gif 工具LICEcap Clash for Windows科学上网，下载地址"},{"title":"HTTP Client 接口调用插件的使用","date":"2023-06-17T02:56:37.000Z","url":"/blog/2023/06/17/Idea/HTTP-Client-%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["Idea","/blog/tags/Idea/"]],"categories":[["Idea","/blog/categories/Idea/"]],"content":"HTTP Client 是 IntelliJ IDEA 自带的一款轻量级的接口调用插件。有了它，我们可以在 IDEA 中编写接口测试脚本，测试接口功能以及对返回结果进行断言等等。 基本用法HTTP Client 是 IDEA 自带的插件，首先确认是否安装了该插件。 熟悉 Demo 项目Demo 提供的接口 URL 请求方式 作用 &#x2F;login POST 登录功能，登录成功后返回 token。账号：root，密码：123456。 &#x2F;user&#x2F;{id} GET 根据 id 获取用户信息，请求头需要携带 token 才能访问该接口。 &#x2F;user POST 根据 id 更新用户信息，请求头需要携带 token 才能访问该接口。 Demo 的响应数据格式以获取用户信息为例，其中 code 为 2000 表示请求成功，5000 表示请求失败。 编写 HTTP 请求创建 HTTP Request 文件 编写 HTTP Request 文件 请求的语法基本上和 http 协议内容是一致的，结构如下： 运行结果Ctrl + Shift + F10 对光标所在的 URL 发起请求，请求结束会将响应数据以 json 格式保存在 .idea 目录中，请求结果如下： 进阶用法在请求中插入 JavaScript 脚本，可以实现打印日志、存储变量、断言等功能。结构如下： 打印日志在脚本中打印日志，代码如下： 存储变量在 demo 项目中，调用 /user/&#123;id&#125; 接口前需要先调用 /login 接口获取 token。我们可以将获取到的 token 通过 JavaScript 脚本存储在环境变量中，然后在调用 /user/&#123;id&#125; 接口时通过 &#123;&#123; 变量名 &#125;&#125; 从环境变量获取变量值。 断言断言可以让让程序代替人判断测试用例执行的结果是否符合预期，HTTP Client 的断言代码如下： 配置环境变量在开发中通常有多个环境，如开发环境、测试环境、生产环境等等，每个环境的域名不同、接口所需的参数（如：账号密码等）也可能不同，那么我们不能在编写接口的时候将域名或参数写死。我们可以在 http-client.env.json 文件中配置接口相关信息， 编写接口时通过 &#123;&#123;变量名&#125;&#125; 的方式获取配置信息，在获取配置信息前需要先指定接口请求的环境。我的接口配置信息如下： 快捷操作Ctrl + J：插入代码模板。 Ctrl + Shift + F10：对光标所在的 URL 发起请求。 注意事项在请求体中使用 &#123;&#123;变量名&#125;&#125; 获取环境变量时，需要使用双引号 “ ” 括起来，否则在解析 json 参数时会报 HttpMessageNotReadableException 异常。 "},{"title":"CentOS7 配置静态 IP","date":"2023-06-10T09:11:18.000Z","url":"/blog/2023/06/10/Linux/Centos7-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/","tags":[["Linux","/blog/tags/Linux/"]],"categories":[["Linux","/blog/categories/Linux/"]],"content":"修改配置文件 需要修改或添加如下信息： BOOTPROTO&#x3D;”static” ONBOOT&#x3D;”yes” IPADDR&#x3D;192.168.134.100 （根据自己情况设置） GATEWAY&#x3D;192.168.134.2 （根据自己情况设置） NETMASK&#x3D;255.255.255.0 DNS1&#x3D;8.8.8.8 重启网络 查看网络是否可用 查看 IP 地址 遇到的问题网络不可用的情况如果物理机无法 ping 通虚拟机，那么是配置问题。如果物理机和虚拟机可以互 ping 通，但是无法 ping 通百度。尝试添加网关： 浏览器无法访问虚拟机接口的问题问题描述：宿主机和虚拟机能互相 ping 通，且 postman 可以调用虚拟机的接口，但是宿主机的浏览器无法调用虚拟机的接口。 原因：可能是 windows 对虚拟机的静态 ip 进行了代理，导致在浏览器无法调用虚拟机的接口。修改 windows 的代理配置，要求禁止对虚拟机的静态 ip 进行代理。修改如下： 数据来源说明IPADDR、GATEWAY、NETMASK 数据来源如下： 编辑 -&gt; 虚拟网络编辑器 -&gt; NAT 设置 "},{"title":"CentOS7 安装 Docker","date":"2023-06-10T07:48:48.000Z","url":"/blog/2023/06/10/Docker/CentOS-Docker-%E5%AE%89%E8%A3%85/","tags":[["Docker","/blog/tags/Docker/"]],"categories":[["Docker","/blog/categories/Docker/"]],"content":"Docker 是一个开源平台，用于支持开发人员构建、部署、运行、更新和管理容器；而容器是标准化的可执行组件，结合了应用程序源代码以及在任何环境中运行该代码所需的操作系统库和依赖关系。 使用官方安装 Docker 使用阿里云的安装Docker 配置镜像服务器Docker 拉取镜像时，经常出现无法访问或者长时间下载不完的情况。是因为 Docker 的默认的镜像服务器 Docker Hub 部署在海外，因此要解决这个问题只需要将镜像服务器地址指定为国内的地址即可。 到 2023-06-10 为止，还可以免费使用的国内的镜像平台： 镜像加速器 镜像加速器地址 USTC  阿里云  百度云  网易云  DaoCloud 镜像站  Docker 镜像代理  配置镜像加速地址创建或修改 daemon.json 文件 将以下内容写入此配置文件，镜像服务地址可根据自己实际情况填写 重新加载配置文件 重启 docker 服务 查看 docker 信息 出现如上信息表示配置成功。 Docker Hub 镜像测速使用镜像前后，可使用 time 统计所花费的总时间。测速前先移除本地的镜像！ "},{"title":"MySQL 的数据目录","date":"2023-05-21T16:00:00.000Z","url":"/blog/2023/05/22/mysql/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/","tags":[["MySQL","/blog/tags/MySQL/"]],"categories":[["MySQL","/blog/categories/MySQL/"]],"content":" 本章主要介绍 MySQL 系统的目录结构以及数据库和表在文件系统的表示方法。 MySQL8 的主要目录结构数据库文件的存放路径show variables like &#39;datadir&#39; SQL 语句能够查询 MySQL 数据库文件的存放路径，从结果可以看出在我的计算机上 MySQL 的数据目录是 /var/lib/mysql/。 MySQL 配置文件的存放路径MySQL 配置文件的存放路径：/etc/、/usr/share/mysql-8.0 等文件目录，文件名为 my.cnf。 数据库和文件系统的关系MySQL 系统自带的数据库以下除了 testdb 数据库是自己创建的，其他四个是 MySQL 系统自带的。 mysqlMySQL 系统自带的核心数据库，它存储了 MySQL 的用户信息、权限信息、存储过程、事件的定义信息、运行过程中产生的日志信息，一些帮助信息以及时区信息等。 information_schema这个数据库保存着 MySQL 服务器维护的所有其他数据库的信息 ，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据 。 performance_schema这个数据库里主要保存 MySQL 服务器运行过程中的一些状态信息，可以用来监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。 sys这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。 数据库在文件系统中的表示以下是我的计算机上的数据目录的内容。这个数据目录中，除了 information_schema 这个系统数据库外，其他的数据库在数据目录下都有对应的子目录。 表在文件系统中的表示新建一个名为 demo01 的数据库，有如下表： InnoDB 存储引擎模式表结构为了保存表结构， InnoDB 在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件 ，文件名格式为表名.frm。MySQL8.0 中不再单独提供表名.frm，而是合并在表名.ibd文件中。 以 demo01 数据库为例，在 MySQL5.7 下打开数据目录中对应的数据库子目录： 在 MySQL8.0 中打开： 表中数据和索引默认情况下，InnoDB 会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应的系统表空间在文件系统上的表示。当不够用的时候它会自己增加文件大小。可以在 my.cnf 配置文件中这样修改文件名和文件大小： 在 MySQL5.6.6 以及之后的版本中，InnoDB 并不会默认的把各个表的数据存储到系统表空间中，也就是 ibdata1 文件中，而是为每 一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名的格式为表名.ibd。 我们可以自己指定使用系统表空间还是独立表空间来存储数据，这个功能由启动参数 innodb_file_per_table 控制，比如说我们想将表数据都存储到系统表空间时，可以这样修改 my.cnf 配置文件： MyISAM 存储引擎模式表结构在存储表结构方面， MyISAM 和 InnoDB 一样，也是在数据目录下对应的数据库子目录下创建了一个表名.frm文件用于描述表结构. 表中数据和索引在 MyISAM 中的索引全部都是二级索引，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件。假如 test 表使用 MyISAM 存储引擎的话，那么在它所在数据库目录下会为 test 表创建这三个文件： 小结 如果表采用了 InnoDB 存储引擎 在 MySQL5.7 中，用表名.frm文件存储表结构信息，表名.ibd文件&#96;存储表数据和索引。 在 MySQL8.0 中，用表名.ibd文件存储表结构、数据和索引。 如果表采用了 MyISAM 存储引擎 在 MySQL5.7 中，用表名.frm文件存储表结构信息，表名.MYD文件 存储表数据，表名.MYI文件存放索引信息 在 MySQL8.0 中，用表名.xxx.sdi文件存储表结构信息，表名.MYD文件 存储表数据，表名.MYI文件存放索引信息 另外，在 MySQL5.7 中会在数据目录对应的数据库文件下会生成 db.opt 文件，用于存储数据库的相关配置。比如：字符集、比较规则。而MySQL8.0不再提供 db.opt 文件。"},{"title":"【Java 8 新特性】时间类：OffsetTime 和 OffsetDateTime","date":"2023-05-20T16:00:00.000Z","url":"/blog/2023/05/21/Java8/time/OffsetTime_OffsetDateTime/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"本章介绍 java.time 包下两个带有偏移量概念的时间类： OffsetTime 和 OffsetDateTime。 OffsetTime：OffsetTime 类表示一个带有时区偏移量的时间，它由一个 LocalTime 对象和一个 ZoneOffset 对象组成。 OffsetDateTime：OffsetDateTime 类表示一个带有时区偏移量的日期时间，它由一个 LocalDateTime 对象和一个 ZoneOffset 对象组成。 OffsetTimeOffsetTime 类表示一个带有时区偏移量的时间，包含了时间和时区偏移量两个属性。OffsetTime 类是由 LocalTime 类和 ZoneOffset 类组成的，因此它的使用方式也和 LocalTime 类似，但需要考虑时区偏移量的影响。例如 08:00:00+08:00 是一个带有时区偏移量的时间，它表示比 00:00:00 UTC（世界协调时间） 快 8 小时，是在 00:00:00 UTC 加 8 小时后得到的时间。 公共常量 静态方法from(TemporalAccessor temporal) now()now(ZoneId zone)now(Clock clock) of(int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset)of(LocalTime time, ZoneOffset offset)ofInstant(Instant instant, ZoneId zone) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) 成员方法atDate(LocalDate date) format(DateTimeFormatter formatter) toLocalTime() truncatedTo(TemporalUnit unit) until(Temporal endExclusive, TemporalUnit unit) withOffsetSameInstant(ZoneOffset offset)withOffsetSameLocal(ZoneOffset offset) 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用类似，该篇章就不在赘述了。 adjustInto(Temporal temporal) compareTo(OffsetTime other) isAfter(OffsetTime other) isBefore(OffsetTime other) isEqual(OffsetTime other) equals(Object obj) get(TemporalField field) getLong(TemporalField field) getHour() getMinute() getNano() getOffset() getSecond() hashCode() isSupported(TemporalField field) isSupported(TemporalUnit unit) minus(long amountToSubtract, TemporalUnit unit) minus(TemporalAmount amountToSubtract) minusHours(long hours) minusMinutes(long minutes) minusNanos(long nanos) minusSeconds(long seconds) plus(long amountToAdd, TemporalUnit unit) plus(TemporalAmount amountToAdd) plusHours(long hours) plusMinutes(long minutes) plusNanos(long nanos) plusSeconds(long seconds) query(TemporalQuery query) range(TemporalField field) toString() with(TemporalAdjuster adjuster) with(TemporalField field, long newValue) withHour(int hour) withMinute(int minute) withNano(int nanoOfSecond) withSecond(int second) OffsetDateTimeOffsetDateTime 表示一个带有时区偏移量的日期时间，包含了日期、时间和时区偏移量三个属性。OffsetDateTime 类是由 LocalDateTime 类和 ZoneOffset 类组成的，因此它的使用方式也和 LocalDateTime 类似，但需要考虑时区偏移量的影响。例如 2023-01-01 08:00:00+08:00 是一个带有时区偏移量的日期时间，它表示比 2023-01-01 00:00:00 UTC（世界协调时间） 快 8 小时，是在 2023-01-01 00:00:00 UTC 加 8 小时后得到的日期时间。 公共常量 静态方法from(TemporalAccessor temporal) now()now(ZoneId zone)now(Clock clock) of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset)of(LocalDate date, LocalTime time, ZoneOffset offset)of(LocalDateTime dateTime, ZoneOffset offset)ofInstant(Instant instant, ZoneId zone) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) timeLineOrder() 成员方法format(DateTimeFormatter formatter) getOffset() toEpochSecond()toInstant()toLocalDate()toLocalDateTime()toLocalTime()toOffsetTime()toZonedDateTime() truncatedTo(TemporalUnit unit) until(Temporal endExclusive, TemporalUnit unit) withOffsetSameInstant(ZoneOffset offset)withOffsetSameLocal(ZoneOffset offset) atZoneSameInstant(ZoneId zone)atZoneSimilarLocal(ZoneId zone) 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用类似，该篇章就不在赘述了。 compareTo(OffsetTime other) isAfter(OffsetTime other) isBefore(OffsetTime other) isEqual(OffsetTime other) equals(Object obj) get(TemporalField field) getLong(TemporalField field) getDayOfMonth() getDayOfWeek() getDayOfYear() getYear() getMonth() getMonthValue() getHour() getMinute() getNano() getOffset() getSecond() hashCode() isSupported(TemporalField field) isSupported(TemporalUnit unit) minus(long amountToSubtract, TemporalUnit unit) minus(TemporalAmount amountToSubtract) minusDays(long days) minusMonths(long months) minusWeeks(long weeks) minusYears(long years) minusHours(long hours) minusMinutes(long minutes) minusNanos(long nanos) minusSeconds(long seconds) plus(long amountToAdd, TemporalUnit unit) plus(TemporalAmount amountToAdd) plusDays(long days) plusMonths(long months) plusWeeks(long weeks) plusYears(long years) plusHours(long hours) plusMinutes(long minutes) plusNanos(long nanos) plusSeconds(long seconds) query(TemporalQuery query) range(TemporalField field) toString() with(TemporalAdjuster adjuster) with(TemporalField field, long newValue) withDayOfMonth(int dayOfMonth) withDayOfYear(int dayOfYear) withMonth(int month) withYear(int year) withHour(int hour) withMinute(int minute) withNano(int nanoOfSecond) withSecond(int second) 参考文献"},{"title":"【Java 8 新特性】时间类：ZonedDateTime","date":"2023-05-20T16:00:00.000Z","url":"/blog/2023/05/21/Java8/time/ZonedDateTime/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"ZonedDateTime 是具有偏移量和时区两个概念的日期时间，由 dateTime、offset 和 zone 三个变量组成。其中 dateTime 是 LocalDateTime 类的对象，表示日期时间，offset 是 ZoneOffset 类的对象，用于表示 dateTime 对象相对于 UTC 的偏移量，zone 属于 ZoneId 类，可以是 ZoneRegion 类的对象（表示时区），也可以是 ZoneOffset，此时没有时区的概念。ZonedDateTime 在功能上跟 OffsetDateTime 差不多，但 ZonedDateTime 在时区转换上使用起来跟方便。 静态方法from(TemporalAccessor temporal) now()now(ZoneId zone)now(Clock clock) of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, ZoneId zone)of(LocalDate date, LocalTime time, ZoneId zone)of(LocalDateTime localDateTime, ZoneId zone) ofInstant(Instant instant, ZoneId zone)ofInstant(LocalDateTime localDateTime, ZoneOffset offset, ZoneId zone) ofLocal(LocalDateTime localDateTime, ZoneId zone, ZoneOffset preferredOffset)ofStrict(LocalDateTime localDateTime, ZoneOffset offset, ZoneId zone) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) 成员方法format(DateTimeFormatter formatter) getZone() toLocalDate()toLocalDateTime()toLocalTime()toOffsetDateTime() truncatedTo(TemporalUnit unit) until(Temporal endExclusive, TemporalUnit unit) withEarlierOffsetAtOverlap()withLaterOffsetAtOverlap()withFixedOffsetZone() withZoneSameInstant(ZoneId zone)withZoneSameLocal(ZoneId zone) 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用类似，该篇章就不在赘述了。 equals(Object obj) get(TemporalField field) getLong(TemporalField field) getDayOfMonth() getDayOfWeek() getDayOfYear() getYear() getMonth() getMonthValue() getHour() getMinute() getNano() getOffset() getSecond() hashCode() isSupported(TemporalField field) isSupported(TemporalUnit unit) minus(long amountToSubtract, TemporalUnit unit) minus(TemporalAmount amountToSubtract) minusDays(long days) minusMonths(long months) minusWeeks(long weeks) minusYears(long years) minusHours(long hours) minusMinutes(long minutes) minusNanos(long nanos) minusSeconds(long seconds) plus(long amountToAdd, TemporalUnit unit) plus(TemporalAmount amountToAdd) plusDays(long days) plusMonths(long months) plusWeeks(long weeks) plusYears(long years) plusHours(long hours) plusMinutes(long minutes) plusNanos(long nanos) plusSeconds(long seconds) query(TemporalQuery query) range(TemporalField field) toString() with(TemporalAdjuster adjuster) with(TemporalField field, long newValue) withDayOfMonth(int dayOfMonth) withDayOfYear(int dayOfYear) withMonth(int month) withYear(int year) withHour(int hour) withMinute(int minute) withNano(int nanoOfSecond) withSecond(int second) 参考文献"},{"title":"MySQL 中的数据类型","date":"2023-05-16T16:00:00.000Z","url":"/blog/2023/05/17/mysql/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":[["MySQL","/blog/tags/MySQL/"]],"categories":[["MySQL","/blog/categories/MySQL/"]],"content":"MySQL 中的数据类型如下： 类型 类型举例 整数类型 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT 浮点类型 FLOAT、DOUBLE 定点数类型 DECIMAL 位类型 BIT 日期时间类型 YEAR、TIME、DATE、DATETIME、TIMESTAMP 文本字符串类型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 枚举类型 ENUM 集合类型 SET 二进制字符串类型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB JSON类型 JSON对象、JSON数组 空间数据类型 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 常见数据类型的属性，如下： MySQL 关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 整数类型类型介绍在 MySQL 中，整数类型一共有 5 种，分别是 TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT。它们的区别如下表所示： 整数类型 字节 有符号数取值范围 无符号数取值范围 TINYINT 1 -128~127 0~255 SMALLINT 2 -32768~32767 0~65535 MEDIUMINT 3 -8388608~8388607 0~16777215 INT 4 -2147483648~2147483647 0~4294967295 BIGINT 8 -9223372036854775808~9223372036854775807 0~18446744073709551615 可选属性整数类型有三个可选属性：M（显示宽度）、ZEROFILL（0填充）、UNSIGNED（无符号类型）。 M（显示宽度）M 表示显示宽度，取值范围是(0, 255)。例如 int(5)：当数据宽度小于 5 位时在数字前用字符填满宽度。该项功能需要配合 ZEROFILL 使用，表示用 0 填满宽度，否则指定显示宽度无效。在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。如果插入的数据宽度超过显示宽度，不会影响插入结果。如果在定义表的时候未指定数据宽度，系统为每一种类型指定默认的宽度值。从 MySQL 8.0.17 开始，整数数据类型不推荐使用显示宽度属性。 示例： ZEROFILLZEROFILL：0 填充，如果指定了 ZEROFILL 只是表示不够 M 位时，用 0 在整数左边填充。如果某列是 ZEROFILL，那么 MySQL 会自动为当前列添加 UNSIGNED 属性。最后， int(M) 必须和 UNSIGNED 和 ZEROFILL 一起使用才有意义。 示例： UNSIGNEDUNSIGNED: 无符号类型（非负），无符号整数类型的最小取值为0。int 类型默认显示宽度为 int(11)，无符号 int 类型默认显示宽度为 int(10)。 示例： 浮点类型类型介绍在 MySQL 中，浮点类型一共有 2 种，分别是 FLOAT 和 DOUBLE，它们的区别如下表所示： 浮点类型 字节 有符号数取值范围 无符号数取值范围 FLOAT 4 (-3.402823466E+38, -1.175494351E-38) 0(1.175494351E-38, 3.402823466E+38) 0(1.175494351E-38, 3.402823466E+38) DOUBLE 8 (-1.7976931348623157E+308, -2.2250738585072014E-308)0(2.2250738585072014E-308, 1.7976931348623157E+308) 0(2.2250738585072014E-308, 1.7976931348623157E+308) 注：MySQL 存储浮点数的格式为：符号(S)、尾数(M) 和 阶码(E)。无论有没有 UNSIGNED 修饰，MySQL 的浮点数都会存储表示符号的部分。所以，无符号数的取值范围，其实就是有符号数的取值范围大于等于零的部分。 精度误差说明浮点数类型有个缺陷，就是不精准。比如，我们设计一个表，有 f1 这个 double 类型的字段，插入值分别为 0.47 ,0.44 , 0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 &#x3D; 1.1。而使用 sum 之后查询： 查询结果是 1.0999999999999999。虽然误差很小，但确实有误差。原因是 MySQL 用二进制的方式来存储浮点类型数据。比如 9.625，用二进制来表达，就是 1001.101。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。在 MySQL 中也有精准的数据类型，就是定点数类型：DECIMAL。 定点数类型类型介绍在 MySQL 中，定点数类型只有 DECIMAL 一种类型。 数据类型 字节数 含义 DECIMAL(M,D) M+2 字节 有效范围由 M 和 D 决定 使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M 被称为精度，D 被称为标度。M &gt; D，0 &lt;&#x3D; M &lt;&#x3D; 65，0 &lt;&#x3D; D &lt;&#x3D; 30。例如，定义 DECIMAL（5,2） 的类型，表示该列取值范围是 -999.99~999.99 。当 DECIMAL 类型不指定精度和标度时，其默认为 DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时， MySQL 会进行四舍五入处理。 示例： DECIMAL(M,D) 的最大取值范围与 DOUBLE 类型一样，但是有效的数据范围是由 M 和 D 决定的。DECIMAL 的存储空间并不是固定的，由精度值 M 决定，总共占用的存储空间为 M + 2 个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。定点数在 MySQL 内部是以字符串的形式进行存储，这就决定了它一定是精准的。 位类型类型介绍BIT 类型中存储的是二进制值，类似 010110。 二进制字符串类型 长度 长度范围 占用空间 BIT(M) M 1 &lt;&#x3D; M &lt;&#x3D; 64 约为(M + 7)&#x2F;8个字节 示例： 日期与时间类型MySQL 有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0 版本支持的日期和时间类型主要有：YEAR 类型、TIME 类型、DATE 类型、DATETIME 类型和 TIMESTAMP 类型。 YEAR类型用来表示年 DATE类型用来表示年、月、日 TIME类型用来表示时、分、秒 DATETIME类型用来表示年、月、日、时、分、秒 TIMESTAMP类型用来表示带时区的年、月、日、时、分、秒 类型 名称 字节 日期格式 最小值 最大值 YEAR 年 1 YYYY 1901 2155 TIME 时间 3 HH:MM:SS -838:59:59 838:59:59 DATE 日期 3 YYYY-MM-DD 1000-01-01 9999-12-03 DATETIME 日期时间 8 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 TIMESTAMP 日期时间 4 YYYY-MM-DD HH:MM:SS 1970-01-01 00:00:00 UTC 2038-01-19 03:14:07UTC TIME 类型的取值范围不是 -23:59:59～23:59:59，是因为 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。 YEAR 类型YEAR 类型用来表示年份，从 MySQL5.5.27 开始，2 位格式的 YEAR 不推荐使用，所以本章不演示 2 位格式的用法。YEAR 默认格式是 YYYY，所以没必要写成 YEAR(4)。 示例： DATE 类型DATE 类型表示日期，没有时间部分，格式为YYYY-MM-DD，其中，YYYY 表示年份，MM 表示月份，DD 表示日期。在向 DATE 类型的字段插入数据时，字符串日期需要满足 YYYY-MM-DD 格式或者 YYYYMMDD 格式，其最小取值为1000-01-01，最大取值为9999-12-03。使用 CURDATE() 或者 NOW() 函数，会插入当前系统的日期。 示例： TIME 类型TIME 类型用来表示时间，不包含日期部分。可以使用 HH:MM:SS 格式来表示 TIME 类型，其中，HH 表示小时，MM 表示分钟，SS 表示秒。 在 MySQL 中，向 TIME 类型的字段插入数据时，也可以使用几种不同的格式。（1）可以使用带有冒号的字符串，比如 HH:MM:SS、D HH:MM:SS、HH:MM、D HH:MM、D HH或SS格式，都能被正确地插入 TIME 类型的字段中。其中 D 表示天，其最小值为 0，最大值为 34。如果使用带有 D 格式的字符串插入 TIME 类型的字段时，D 会被转化为小时，计算格式为 D * 24 + HH。（2）可以使用不带有冒号的字符串或者数字，格式为 HHMMSS 或 MMSS。比如 1210，MySQL 会将最右边的两位解析成秒，表示 00:12:10，而不是 12:10:00。（3）使用 CURRENT_TIME() 或者 NOW()，会插入当前系统的时间。 示例： DATETIME 类型DATETIME 类型在格式上为 DATE 类型和 TIME 类型的组合，可以表示为 YYYY-MM-DD HH:MM:SS，其中 YYYY 表示年份，MM 表示月份，DD 表示日期，HH 表示小时，MM 表示分钟，SS 表示秒。以 YYYY-MM-DD HH:MM:SS 格式或者 YYYYMMDDHHMMSS 格式的字符串插入 DATETIME 类型的字段时，最小值为 1000-01-01 00:00:00，最大值为 9999-12-03 23:59:59。使用函数 NOW()，可以向 DATETIME 类型的字段插入系统的当前日期和时间。 示例： TIMESTAMP 类型TIMESTAMP 类型也可以表示日期时间，其显示格式与 DATETIME 类型相同，都是 YYYY-MM-DD HH:MM:SS。TIMESTAMP 存储的时间范围比 DATETIME 要小很多，只能存储 1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC 之间的时间。如果向 TIMESTAMP 类型的字段插入的时间超出了 TIMESTAMP 类型的范围，则 MySQL 会抛出错误信息。存储数据的时候 MySQL 会对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用 TIMESTAMP 存储的同一个时间值，在不同的时区查询时会显示不同的时间。 示例： 文本字符串类型CHAR 与 VARCHAR 类型CHAR 和 VARCHAR 类型都是存储比较短的字符串，它们的区别如下表所示： 字符串（文本）类型 特点 长度范围（字符） CHAR(M) 字符长度固定，字节长度不固定 0 &lt;&#x3D; M &lt;&#x3D; 255 VARCHAR(M) 字符长度不固定，字节长度不固定 0 &lt;&#x3D; M &lt;&#x3D; 21845 CHAR 类型 CHAR(M) 类型一般需要预先定义字符串长度。如果不指定 (M)，则表示长度默认是 1 个字符。在 MySQL 中，一个字母是一个字符，一个汉字也是一个字符，但在 utf8mb4 编码中，一个字母用一个字节存储，一个汉字用三个字节存储，所以 CHAR(M) 的字符长度固定，但字节长度并不固定。 如果保存时，数据的实际长度比 CHAR 类型声明的长度小，则会在右侧填充空格以达到指定的长度。当 MySQL 检索 CHAR 类型的数据时，CHAR 类型的字段会去除尾部的空格。如果插入的数据中尾部有空格，也会被除去。 示例： VARCHAR 类型 VARCHAR(M) 定义时，必须指定长度 M，否则报错。 MySQL5.0 版本以上，varchar(20) 指的是 20 字符。 检索 VARCHAR 类型的字段数据时，会保留数据尾部的空格。VARCHAR 类型的字段会多用1个字节用来存储长度信息。 示例： TEXT 类型在 MySQL 中，TEXT 用来保存文本类型的字符串，总共包含4种类型，分别为 TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。 在向 TEXT 类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。 检索 TEXT 类型的字段数据时，会保留数据尾部的空格。 它们的区别如下表所示： 文本字符串类型 特点 长度 长度范围（字节） 占用的存储空间 TINYTEXT 小文本、可变长度 L 0 &lt;&#x3D; L &lt;&#x3D; 255（256B） L + 2 个字节 TEXT 文本、可变长度 L 0 &lt;&#x3D; L &lt;&#x3D; 65535（64KB） L + 2 个字节 MEDIUMTEXT 中等文本、可变长度 L 0 &lt;&#x3D; L &lt;&#x3D; 16777215（16MB） L + 3 个字节 LONGTEXT 大文本、可变长度 L 0 &lt;&#x3D; L&lt;&#x3D; 4294967295（4GB） L + 4 个字节 TEXT 类型的长度范围是以字节为单位，例如 TINYTEXT 类型最大存储空间可支持 255 个字节，那么 TINYTEXT 类型的字段在 utf8mb4 编码格式中可存储 255 个英文字母或 85 个汉字。MySQL 不允许 TEXT 类型的字段做主键。 示例： ENUM 类型ENUM 类型也叫作枚举类型。当ENUM类型包含1～255个成员时，需要1个字节的存储空间；当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。 文本字符串类型 长度 长度范围 占用的存储空间 ENUM L 1 &lt;&#x3D; L &lt;&#x3D; 65535 1 或 2 个字节 示例： SET 类型SET 表示一个字符串对象，可以包含 0 个或多个成员，但成员个数的上限为 64。设置字段值时，可以取取值范围内的 0 个或多个值，这一点与 ENUM 类型不同。 当 SET 类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下： 成员个数范围（L表示实际成员个数） 占用的存储空间 1 &lt;&#x3D; L &lt;&#x3D; 8 1个字节 9 &lt;&#x3D; L &lt;&#x3D; 16 2个字节 17 &lt;&#x3D; L &lt;&#x3D; 24 3个字节 25 &lt;&#x3D; L &lt;&#x3D; 32 4个字节 33 &lt;&#x3D; L &lt;&#x3D; 64 8个字节 示例： 二进制字符串类型MySQL 中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。在实际开发中，这种类型的字段很少遇到。 MySQL 中支持的二进制字符串类型主要包括 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 类型。 BINARY 与 VARBINARY 类型BINARY(M) 为固定长度的二进制字符串，M 表示最多能存储的字节数，取值范围是 0~255 个字符。如果未指定 (M)，默认值为 1。如果字段值不足 (M) 个字节，将在右边填充 \\0 以补齐指定长度。 VARBINARY(M) 为可变长度的二进制字符串，M 表示最多能存储的字节数，总字节数不能超过 65535。另外还要考虑额外字节开销，VARBINARY 类型的数据除了存储数据本身外，还需要 1 或 2 个字节来存储数据的字节数。VARBINARY类型必须指定 (M)，否则报错。 它们的区别如下表所示： 二进制字符串类型 特点 值的长度（字节） 占用空间 BINARY(M) 固定长度 M （0 &lt;&#x3D; M &lt;&#x3D; 255） M个字节 VARBINARY(M) 可变长度 M（0 &lt;&#x3D; M &lt;&#x3D; 65535） M+1个字节 有人会将 BINARY 和 VARBINARY 跟 CHAR 和 VARCHAR 进行类比，确实有相似的地方，那么我列举几个不同点： BINARY 和 VARBINARY 类型的值的长度以字节为单位，而 CHAR 和 VARCHAR 以字符为单位。 BINARY 字段值不足 (M) 个字节时，将在右边填充 \\0 以补齐指定长度，在检索时不会除去 \\0。而 CHAR 不足(M) 个字节，将在右边填充空格，但在检索时会除去空格。 示例： BLOB 类型BLOB是一个二进制大对象，可以容纳可变数量的数据。类型包括 TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们的区别如下表所示： 二进制字符串类型 值的长度 长度范围 占用空间 TINYBLOB L 0 &lt;&#x3D; L &lt;&#x3D; 255（256B） L + 1 个字节 BLOB L 0 &lt;&#x3D; L &lt;&#x3D; 65535（64KB） L + 2 个字节 MEDIUMBLOB L 0 &lt;&#x3D; L &lt;&#x3D; 16777215 （16MB） L + 3 个字节 LONGBLOB L 0 &lt;&#x3D; L &lt;&#x3D; 4294967295（4GB） L + 4 个字节 在实际工作中，往往不会在 MySQL 数据库中使用 BLOB 类型存储大对象数据，通常会将图片、音频和视频文件存储到服务器的磁盘上，并将图片、音频和视频的访问路径存储到 MySQL 中。 JSON 类型在 MySQL 5.7 中，就已经支持 JSON 数据类型。在 MySQL 8.x 版本中，JSON 类型提供了可以进行自动验证的 JSON 文档和优化存储结构，使得在 MySQL 中存储和读取 JSON 类型的数据更加方便和高效。示例： 空间类型MySQL 空间类型支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL 中使用 Geometry（几何） 来表示所有地理特征。Geometry 指一个点或点的集合，代表世界上任何具有位置的事物。 MySQL 的空间数据类型对应于 OpenGIS 类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 。 Geometry 是所有空间集合类型的基类，其他类型如 POINT、LINESTRING、POLYGON 都是 Geometry 的子类。 Point：用坐标值表示一个点，例如 POINT(121.213342 31.234532)、POINT(30 10)，坐标值支持DECIMAL类型，经度在前，维度在后，用空格分隔。 LineString：由一系列点表示线，例如 LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与 POINT 格式一致。 Polygon：由多条线表示多边形，例如POLYGON((0 0,10 0,10 10, 0 10))。 下面展示几种常见的几何图形元素： MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这4种类型都是集合类，是多个 Point、LineString 或 Polygon 组合而成。 下面展示的是多个同类或异类几何图形元素的组合： 示例： "},{"title":"MySQL 中常用的函数","date":"2023-05-14T16:00:00.000Z","url":"/blog/2023/05/15/mysql/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","tags":[["MySQL","/blog/tags/MySQL/"]],"categories":[["MySQL","/blog/categories/MySQL/"]],"content":"数值函数基本函数ABS(x)返回x的绝对值 SIGN(x)返回x的符号。正数返回1，负数返回-1，0返回0 PI()返回圆周率的值 CEIL(x)，CEILING(x)返回大于或等于某个值的最小整数 FLOOR(x)返回小于或等于某个值的最大整数 LEAST(e1,e2,e3…)返回列表中的最小值 GREATEST(e1,e2,e3…)返回列表中的最大值 MOD(x,y)返回x除以y后的余数 RAND()返回0~1的随机值 RAND(x)返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数 ROUND(x)四舍五入，保留整数部分 ROUND(x,y)四舍五入，并保留到小数点后面y位 TRUNCATE(x,y)返回数字x截断为y位小数的结果 SQRT(x)返回x的平方根。当X的值为负数时，返回NULL 角度与弧度互转函数RADIANS(x)将角度转化为弧度，其中，参数x为角度值 DEGREES(x)将弧度转化为角度，其中，参数x为弧度值 三角函数SIN(x)返回x的正弦值，其中，参数x为弧度值 ASIN(x)返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL COS(x)返回x的余弦值，其中，参数x为弧度值 ACOS(x)返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL TAN(x)返回x的正切值，其中，参数x为弧度值 ATAN(x)返回x的反正切值，即返回正切值为x的值 ATAN2(m,n)返回两个参数的反正切值 指数与对数POW(x,y)，POWER(x,y)返回x的y次方 EXP(x)返回e的X次方，其中e是一个常数，2.718281828459045 LN(x)，LOG(x)返回以e为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL LOG10(x)返回以10为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL LOG2(x)返回以2为底的X的对数，当X &lt;&#x3D; 0 时，返回NULL 进制间的转换BIN(x)返回x的二进制编码 HEX(x)返回x的十六进制编码 OCT(x)返回x的八进制编码 CONV(x,f1,f2)返回f1进制数变成f2进制数 字符串函数在 MySQL 中，字符串都是从1开始的。 ASCII(S)返回字符串S中的第一个字符的ASCII码值 CHAR_LENGTH(s)返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同 LENGTH(s)返回字符串s的字节数，和字符集有关 CONCAT(s1,s2,……,sn)连接s1,s2,……,sn为一个字符串 CONCAT_WS(x, s1,s2,……,sn)同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x INSERT(str, idx, len, replacestr)将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr REPLACE(str, a, b)用字符串b替换字符串str中所有出现的字符串a UPPER(s) 和 UCASE(s)将字符串s的所有字母转成大写字母 LOWER(s) 和 LCASE(s)将字符串s的所有字母转成小写字母 LEFT(str,n)返回字符串str最左边的n个字符 RIGHT(str,n)返回字符串str最右边的n个字符 LPAD(str, len, pad)用字符串pad对str最左边进行填充，直到str的长度为len个字符 RPAD(str ,len, pad)用字符串pad对str最右边进行填充，直到str的长度为len个字符 LTRIM(s)去掉字符串s左侧的空格 RTRIM(s)去掉字符串s右侧的空格 TRIM(s)去掉字符串s开始与结尾的空格 TRIM(s1 FROM s)去掉字符串s开始与结尾的s1 TRIM(LEADING s1 FROM s)去掉字符串s开始处的s1 TRIM(TRAILING s1 FROM s)去掉字符串s结尾处的s1 REPEAT(str, n)返回str重复n次的结果 SPACE(n)返回n个空格 STRCMP(s1,s2)比较字符串s1,s2的ASCII码值的大小 SUBSTR(s,index,len)返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同 LOCATE(substr,str)返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0 ELT(m,s1,s2,…,sn)返回指定位置的字符串，如果m&#x3D;1，则返回s1，如果m&#x3D;2，则返回s2，如果m&#x3D;n，则返回sn FIELD(s,s1,s2,…,sn)返回字符串s在字符串列表中第一次出现的位置 FIND_IN_SET(s1,s2)返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 REVERSE(s)返回s反转后的字符串 NULLIF(value1,value2)比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1 日期和时间函数获取日期和时间函数CURDATE()返回当前日期，只包含年、月、日 CURTIME()返回当前时间，只包含时、分、秒 NOW()返回当前系统日期和时间 UTC_DATE()返回 UTC（世界标准时间）日期 UTC_TIME()返回 UTC（世界标准时间）时间 日期与时间戳的转换函数UNIX_TIMESTAMP()以 UNIX 时间戳的形式返回当前时间，不管 MySQL 的时区是什么，返回结果都一样，都是此刻 UTC 时区的时间距离 1970-01-01 00:00:00 的秒数。 UNIX_TIMESTAMP(date)将 date 以 UNIX 时间戳的形式返回，date 跟时区挂钩，MySQL 被设置成哪个时区，date 就被认为是哪个时区的时间。 FROM_UNIXTIME(timestamp)将 UNIX 时间戳转换为普通格式的时间，传入的参数是距离 UTC 1970-01-01 00:00:00 的秒数，返回的是跟时区相关的时间。例如，我传入的是 0 ，对应 UTC 1970-01-01 00:00:00 时间，如果 MySQL 的时区为北京时间，比 UTC 快 8 小时，那么 from_unixtime(0) 会将 UTC 1970-01-01 00:00:00 转换成北京时间 1970-01-01 08:00:00。 获取月份、星期、天数等函数YEAR(date) \\ MONTH(date)\\ DAY(date)返回具体的日期值 HOUR(time) \\ MINUTE(time) \\ SECOND(time)返回具体的时间值 MONTHNAME(date)返回月份：January，… DAYNAME(date)返回星期几：MONDAY，TUESDAY…..SUNDAY WEEKDAY(date)返回周几，注意，周1是0，周2是1，。。。周日是6 QUARTER(date)返回日期对应的季度，范围为1～4 WEEKOFYEAR(date)返回一年中的第几周 DAYOFYEAR(date)返回日期是一年中的第几天 DAYOFMONTH(date)返回日期位于所在月份的第几天 DAYOFWEEK(date)返回周几，注意：周日是1，周一是2，。。。周六是7 日期的操作函数EXTRACT(type FROM date)返回指定日期中特定的部分，type 指定返回的值。 EXTRACT(type FROM date)函数中type的取值与含义： type 取值 含义 MICROSECOND 返回毫秒数 SECOND 返回秒数 MINUTE 返回分钟数 HOUR 返回小时数 DAY 返回天数 WEEK 返回日期在一年中的第几个星期 MONTH 返回日期在一年中的第几个月 QUARTER 返回日期在一年中的第几个季度 YEAR 返回日期的年份 SECOND_MICROSECOND 返回秒和毫秒值 MINUTE_MICROSECOND 返回分钟和毫秒值 MINUTE_SECOND 返回分钟和秒值 HOUR_MICROSECOND 返回小时和毫秒值 HOUR_SECOND 返回小时和秒值 HOUR_MINUTE 返回小时和分钟值 DAY_MICROSECOND 返回天和毫秒值 DAY_SECOND 返回天和秒值 DAY_MINUTE 返回天和分钟值 DAY_HOUR 返回天和小时 YEAR_MONTH 返回年和月 时间和秒钟转换的函数TIME_TO_SEC(time)将 time 转化为秒并返回结果值。转化的公式为：小时3600+分钟60+秒 SEC_TO_TIME(seconds)将 seconds 描述转化为包含小时、分钟和秒的时间 计算日期和时间的函数DATE_ADD(datetime, INTERVAL expr type)DATE_SUB(datetime, INTERVAL expr type)返回与datetime相差INTERVAL时间间隔的日期时间。 上述函数中type的取值： type 取值 含 义 HOUR 小时 MINUTE 分钟 SECOND 秒 YEAR 年 MONTH 月 DAY 日 YEAR_MONTH 年和月 DAY_HOUR 日和小时 DAY_MINUTE 日和分钟 DAY_SECOND 日和秒 HOUR_MINUTE 小时和分钟 HOUR_SECOND 小时和秒 MINUTE_SECOND 分钟和秒 ADDTIME(time1,time2)返回time1加上time2的时间 SUBTIME(time1,time2)返回time1减去time2后的时间 DATEDIFF(date1,date2)返回date1 - date2的日期间隔天数 TIMEDIFF(time1, time2)返回time1 - time2的时间间隔 FROM_DAYS(N)返回从0000年1月1日起，N天以后的日期 TO_DAYS(date)返回日期date距离0000年1月1日的天数 LAST_DAY(date)返回date所在月份的最后一天的日期 MAKEDATE(year,n)针对给定年份与所在年份中的天数返回一个日期 MAKETIME(hour,minute,second)将给定的小时、分钟和秒组合成时间并返回 日期的格式化与解析DATE_FORMAT(date,fmt)按照字符串fmt格式化日期date值 TIME_FORMAT(time,fmt)按照字符串fmt格式化时间time值 STR_TO_DATE(str, fmt)按照字符串fmt对str进行解析，解析为一个日期。 上述函数中fmt参数常用的格式符： 格式符 说明 格式符 说明 %Y 4位数字表示年份 %y 表示两位数字表示年份 %M 月名表示月份（January,….） %m 两位数字表示月份（01,02,03。。。） %b 缩写的月名（Jan.，Feb.，….） %c 数字表示月份（1,2,3,…） %D 英文后缀表示月中的天数（1st,2nd,3rd,…） %d 两位数字表示月中的天数(01,02…) %e 数字形式表示月中的天数（1,2,3,4,5…..） %H 两位数字表示小数，24小时制（01,02..） %h和%I 两位数字表示小时，12小时制（01,02..） %k 数字形式的小时，24小时制(1,2,3) %l 数字形式表示小时，12小时制（1,2,3,4….） %i 两位数字表示分钟（00,01,02） %S和%s 两位数字表示秒(00,01,02…) %W 一周中的星期名称（Sunday…） %a 一周中的星期缩写（Sun.，Mon.,Tues.，..） %w 以数字表示周中的天数(0&#x3D;Sunday,1&#x3D;Monday….) %j 以3位数字表示年中的天数(001,002…) %U 以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天 %u 以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天 %T 24小时制 %r 12小时制 %p AM或PM %% 表示% GET_FORMAT(date_type,format_type)返回日期字符串的显示格式。GET_FORMAT 函数中 date_type 和 format_type 参数取值如下： 日期类型 格式化类型 返回的格式化字符串 DATE USA %m.%d.%Y DATE JIS %Y-%m-%d DATE ISO %Y-%m-%d DATE EUR %d.%m.%Y DATE INTERNAL %Y%m%d TIME USA %h:%i:%s %p TIME JIS %H:%i:%s TIME ISO %H:%i:%s TIME EUR %H.%i.%s TIME INTERNAL %H%i%s DATETIME USA %Y-%m-%d %H.%i.%s DATETIME JIS %Y-%m-%d %H:%i:%s DATETIME ISO %Y-%m-%d %H:%i:%s DATETIME EUR %Y-%m-%d %H.%i.%s DATETIME INTERNAL %Y%m%d%H%i%s 流程控制函数IF(value,value1,value2)如果value的值为TRUE，返回value1，否则返回value2 IFNULL(value1, value2)如果value1不为NULL，返回value1，否则返回value2 CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn] END相当于Java的if…else if…else… CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END相当于Java的switch…case… 加密函数MD5(str)返回字符串 str 的 md5 加密后的值，也是一种加密方式。若参数为 NULL，则会返回 NULL SHA(str)从原明文密码 str 计算并返回加密后的密码字符串，当参数为 NULL 时，返回 NULL。SHA加密算法比MD5更加安全。 MySQL信息函数.sqlVERSION()返回当前MySQL的版本号 CONNECTION_ID()返回当前MySQL服务器的连接数 DATABASE()返回MySQL命令行当前所在的数据库 USER()返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名” CHARSET(value)返回字符串value自变量的字符集 COLLATION(value)返回字符串value的比较规则 聚合函数AVG()求平均值 SUM()求累加和 MAX()求最大值 MIN() 求最小值 COUNT()统计行的数量 其他函数INET_ATON(ipvalue)将以点分隔的IP地址转化为一个数字。 计算方法以“127.0.0.1”为例，计算方式为127乘以256的3次方，加上0乘以256的2次方，加上0乘以256，再加上1。 INET_NTOA(value)将数字形式的IP地址转化为以点分隔的IP地址 BENCHMARK(n,expr)将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间 CONVERT(value USING char_code)将value所使用的字符编码修改为char_code "},{"title":"【Java 8 新特性】时间类：ZoneId 和 ZoneOffset","date":"2023-05-10T16:00:00.000Z","url":"/blog/2023/05/11/Java8/time/ZoneId_ZoneOffset/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"本章介绍 java.time 包下两个跟时差相关的类： ZoneId 和 ZoneOffset。 ZoneId：ZoneId 是一个抽象类，它有两个实现类，其中 ZoneRegion 用于表示时区，ZoneOffset 用于表示跟 UTC 时区的偏移量，ZoneId 提供了创建这两种对象的静态方法。因为 ZoneRegion 没有对外提供创建 ZoneRegion 对象的方法，只能由 ZoneId 的静态方法创建，并且没有扩展其它方法，因此本章不做介绍。 ZoneOffset：用来表示跟 UTC 时区的偏移量。 ZoneId在 Java 8 中，跟时区相关的操作通常涉及到 ZoneId 。ZoneId 用来表示时区或偏移量，它用于将时间与时差（以 UTC 为基准）联系起来，以便于表示和计算。在 Java 中，时区都以标准的区域 ID 字符串表示，如 Asia/Shanghai 或 America/New_York 等。 公共常量 静态方法from(TemporalAccessor temporal) getAvailableZoneIds() of(String zoneId)of(String zoneId, Map&lt;String,String&gt; aliasMap)ofOffset(String prefix, ZoneOffset offset) systemDefault() 成员方法getId() getRules() normalized() 未演示方法 equals(Object obj) getDisplayName(TextStyle style, Locale locale) hashCode() toString() ZoneOffsetZoneOffset 类表示一个时区偏移量，它表示与 UTC 时间之间的时间差。偏移量的范围为从 UTC-18:00 到 UTC+18:00，以小时为单位。 公共常量 静态方法from(TemporalAccessor temporal) of(String offsetId)ofHours(int hours)ofHoursMinutes(int hours, int minutes)ofHoursMinutesSeconds(int hours, int minutes, int seconds)ofTotalSeconds(int totalSeconds) 成员方法getId() getRules() getTotalSeconds() 未演示方法 adjustInto(Temporal temporal) compareTo(ZoneOffset other)getDays() equals(Object obj) get(TemporalField field) getLong(TemporalField field) hashCode() isSupported(TemporalField field) query(TemporalQuery query) range(TemporalField field) toString() 参考文献"},{"title":"Idea 常用快捷键","date":"2023-05-09T16:00:00.000Z","url":"/blog/2023/05/10/Idea/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","tags":[["Idea","/blog/tags/Idea/"]],"categories":[["Idea","/blog/categories/Idea/"]],"content":" 描述 快捷键 代码上移&#x2F;下移 Shift + Alt + ↑&#x2F;↓ 当前行之后开始新行 Shift + Enter 快速查看文档 Ctrl + Q 查看类中的方法 Ctrl + F12 在全局搜索切换作用域 Alt + P 切换大小写 Ctrl + Shift + U 插入代码模板 Ctrl + J 重构 描述 快捷键 提取变量 Ctrl + Alt + V 修改变量名 Shift + F6 数据库 描述 快捷键 查询表中的数据 F4 搜索列 Ctrl + F12 调试 描述 快捷键 步过 F8 步入 F7 步出 Shift + F8 运行到光标处 Alt + F9 对表达式求值 Alt + F8 调试程序 Alt + Shift + F9 运行程序 Ctrl + Shift + F10 界面 描述 快捷键 打开终端界面 Alt + F12 打开服务界面 Alt + 8 打开运行界面 Alt + 4 打开调试界面 Alt + 5 打开数据库界面 Alt + D（自定义） 打开菜单栏 Alt + 英文字母 书签 描述 快捷键 创建标签 F11 打开标签列表 Shift + F11 F2 修改标签名 Ctrl + Shift + ↑&#x2F;↓ 上下移动标签（不可用） IDEA 快捷键无法使用的原因原因是 IDEA 自带的快捷键跟其他软件的快捷键发生冲突，以下是 IDEA 的快捷键可能会与其他软件的快捷键发送冲突： Ctrl + Alt + V：搜狗输入法、有道词典、QQ 音乐 F8: 有道词典"},{"title":"【Java 8 新特性】时间类：Instant","date":"2023-05-09T16:00:00.000Z","url":"/blog/2023/05/10/Java8/time/Instant/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"Instant是一个用来表示时间戳的类，与 LocalDateTime 有类似的地方，都没有时区概念，都记录了日期和时间的信息。不同的是 LocalDateTime通过记录年月日时分秒等数据来表示日期和时间，而Instant通过记录距离1970-01-01T00:00:00Z的秒数和纳秒数来表示日期和时间，因此 Instant 常用来作为新旧时间类转换的媒介。Instant 虽然没有时区的概念，但我都是作为 UTC 时区的时间来使用。Instant 对象的输出结果中末尾的 Z 表示距 UTC 时区的偏移量为 0。 公共常量 静态方法from(TemporalAccessor temporal) now()now(Clock clock) ofEpochMilli(long epochMilli)ofEpochSecond(long epochSecond)ofEpochSecond(long epochSecond, long nanoAdjustment) parse(CharSequence text) 成员方法atOffset(ZoneOffset offset)atZone(ZoneId zone) toEpochMilli() truncatedTo(TemporalUnit unit) until(Temporal endExclusive, TemporalUnit unit) 未演示方法 adjustInto(Temporal temporal) compareTo(Instant otherInstant) isAfter(Instant otherInstant) isBefore(Instant otherInstant) equals(Object obj) get(TemporalField field) getLong(TemporalField field) getEpochSecond() getNano() isSupported(TemporalField field) isSupported(TemporalUnit unit) minus(long amountToSubtract, TemporalUnit unit) minus(TemporalAmount amountToSubtract) minusMillis(long millisToSubtract) minusNanos(long nanosToSubtract) minusSeconds(long secondsToSubtract) plus(long amountToAdd, TemporalUnit unit) plus(TemporalAmount amountToAdd) plusMillis(long millisToAdd) plusNanos(long nanosToAdd) plusSeconds(long secondsToAdd) query(TemporalQuery query) range(TemporalField field) toString() with(TemporalAdjuster adjuster) with(TemporalField field, long newValue) hashCode() 参考文献"},{"title":"【Java 8 新特性】时间类：Duration 和 Period","date":"2023-05-09T16:00:00.000Z","url":"/blog/2023/05/10/Java8/time/Duration_Period/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"本章介绍 java.time 包下两个跟时间长度相关的类： Duration 和 Period。 Duration：表示两个时间点之间的时间长度，可以表示纳秒、秒、分钟、小时等等。 Period：表示两个日期之间的时间跨度，精确到年、月、日单位。 DurationDuration 类由两个变量 seconds 和 nanos 组成，适用于计算时间间隔，比如计算两个时间点之间相差的秒数、毫秒数等等，可以表示时间的长度精度到纳秒级别。 公共常量 静态方法parse(CharSequence text) between(Temporal startInclusive, Temporal endExclusive) of(long amount, TemporalUnit unit)ofDays(long days)ofHours(long hours)ofMinutes(long minutes)ofSeconds(long seconds)ofSeconds(long seconds, long nanoAdjustment)ofMillis(long millis)ofNanos(long nanos) 成员方法abs()negated() addTo(Temporal temporal)subtractFrom(Temporal temporal) compareTo(Duration otherDuration) multipliedBy(long multiplicand)dividedBy(long divisor) getUnits() 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用类似，该篇章就不在赘述了。 equals(Object otherDuration) get(TemporalUnit unit) getNano() getSeconds() hashCode() minus(Duration duration) minus(long amountToSubtract, TemporalUnit unit) minusDays(long daysToSubtract) minusHours(long hoursToSubtract) minusMillis(long millisToSubtract) minusMinutes(long minutesToSubtract) minusNanos(long nanosToSubtract) minusSeconds(long secondsToSubtract) plus(Duration duration) plus(long amountToAdd, TemporalUnit unit) plusDays(long daysToAdd) plusHours(long hoursToAdd) plusMillis(long millisToAdd) plusMinutes(long minutesToAdd) plusNanos(long nanosToAdd) plusSeconds(long secondsToAdd) toString() withNanos(int nanoOfSecond) withSeconds(long seconds) PeriodPeriod 类由三个变量 years、months 和 days 组成，适用于更大的时间跨度，比如计算两个日期之间相差的年数、月数、天数。 公共常量 静态方法parse(CharSequence text) between(LocalDate startDateInclusive, LocalDate endDateExclusive) of(int years, int months, int days)ofDays(int days)ofMonths(int months)ofWeeks(int weeks)ofYears(int years) 成员方法addTo(Temporal temporal)subtractFrom(Temporal temporal) getUnits() isNegative()isZero() multipliedBy(int scalar)negated() normalized()toTotalMonths() 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用类似，该篇章就不在赘述了。 equals(Object otherDuration) get(TemporalUnit unit) getDays() getSeconds() getMonths() getYears() hashCode() minus(TemporalAmount amountToSubtract) minusDays(long daysToSubtract) minusMonths(long monthsToSubtract) minusYears(long yearsToSubtract) plus(TemporalAmount amountToAdd) plusDays(long daysToAdd) plusMonths(long monthsToAdd) plusYears(long yearsToAdd) toString() withDays(int days) withMonths(int months) withYears(int years) 参考文献"},{"title":"【Java 8 新特性】时间类：MonthDay 、 YearMonth 和 Year","date":"2023-05-08T16:00:00.000Z","url":"/blog/2023/05/09/Java8/time/MonthDay_YearMonth_Year/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"本章介绍 java.time 包下的三个日期类： MonthDay 、YearMonth 和 Year，三个都是不可变的日期时间对象。 MonthDay：由两个int类型的变量 month 和 day 组成，表示一年中的某个月以及该月中的某一天。 YearMonth：由两个int类型的变量 year 和 month 组成，表示一年中的某个月份。 Year：由一个int类型的变量 year 表示，表示一个特定的年份。 MonthDay MonthDay 类代表了一年中的某个月以及该月中的某一天，但不含年份信息。它可以被用来表示诸如生日、纪念日、节日等日期，而不需要指定具体的年份。 静态方法from(TemporalAccessor temporal) now()now(ZoneId zone)now(Clock clock) of(int month, int dayOfMonth)of(Month month, int dayOfMonth) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) 成员方法atYear(int year) isValidYear(int year) 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用相同，该篇章就不在赘述了。 adjustInto(Temporal temporal) compareTo(MonthDay other) isAfter(MonthDay other) isBefore(MonthDay other) equals(Object obj) format(DateTimeFormatter formatter) get(TemporalField field) getLong(TemporalField field) getDayOfMonth() getMonth() getMonthValue() hashCode() isSupported(TemporalField field) query(TemporalQuery query) range(TemporalField field) toString() with(Month month) withDayOfMonth(int dayOfMonth) withMonth(int month) YearMonthYearMonth 类代表了一年中的某个月份，但不含具体的日期信息。它可以被用来表示一些周期性的事件，如月度财务报告、月度账单结算等。它也可以很方便地用于计算某个月份的天数等信息。 静态方法from(TemporalAccessor temporal) now()now(ZoneId zone)now(Clock clock) of(int year, int month)of(int year, Month month) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) 成员方法atDay(int dayOfMonth)atEndOfMonth() isLeapYear()isValidDay(int dayOfMonth) lengthOfMonth()lengthOfYear() 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用相同，该篇章就不在赘述了。 adjustInto(Temporal temporal) compareTo(YearMonth other) isAfter(YearMonth other) isBefore(YearMonth other) equals(Object obj) format(DateTimeFormatter formatter) get(TemporalField field) getLong(TemporalField field) getMonth() getMonthValue() getYear() hashCode() isSupported(TemporalField field) isSupported(TemporalUnit unit) minus(long amountToSubtract, TemporalUnit unit) minus(TemporalAmount amountToSubtract) minusMonths(long monthsToSubtract) minusYears(long yearsToSubtract) plus(long amountToAdd, TemporalUnit unit) plus(TemporalAmount amountToAdd) plusMonths(long monthsToAdd) plusYears(long yearsToAdd) query(TemporalQuery query) range(TemporalField field) toString() until(Temporal endExclusive, TemporalUnit unit) with(TemporalAdjuster adjuster) with(TemporalField field, long newValue) withMonth(int month) withYear(int year) YearYear 类代表了一个特定的年份，不包含月份和日期信息。 公共常量 静态方法from(TemporalAccessor temporal) isLeap(long year) now()now(ZoneId zone)now(Clock clock) of(int isoYear) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) 成员方法atDay(int dayOfYear)atMonthDay(MonthDay monthDay) atMonth(int month)atMonth(Month month) isLeap()isValidMonthDay(MonthDay monthDay) length() 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用相同，该篇章就不在赘述了。 adjustInto(Temporal temporal) compareTo(YearMonth other) isAfter(YearMonth other) isBefore(YearMonth other) equals(Object obj) format(DateTimeFormatter formatter) get(TemporalField field) getLong(TemporalField field) getValue() hashCode() isSupported(TemporalField field) isSupported(TemporalUnit unit) minus(long amountToSubtract, TemporalUnit unit) minus(TemporalAmount amountToSubtract) minusYears(long yearsToSubtract) plus(long amountToAdd, TemporalUnit unit) plus(TemporalAmount amountToAdd) plusYears(long yearsToAdd) query(TemporalQuery query) range(TemporalField field) toString() until(Temporal endExclusive, TemporalUnit unit) with(TemporalAdjuster adjuster) with(TemporalField field, long newValue) 参考文献"},{"title":"【Java 8 新特性】时间类：DayOfWeek 和 Month","date":"2023-05-07T16:00:00.000Z","url":"/blog/2023/05/08/Java8/time/DayOfWeek_Month/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"本章介绍 java.time 包下的两个枚举类： DayOfWeek 枚举和 Month 枚举。其中 DayOfWeek 类枚举了七个星期，对应整数1~7；Month 类枚举了12个月份，对应整数1~12。 DayOfWeek枚举类DayOfWeek 枚举类用于表示一周中的某一天，包括周一到周日七个枚举常量。 枚举值 静态方法from(TemporalAccessor temporal) of(int dayOfWeek) valueOf(String name) values() 成员方法adjustInto(Temporal temporal) getDisplayName(TextStyle style, Locale locale) getValue() plus(long months)minus(long months) 未演示方法以下方法在 LocalDate 和 LocalTime 篇章演示过且作用相同，该篇章就不在赘述了。 get(TemporalField field) getLong(TemporalField field) isSupported(TemporalField field) query(TemporalQuery query) range(TemporalField field) Month枚举类Month 枚举类用于表示一年中的某个月份，包括一月到十二月共12个枚举常量。 枚举值 静态方法from(TemporalAccessor temporal) of(int month) valueOf(String name) values() 成员方法adjustInto(Temporal temporal) firstDayOfYear(boolean leapYear) firstMonthOfQuarter() getDisplayName(TextStyle style, Locale locale) getValue() length(boolean leapYear) maxLength()minLength() plus(long months)minus(long months) 未演示方法以下方法在 LocalDate 和 LocalTime 篇章演示过且作用相同，该篇章就不在赘述了。 get(TemporalField field) getLong(TemporalField field) isSupported(TemporalField field) query(TemporalQuery query) range(TemporalField field) 参考文献"},{"title":"【Java 8 新特性】时间类：LocalDateTime","date":"2023-05-07T16:00:00.000Z","url":"/blog/2023/05/08/Java8/time/LocalDateTime/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"LocalDateTime 类用来表示日期和时间，由两个成员变量 date 和 time 组成。其中 date 对象属于 LocalDate 类，用来表示日期；time 对象属于 LocalTime 类，用来表示时间；LocalDateTime 类有非常多的成员方法的作用是跟LocalDate 类和 LocalTime 类中的方法一样，该篇章就不再赘述了。 公共常量 静态方法from(TemporalAccessor temporal) now()now(ZoneId zone)now(Clock clock) of(int year, int month, int dayOfMonth, int hour, int minute)of(int year, int month, int dayOfMonth, int hour, int minute, int second)of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)of(int year, Month month, int dayOfMonth, int hour, int minute)of(int year, Month month, int dayOfMonth, int hour, int minute, int second)of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)of(LocalDate date, LocalTime time)ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset)ofInstant(Instant instant, ZoneId zone) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) 成员方法atOffset(ZoneOffset offset)atZone(ZoneId zone) toLocalDate()toLocalTime() truncatedTo(TemporalUnit unit) until(Temporal endExclusive, TemporalUnit unit) 未演示方法以下方法大多在 LocalDate 和 LocalTime 篇章演示过且作用类似，该篇章就不在赘述了。 adjustInto(Temporal temporal) compareTo(ChronoLocalDateTime&lt;?&gt; other) isAfter(ChronoLocalDateTime&lt;?&gt; other) isBefore(ChronoLocalDateTime&lt;?&gt; other) isEqual(ChronoLocalDateTime&lt;?&gt; other) isSupported(TemporalField field) isSupported(TemporalUnit unit) equals(Object obj) format(DateTimeFormatter formatter) get(TemporalField field) getLong(TemporalField field) getXXX() minus(long amountToSubtract, TemporalUnit unit) minus(TemporalAmount amountToSubtract) minusXXX(long xxx) plus(long amountToAdd, TemporalUnit unit) plus(TemporalAmount amountToAdd) plusXXX(long xxx) query(TemporalQuery query) range(TemporalField field) with(TemporalAdjuster adjuster) with(TemporalField field, long newValue) withXXX(int xxx) hashCode() toString() 参考文献"},{"title":"【Java 8 新特性】时间类：LocalTime","date":"2023-05-06T16:00:00.000Z","url":"/blog/2023/05/07/Java8/time/LocalTime/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"LocalTime 类用来表示时间，由四个成员变量 hour 、 minute 、 second 和 nano 组成，分别表示时分秒纳秒。大部分成员方法是操作四个成员变量的过程，如查询由这四个变量组成的其他的时间分量，对四个变量进行加、减或重新赋予新值等等操作。 公共常量 静态方法from(TemporalAccessor temporal) now()now(ZoneId zone)now(Clock clock) of(int hour, int minute)of(int hour, int minute, int second)of(int hour, int minute, int second, int nanoOfSecond)ofSecondOfDay(long secondOfDay)ofNanoOfDay(long nanoOfDay) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) 成员方法atDate(LocalDate date) atOffset(ZoneOffset offset) compareTo(LocalTime other)isAfter(LocalTime other)isBefore(LocalTime other) format(DateTimeFormatter formatter) isSupported(TemporalField field)isSupported(TemporalUnit unit) get(TemporalField field)getLong(TemporalField field)getHour()getMinute()getNano()getSecond() minus(long amountToSubtract, TemporalUnit unit)minus(TemporalAmount amountToSubtract)minusHours(long hoursToSubtract)minusMinutes(long minutesToSubtract)minusNanos(long nanosToSubtract)minusSeconds(long secondsToSubtract) plus(long amountToSubtract, TemporalUnit unit)plus(TemporalAmount amountToSubtract)plusHours(long hoursToAdd)plusMinutes(long minutesToAdd)plusNanos(long nanosToAdd)plusSeconds(long secondstoAdd) toSecondOfDay()toNanoOfDay() query(TemporalQuery&lt;R&gt; query) range(TemporalField field) truncatedTo(TemporalUnit unit) until(Temporal endExclusive, TemporalUnit unit) with(TemporalField field, long newValue)withHour(int hour)withMinute(int minute)withNano(int nanoOfSecond)withSecond(int second)with(TemporalAdjuster adjuster) 未演示方法 adjustInto(Temporal temporal) equals(Object obj) hashCode() toString() 参考文献"},{"title":"【Java 8 新特性】时间类：LocalDate","date":"2023-05-03T16:00:00.000Z","url":"/blog/2023/05/04/Java8/time/LocalDate/","tags":[["Java","/blog/tags/Java/"]],"categories":[["Java","/blog/categories/Java/"]],"content":"LocalDate 类用来表示日期，由三个成员变量 year 、 month 、 day 组成，大部分成员方法是操作三个成员变量的过程，如查询由这三个变量组成的其他的时间分量，对三个变量进行加、减或重新赋予新值等等操作。 公共常量 静态方法from(TemporalAccessor temporal) now()now(ZoneId zone)now(Clock clock) of(int year, int month, int dayOfMonth)of(int year, Month month, int dayOfMonth) ofEpochDay(long epochDay)ofYearDay(int year, int dayOfYear) parse(CharSequence text)parse(CharSequence text, DateTimeFormatter formatter) 成员方法atStartOfDay()atStartOfDay(ZoneId zone) atTime(int hour, int minute)atTime(int hour, int minute, int second)atTime(int hour, int minute, int second, int nanoOfSecond)atTime(LocalTime time)atTime(OffsetTime time) compareTo(ChronoLocalDate other)isAfter(ChronoLocalDate other)isBefore(ChronoLocalDate other)isEqual(ChronoLocalDate other) format(DateTimeFormatter formatter) isSupported(TemporalField field)isSupported(TemporalUnit unit) get(TemporalField field)getLong(TemporalField field)getDayOfMonth()getDayOfWeek()getDayOfYear()getEra()getMonth()getMonthValue()getYear() isLeapYear() lengthOfMonth()lengthOfYear() minus(long amountToSubtract, TemporalUnit unit)minus(TemporalAmount amountToSubtract)minusDays(long daysToSubtract)minusMonths(long monthsToSubtract)minusWeeks(long weeksToSubtract)minusYears(long yearsToSubtract) plus(long amountToSubtract, TemporalUnit unit)plus(TemporalAmount amountToSubtract)plusDays(long daysToSubtract)plusMonths(long monthsToSubtract)plusWeeks(long weeksToSubtract)plusYears(long yearsToSubtract) query(TemporalQuery&lt;R&gt; query) range(TemporalField field) toEpochDay() until(ChronoLocalDate endDateExclusive)until(Temporal endExclusive, TemporalUnit unit) with(TemporalField field, long newValue)withDayOfMonth(int dayOfMonth)withDayOfYear(int dayOfYear)withMonth(int month)withYear(int year)with(TemporalAdjuster adjuster) 未演示方法 adjustInto(Temporal temporal) equals(Object obj) getChronology() hashCode() 参考文献"}]